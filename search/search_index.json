{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Splunk Solutions SDK is an open source packaged solution for getting data into Splunk using modular inputs. This SDK is used by Splunk Add-on builder, and Splunk UCC based add-ons and is intended for use by partner developers. This SDK/Library extends the Splunk SDK for Python.</p> <p>Note: this project uses <code>poetry</code> 1.5.1.</p>"},{"location":"acl/","title":"acl.py","text":"<p>This module contains interfaces that support CRUD operations on ACL.</p>"},{"location":"acl/#solnlib.acl.__all__","title":"<code>__all__ = ['ACLException', 'ACLManager']</code>  <code>module-attribute</code>","text":""},{"location":"acl/#solnlib.acl.ACLException","title":"<code>ACLException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised by ACLManager.</p> Source code in <code>solnlib/acl.py</code> <pre><code>class ACLException(Exception):\n\"\"\"Exception raised by ACLManager.\"\"\"\n\n    pass\n</code></pre>"},{"location":"acl/#solnlib.acl.ACLManager","title":"<code>ACLManager</code>","text":"<p>ACL manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import solnlib.acl as sacl\n&gt;&gt;&gt; saclm = sacl.ACLManager(session_key, 'Splunk_TA_test')\n&gt;&gt;&gt; saclm.get('data/transforms/extractions')\n&gt;&gt;&gt; saclm.update('data/transforms/extractions/_acl',\n                 perms_read=['*'], perms_write=['*'])\n</code></pre> Source code in <code>solnlib/acl.py</code> <pre><code>class ACLManager:\n\"\"\"ACL manager.\n\n    Examples:\n       &gt;&gt;&gt; import solnlib.acl as sacl\n       &gt;&gt;&gt; saclm = sacl.ACLManager(session_key, 'Splunk_TA_test')\n       &gt;&gt;&gt; saclm.get('data/transforms/extractions')\n       &gt;&gt;&gt; saclm.update('data/transforms/extractions/_acl',\n                        perms_read=['*'], perms_write=['*'])\n    \"\"\"\n\n    def __init__(\n        self,\n        session_key: str,\n        app: str,\n        owner: str = \"nobody\",\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        **context: dict\n    ):\n\"\"\"Initializes ACLManager.\n\n        Arguments:\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        self._rest_client = rest_client.SplunkRestClient(\n            session_key,\n            app,\n            owner=owner,\n            scheme=scheme,\n            host=host,\n            port=port,\n            **context\n        )\n\n    @retry(exceptions=[binding.HTTPError])\n    def get(self, path: str) -&gt; dict:\n\"\"\"Get ACL of  /servicesNS/{`owner`}/{`app`}/{`path`}.\n\n        Arguments:\n            path: Path of ACL relative to /servicesNS/{`owner`}/{`app`}\n\n        Returns:\n            A dict contains ACL.\n\n        Raises:\n            ACLException: If `path` is invalid.\n\n        Examples:\n           &gt;&gt;&gt; aclm = acl.ACLManager(session_key, 'Splunk_TA_test')\n           &gt;&gt;&gt; perms = aclm.get('data/transforms/extractions/_acl')\n        \"\"\"\n\n        try:\n            content = self._rest_client.get(path, output_mode=\"json\").body.read()\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise ACLException(\"Invalid endpoint: %s.\", path)\n\n        return json.loads(content)[\"entry\"][0][\"acl\"]\n\n    @retry(exceptions=[binding.HTTPError])\n    def update(\n        self,\n        path: str,\n        owner: str = None,\n        perms_read: List = None,\n        perms_write: List = None,\n    ) -&gt; dict:\n\"\"\"Update ACL of /servicesNS/{`owner`}/{`app`}/{`path`}.\n\n        If the ACL is per-entity (ends in /acl), owner can be reassigned. If\n        the acl is endpoint-level (ends in _acl), owner will be ignored. The\n        'sharing' setting is always retrieved from the current.\n\n        Arguments:\n            path: Path of ACL relative to /servicesNS/{owner}/{app}. MUST\n                end with /acl or /_acl indicating whether the permission is applied\n                at the per-entity level or endpoint level respectively.\n            owner: (optional) New owner of ACL, default is `nobody`.\n            perms_read: (optional) List of roles (['*'] for all roles). If\n                unspecified we will POST with current (if available) perms.read,\n                default is None.\n            perms_write: (optional) List of roles (['*'] for all roles). If\n                unspecified we will POST with current (if available) perms.write,\n                default is None.\n\n        Returns:\n            A dict contains ACL after update.\n\n        Raises:\n            ACLException: If `path` is invalid.\n\n        Examples:\n           &gt;&gt;&gt; aclm = acl.ACLManager(session_key, 'Splunk_TA_test')\n           &gt;&gt;&gt; perms = aclm.update('data/transforms/extractions/_acl',\n                                   perms_read=['admin'], perms_write=['admin'])\n        \"\"\"\n\n        if not path.endswith(\"/acl\") and not path.endswith(\"/_acl\"):\n            raise ACLException(\n                \"Invalid endpoint: %s, must end with /acl or /_acl.\" % path\n            )\n\n        curr_acl = self.get(path)\n\n        postargs = {}\n        if perms_read:\n            postargs[\"perms.read\"] = \",\".join(perms_read)\n        else:\n            curr_read = curr_acl[\"perms\"].get(\"read\", [])\n            if curr_read:\n                postargs[\"perms.read\"] = \",\".join(curr_read)\n\n        if perms_write:\n            postargs[\"perms.write\"] = \",\".join(perms_write)\n        else:\n            curr_write = curr_acl[\"perms\"].get(\"write\", [])\n            if curr_write:\n                postargs[\"perms.write\"] = \",\".join(curr_write)\n\n        if path.endswith(\"/acl\"):\n            # Allow ownership to be reset only at entity level.\n            postargs[\"owner\"] = owner or curr_acl[\"owner\"]\n\n        postargs[\"sharing\"] = curr_acl[\"sharing\"]\n\n        try:\n            content = self._rest_client.post(\n                path, body=binding._encode(**postargs), output_mode=\"json\"\n            ).body.read()\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise ACLException(\"Invalid endpoint: %s.\", path)\n\n        return json.loads(content)[\"entry\"][0][\"acl\"]\n</code></pre>"},{"location":"acl/#solnlib.acl.ACLManager.__init__","title":"<code>__init__(session_key, app, owner='nobody', scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes ACLManager.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>str</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/acl.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    app: str,\n    owner: str = \"nobody\",\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict\n):\n\"\"\"Initializes ACLManager.\n\n    Arguments:\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    self._rest_client = rest_client.SplunkRestClient(\n        session_key,\n        app,\n        owner=owner,\n        scheme=scheme,\n        host=host,\n        port=port,\n        **context\n    )\n</code></pre>"},{"location":"acl/#solnlib.acl.ACLManager.get","title":"<code>get(path)</code>","text":"<p>Get ACL of  /servicesNS/{<code>owner</code>}/{<code>app</code>}/{<code>path</code>}.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path of ACL relative to /servicesNS/{<code>owner</code>}/{<code>app</code>}</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dict contains ACL.</p> <p>Raises:</p> Type Description <code>ACLException</code> <p>If <code>path</code> is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; aclm = acl.ACLManager(session_key, 'Splunk_TA_test')\n&gt;&gt;&gt; perms = aclm.get('data/transforms/extractions/_acl')\n</code></pre> Source code in <code>solnlib/acl.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get(self, path: str) -&gt; dict:\n\"\"\"Get ACL of  /servicesNS/{`owner`}/{`app`}/{`path`}.\n\n    Arguments:\n        path: Path of ACL relative to /servicesNS/{`owner`}/{`app`}\n\n    Returns:\n        A dict contains ACL.\n\n    Raises:\n        ACLException: If `path` is invalid.\n\n    Examples:\n       &gt;&gt;&gt; aclm = acl.ACLManager(session_key, 'Splunk_TA_test')\n       &gt;&gt;&gt; perms = aclm.get('data/transforms/extractions/_acl')\n    \"\"\"\n\n    try:\n        content = self._rest_client.get(path, output_mode=\"json\").body.read()\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise ACLException(\"Invalid endpoint: %s.\", path)\n\n    return json.loads(content)[\"entry\"][0][\"acl\"]\n</code></pre>"},{"location":"acl/#solnlib.acl.ACLManager.update","title":"<code>update(path, owner=None, perms_read=None, perms_write=None)</code>","text":"<p>Update ACL of /servicesNS/{<code>owner</code>}/{<code>app</code>}/{<code>path</code>}.</p> <p>If the ACL is per-entity (ends in /acl), owner can be reassigned. If the acl is endpoint-level (ends in _acl), owner will be ignored. The \u2018sharing\u2019 setting is always retrieved from the current.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path of ACL relative to /servicesNS/{owner}/{app}. MUST end with /acl or /_acl indicating whether the permission is applied at the per-entity level or endpoint level respectively.</p> required <code>owner</code> <code>str</code> <p>(optional) New owner of ACL, default is <code>nobody</code>.</p> <code>None</code> <code>perms_read</code> <code>List</code> <p>(optional) List of roles ([\u2018*\u2019] for all roles). If unspecified we will POST with current (if available) perms.read, default is None.</p> <code>None</code> <code>perms_write</code> <code>List</code> <p>(optional) List of roles ([\u2018*\u2019] for all roles). If unspecified we will POST with current (if available) perms.write, default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dict contains ACL after update.</p> <p>Raises:</p> Type Description <code>ACLException</code> <p>If <code>path</code> is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; aclm = acl.ACLManager(session_key, 'Splunk_TA_test')\n&gt;&gt;&gt; perms = aclm.update('data/transforms/extractions/_acl',\n                        perms_read=['admin'], perms_write=['admin'])\n</code></pre> Source code in <code>solnlib/acl.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef update(\n    self,\n    path: str,\n    owner: str = None,\n    perms_read: List = None,\n    perms_write: List = None,\n) -&gt; dict:\n\"\"\"Update ACL of /servicesNS/{`owner`}/{`app`}/{`path`}.\n\n    If the ACL is per-entity (ends in /acl), owner can be reassigned. If\n    the acl is endpoint-level (ends in _acl), owner will be ignored. The\n    'sharing' setting is always retrieved from the current.\n\n    Arguments:\n        path: Path of ACL relative to /servicesNS/{owner}/{app}. MUST\n            end with /acl or /_acl indicating whether the permission is applied\n            at the per-entity level or endpoint level respectively.\n        owner: (optional) New owner of ACL, default is `nobody`.\n        perms_read: (optional) List of roles (['*'] for all roles). If\n            unspecified we will POST with current (if available) perms.read,\n            default is None.\n        perms_write: (optional) List of roles (['*'] for all roles). If\n            unspecified we will POST with current (if available) perms.write,\n            default is None.\n\n    Returns:\n        A dict contains ACL after update.\n\n    Raises:\n        ACLException: If `path` is invalid.\n\n    Examples:\n       &gt;&gt;&gt; aclm = acl.ACLManager(session_key, 'Splunk_TA_test')\n       &gt;&gt;&gt; perms = aclm.update('data/transforms/extractions/_acl',\n                               perms_read=['admin'], perms_write=['admin'])\n    \"\"\"\n\n    if not path.endswith(\"/acl\") and not path.endswith(\"/_acl\"):\n        raise ACLException(\n            \"Invalid endpoint: %s, must end with /acl or /_acl.\" % path\n        )\n\n    curr_acl = self.get(path)\n\n    postargs = {}\n    if perms_read:\n        postargs[\"perms.read\"] = \",\".join(perms_read)\n    else:\n        curr_read = curr_acl[\"perms\"].get(\"read\", [])\n        if curr_read:\n            postargs[\"perms.read\"] = \",\".join(curr_read)\n\n    if perms_write:\n        postargs[\"perms.write\"] = \",\".join(perms_write)\n    else:\n        curr_write = curr_acl[\"perms\"].get(\"write\", [])\n        if curr_write:\n            postargs[\"perms.write\"] = \",\".join(curr_write)\n\n    if path.endswith(\"/acl\"):\n        # Allow ownership to be reset only at entity level.\n        postargs[\"owner\"] = owner or curr_acl[\"owner\"]\n\n    postargs[\"sharing\"] = curr_acl[\"sharing\"]\n\n    try:\n        content = self._rest_client.post(\n            path, body=binding._encode(**postargs), output_mode=\"json\"\n        ).body.read()\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise ACLException(\"Invalid endpoint: %s.\", path)\n\n    return json.loads(content)[\"entry\"][0][\"acl\"]\n</code></pre>"},{"location":"bulletin_rest_client/","title":"bulletin_rest_client.py","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.__all__","title":"<code>__all__ = ['BulletinRestClient']</code>  <code>module-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient","title":"<code>BulletinRestClient</code>","text":"<p>REST client for handling Bulletin messages.</p> Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>class BulletinRestClient:\n\"\"\"REST client for handling Bulletin messages.\"\"\"\n\n    MESSAGES_ENDPOINT = \"/services/messages\"\n\n    headers = [(\"Content-Type\", \"application/json\")]\n\n    class Severity:\n        INFO = \"info\"\n        WARNING = \"warn\"\n        ERROR = \"error\"\n\n    def __init__(\n        self,\n        message_name: str,\n        session_key: str,\n        app: str,\n        **context: dict,\n    ):\n\"\"\"Initializes BulletinRestClient.\n            When creating a new bulletin message, you must provide a name, which is a kind of ID.\n            If you try to create another message with the same name (ID), the API will not add another message\n            to the bulletin, but it will overwrite the existing one. Similar behaviour applies to deletion.\n            To delete a message, you must indicate the name (ID) of the message.\n            To provide better and easier control over bulletin messages, this client works in such a way\n            that there is one instance responsible for handling one specific message.\n            If you need to add another message to bulletin create another instance\n            with a different 'message_name'\n            e.g.\n            msg_1 = BulletinRestClient(\"message_1\", \"&lt;some session key&gt;\")\n            msg_2 = BulletinRestClient(\"message_2\", \"&lt;some session key&gt;\")\n\n        Arguments:\n            message_name: Name of the message in the Splunk's bulletin.\n            session_key: Splunk access token.\n            app: App name of namespace.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n\n        self.message_name = message_name\n        self.session_key = session_key\n        self.app = app\n\n        self._rest_client = rest_client.SplunkRestClient(\n            self.session_key, app=self.app, **context\n        )\n\n    def create_message(\n        self,\n        msg: str,\n        severity: Severity = Severity.WARNING,\n        capabilities: Optional[List[str]] = None,\n        roles: Optional[List] = None,\n    ):\n\"\"\"Creates a message in the Splunk's bulletin. Calling this method\n        multiple times for the same instance will overwrite existing message.\n\n        Arguments:\n            msg: The message which will be displayed in the Splunk's bulletin\n            severity: Severity level of the message. It has to be one of: 'info', 'warn', 'error'.\n                If wrong severity is given, ValueError will be raised.\n            capabilities: One or more capabilities that users must have to view the message.\n                Capability names are validated.\n                This argument should be provided as a list of string/s e.g. capabilities=['one', 'two'].\n                If a non-existent capability is used, HTTP 400 BAD REQUEST exception will be raised.\n                If argument is not a List[str] ValueError will be raised.\n            roles: One or more roles that users must have to view the message. Role names are validated.\n                This argument should be provided as a list of string/s e.g. roles=['user', 'admin'].\n                If a non-existent role is used, HTTP 400 BAD REQUEST exception will be raised.\n                If argument is not a List[str] ValueError will be raised.\n        \"\"\"\n        body = {\n            \"name\": self.message_name,\n            \"value\": msg,\n            \"severity\": severity,\n            \"capability\": [],\n            \"role\": [],\n        }\n\n        if severity not in (\n            self.Severity.INFO,\n            self.Severity.WARNING,\n            self.Severity.ERROR,\n        ):\n            raise ValueError(\n                \"Severity must be one of (\"\n                \"'BulletinRestClient.Severity.INFO', \"\n                \"'BulletinRestClient.Severity.WARNING', \"\n                \"'BulletinRestClient.Severity.ERROR'\"\n                \").\"\n            )\n\n        if capabilities:\n            body[\"capability\"] = self._validate_and_get_body_value(\n                capabilities, \"Capabilities must be a list of strings.\"\n            )\n\n        if roles:\n            body[\"role\"] = self._validate_and_get_body_value(\n                roles, \"Roles must be a list of strings.\"\n            )\n\n        self._rest_client.post(self.MESSAGES_ENDPOINT, body=body, headers=self.headers)\n\n    def get_message(self):\n\"\"\"Get specific message created by this instance.\"\"\"\n        endpoint = f\"{self.MESSAGES_ENDPOINT}/{self.message_name}\"\n        response = self._rest_client.get(endpoint, output_mode=\"json\").body.read()\n        return json.loads(response)\n\n    def get_all_messages(self):\n\"\"\"Get all messages in the bulletin.\"\"\"\n        response = self._rest_client.get(\n            self.MESSAGES_ENDPOINT, output_mode=\"json\"\n        ).body.read()\n        return json.loads(response)\n\n    def delete_message(self):\n\"\"\"Delete specific message created by this instance.\"\"\"\n        endpoint = f\"{self.MESSAGES_ENDPOINT}/{self.message_name}\"\n        self._rest_client.delete(endpoint)\n\n    @staticmethod\n    def _validate_and_get_body_value(arg, error_msg) -&gt; List:\n        if type(arg) is list and (all(isinstance(el, str) for el in arg)):\n            return [el for el in arg]\n        else:\n            raise ValueError(error_msg)\n</code></pre>"},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.MESSAGES_ENDPOINT","title":"<code>MESSAGES_ENDPOINT = '/services/messages'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.app","title":"<code>app = app</code>  <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.headers","title":"<code>headers = [('Content-Type', 'application/json')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.message_name","title":"<code>message_name = message_name</code>  <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.session_key","title":"<code>session_key = session_key</code>  <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.Severity","title":"<code>Severity</code>","text":"Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>class Severity:\n    INFO = \"info\"\n    WARNING = \"warn\"\n    ERROR = \"error\"\n</code></pre>"},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.Severity.ERROR","title":"<code>ERROR = 'error'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.Severity.INFO","title":"<code>INFO = 'info'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.Severity.WARNING","title":"<code>WARNING = 'warn'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.__init__","title":"<code>__init__(message_name, session_key, app, **context)</code>","text":"<p>Initializes BulletinRestClient.     When creating a new bulletin message, you must provide a name, which is a kind of ID.     If you try to create another message with the same name (ID), the API will not add another message     to the bulletin, but it will overwrite the existing one. Similar behaviour applies to deletion.     To delete a message, you must indicate the name (ID) of the message.     To provide better and easier control over bulletin messages, this client works in such a way     that there is one instance responsible for handling one specific message.     If you need to add another message to bulletin create another instance     with a different \u2018message_name\u2019     e.g.     msg_1 = BulletinRestClient(\u201cmessage_1\u201d, \u201c\u201c)     msg_2 = BulletinRestClient(\u201cmessage_2\u201d, \u201c\u201c) <p>Parameters:</p> Name Type Description Default <code>message_name</code> <code>str</code> <p>Name of the message in the Splunk\u2019s bulletin.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>def __init__(\n    self,\n    message_name: str,\n    session_key: str,\n    app: str,\n    **context: dict,\n):\n\"\"\"Initializes BulletinRestClient.\n        When creating a new bulletin message, you must provide a name, which is a kind of ID.\n        If you try to create another message with the same name (ID), the API will not add another message\n        to the bulletin, but it will overwrite the existing one. Similar behaviour applies to deletion.\n        To delete a message, you must indicate the name (ID) of the message.\n        To provide better and easier control over bulletin messages, this client works in such a way\n        that there is one instance responsible for handling one specific message.\n        If you need to add another message to bulletin create another instance\n        with a different 'message_name'\n        e.g.\n        msg_1 = BulletinRestClient(\"message_1\", \"&lt;some session key&gt;\")\n        msg_2 = BulletinRestClient(\"message_2\", \"&lt;some session key&gt;\")\n\n    Arguments:\n        message_name: Name of the message in the Splunk's bulletin.\n        session_key: Splunk access token.\n        app: App name of namespace.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n\n    self.message_name = message_name\n    self.session_key = session_key\n    self.app = app\n\n    self._rest_client = rest_client.SplunkRestClient(\n        self.session_key, app=self.app, **context\n    )\n</code></pre>"},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.create_message","title":"<code>create_message(msg, severity=Severity.WARNING, capabilities=None, roles=None)</code>","text":"<p>Creates a message in the Splunk\u2019s bulletin. Calling this method multiple times for the same instance will overwrite existing message.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message which will be displayed in the Splunk\u2019s bulletin</p> required <code>severity</code> <code>Severity</code> <p>Severity level of the message. It has to be one of: \u2018info\u2019, \u2018warn\u2019, \u2018error\u2019. If wrong severity is given, ValueError will be raised.</p> <code>Severity.WARNING</code> <code>capabilities</code> <code>Optional[List[str]]</code> <p>One or more capabilities that users must have to view the message. Capability names are validated. This argument should be provided as a list of string/s e.g. capabilities=[\u2018one\u2019, \u2018two\u2019]. If a non-existent capability is used, HTTP 400 BAD REQUEST exception will be raised. If argument is not a List[str] ValueError will be raised.</p> <code>None</code> <code>roles</code> <code>Optional[List]</code> <p>One or more roles that users must have to view the message. Role names are validated. This argument should be provided as a list of string/s e.g. roles=[\u2018user\u2019, \u2018admin\u2019]. If a non-existent role is used, HTTP 400 BAD REQUEST exception will be raised. If argument is not a List[str] ValueError will be raised.</p> <code>None</code> Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>def create_message(\n    self,\n    msg: str,\n    severity: Severity = Severity.WARNING,\n    capabilities: Optional[List[str]] = None,\n    roles: Optional[List] = None,\n):\n\"\"\"Creates a message in the Splunk's bulletin. Calling this method\n    multiple times for the same instance will overwrite existing message.\n\n    Arguments:\n        msg: The message which will be displayed in the Splunk's bulletin\n        severity: Severity level of the message. It has to be one of: 'info', 'warn', 'error'.\n            If wrong severity is given, ValueError will be raised.\n        capabilities: One or more capabilities that users must have to view the message.\n            Capability names are validated.\n            This argument should be provided as a list of string/s e.g. capabilities=['one', 'two'].\n            If a non-existent capability is used, HTTP 400 BAD REQUEST exception will be raised.\n            If argument is not a List[str] ValueError will be raised.\n        roles: One or more roles that users must have to view the message. Role names are validated.\n            This argument should be provided as a list of string/s e.g. roles=['user', 'admin'].\n            If a non-existent role is used, HTTP 400 BAD REQUEST exception will be raised.\n            If argument is not a List[str] ValueError will be raised.\n    \"\"\"\n    body = {\n        \"name\": self.message_name,\n        \"value\": msg,\n        \"severity\": severity,\n        \"capability\": [],\n        \"role\": [],\n    }\n\n    if severity not in (\n        self.Severity.INFO,\n        self.Severity.WARNING,\n        self.Severity.ERROR,\n    ):\n        raise ValueError(\n            \"Severity must be one of (\"\n            \"'BulletinRestClient.Severity.INFO', \"\n            \"'BulletinRestClient.Severity.WARNING', \"\n            \"'BulletinRestClient.Severity.ERROR'\"\n            \").\"\n        )\n\n    if capabilities:\n        body[\"capability\"] = self._validate_and_get_body_value(\n            capabilities, \"Capabilities must be a list of strings.\"\n        )\n\n    if roles:\n        body[\"role\"] = self._validate_and_get_body_value(\n            roles, \"Roles must be a list of strings.\"\n        )\n\n    self._rest_client.post(self.MESSAGES_ENDPOINT, body=body, headers=self.headers)\n</code></pre>"},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.delete_message","title":"<code>delete_message()</code>","text":"<p>Delete specific message created by this instance.</p> Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>def delete_message(self):\n\"\"\"Delete specific message created by this instance.\"\"\"\n    endpoint = f\"{self.MESSAGES_ENDPOINT}/{self.message_name}\"\n    self._rest_client.delete(endpoint)\n</code></pre>"},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.get_all_messages","title":"<code>get_all_messages()</code>","text":"<p>Get all messages in the bulletin.</p> Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>def get_all_messages(self):\n\"\"\"Get all messages in the bulletin.\"\"\"\n    response = self._rest_client.get(\n        self.MESSAGES_ENDPOINT, output_mode=\"json\"\n    ).body.read()\n    return json.loads(response)\n</code></pre>"},{"location":"bulletin_rest_client/#solnlib.bulletin_rest_client.BulletinRestClient.get_message","title":"<code>get_message()</code>","text":"<p>Get specific message created by this instance.</p> Source code in <code>solnlib/bulletin_rest_client.py</code> <pre><code>def get_message(self):\n\"\"\"Get specific message created by this instance.\"\"\"\n    endpoint = f\"{self.MESSAGES_ENDPOINT}/{self.message_name}\"\n    response = self._rest_client.get(endpoint, output_mode=\"json\").body.read()\n    return json.loads(response)\n</code></pre>"},{"location":"conf_manager/","title":"conf_manager.py","text":"<p>This module contains simple interfaces for Splunk config file management, you can update/get/delete stanzas and encrypt/decrypt some fields of stanza automatically.</p>"},{"location":"conf_manager/#solnlib.conf_manager.__all__","title":"<code>__all__ = ['ConfFile', 'ConfManager']</code>  <code>module-attribute</code>","text":""},{"location":"conf_manager/#solnlib.conf_manager.ConfFile","title":"<code>ConfFile</code>","text":"<p>Configuration file.</p> Source code in <code>solnlib/conf_manager.py</code> <pre><code>class ConfFile:\n\"\"\"Configuration file.\"\"\"\n\n    ENCRYPTED_TOKEN = \"******\"\n\n    reserved_keys = (\"userName\", \"appName\")\n\n    def __init__(\n        self,\n        name: str,\n        conf: client.ConfigurationFile,\n        session_key: str,\n        app: str,\n        owner: str = \"nobody\",\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        realm: str = None,\n        **context: dict,\n    ):\n\"\"\"Initializes ConfFile.\n\n        Arguments:\n            name: Configuration file name.\n            conf: Configuration file object.\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            realm: (optional) Realm of credential, default is None.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        self._name = name\n        self._conf = conf\n        self._session_key = session_key\n        self._app = app\n        self._owner = owner\n        self._scheme = scheme\n        self._host = host\n        self._port = port\n        self._context = context\n        self._cred_manager = None\n        # 'realm' is set to provided 'realm' argument otherwise as default\n        # behaviour it is set to 'APP_NAME'.\n        if realm is None:\n            self._realm = self._app\n        else:\n            self._realm = realm\n\n    @property\n    @retry(exceptions=[binding.HTTPError])\n    def _cred_mgr(self):\n        if self._cred_manager is None:\n            self._cred_manager = CredentialManager(\n                self._session_key,\n                self._app,\n                owner=self._owner,\n                realm=self._realm,\n                scheme=self._scheme,\n                host=self._host,\n                port=self._port,\n                **self._context,\n            )\n\n        return self._cred_manager\n\n    def _filter_stanza(self, stanza):\n        for k in self.reserved_keys:\n            if k in stanza:\n                del stanza[k]\n\n        return stanza\n\n    def _encrypt_stanza(self, stanza_name, stanza, encrypt_keys):\n        if not encrypt_keys:\n            return stanza\n\n        encrypt_stanza_keys = [k for k in encrypt_keys if k in stanza]\n        encrypt_fields = {key: stanza[key] for key in encrypt_stanza_keys}\n        if not encrypt_fields:\n            return stanza\n        self._cred_mgr.set_password(stanza_name, json.dumps(encrypt_fields))\n\n        for key in encrypt_stanza_keys:\n            stanza[key] = self.ENCRYPTED_TOKEN\n\n        return stanza\n\n    def _decrypt_stanza(self, stanza_name, encrypted_stanza):\n        encrypted_keys = [\n            key\n            for key in encrypted_stanza\n            if encrypted_stanza[key] == self.ENCRYPTED_TOKEN\n        ]\n        if encrypted_keys:\n            encrypted_fields = json.loads(self._cred_mgr.get_password(stanza_name))\n            for key in encrypted_keys:\n                encrypted_stanza[key] = encrypted_fields[key]\n\n        return encrypted_stanza\n\n    def _delete_stanza_creds(self, stanza_name):\n        self._cred_mgr.delete_password(stanza_name)\n\n    @retry(exceptions=[binding.HTTPError])\n    def stanza_exist(self, stanza_name: str) -&gt; bool:\n\"\"\"Check whether stanza exists.\n\n        Arguments:\n            stanza_name: Stanza name.\n\n        Returns:\n            True if stanza exists else False.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import conf_manager\n           &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                              'Splunk_TA_test')\n           &gt;&gt;&gt; conf = cfm.get_conf('test')\n           &gt;&gt;&gt; conf.stanza_exist('test_stanza')\n        \"\"\"\n\n        try:\n            self._conf.list(name=stanza_name)[0]\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            return False\n\n        return True\n\n    @retry(exceptions=[binding.HTTPError])\n    def get(self, stanza_name: str, only_current_app: bool = False) -&gt; dict:\n\"\"\"Get stanza from configuration file.\n\n        Result is like:\n\n            {\n                'disabled': '0',\n                'eai:appName': 'solnlib_demo',\n                'eai:userName': 'nobody',\n                'k1': '1',\n                'k2': '2'\n            }\n\n        Arguments:\n            stanza_name: Stanza name.\n            only_current_app: Only include current app.\n\n        Returns:\n            Stanza.\n\n        Raises:\n            ConfStanzaNotExistException: If stanza does not exist.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import conf_manager\n           &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                              'Splunk_TA_test')\n           &gt;&gt;&gt; conf = cfm.get_conf('test')\n           &gt;&gt;&gt; conf.get('test_stanza')\n        \"\"\"\n\n        try:\n            if only_current_app:\n                stanza_mgrs = self._conf.list(\n                    search=\"eai:acl.app={} name={}\".format(\n                        self._app, stanza_name.replace(\"=\", r\"\\=\")\n                    )\n                )\n            else:\n                stanza_mgrs = self._conf.list(name=stanza_name)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise ConfStanzaNotExistException(\n                f\"Stanza: {stanza_name} does not exist in {self._name}.conf\"\n            )\n\n        if len(stanza_mgrs) == 0:\n            raise ConfStanzaNotExistException(\n                f\"Stanza: {stanza_name} does not exist in {self._name}.conf\"\n            )\n\n        stanza = self._decrypt_stanza(stanza_mgrs[0].name, stanza_mgrs[0].content)\n        stanza[\"eai:access\"] = stanza_mgrs[0].access\n        stanza[\"eai:appName\"] = stanza_mgrs[0].access.app\n        return stanza\n\n    @retry(exceptions=[binding.HTTPError])\n    def get_all(self, only_current_app: bool = False) -&gt; dict:\n\"\"\"Get all stanzas from configuration file.\n\n        Result is like:\n\n            {\n                'test':\n                    {\n                        'disabled': '0',\n                        'eai:appName': 'solnlib_demo',\n                        'eai:userName': 'nobody',\n                        'k1': '1',\n                        'k2': '2'\n                    }\n            }\n\n        Arguments:\n            only_current_app: Only include current app.\n\n        Returns:\n            Dict of stanzas.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import conf_manager\n           &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                              'Splunk_TA_test')\n           &gt;&gt;&gt; conf = cfm.get_conf('test')\n           &gt;&gt;&gt; conf.get_all()\n        \"\"\"\n\n        if only_current_app:\n            stanza_mgrs = self._conf.list(search=f\"eai:acl.app={self._app}\")\n        else:\n            stanza_mgrs = self._conf.list()\n        res = {}\n        for stanza_mgr in stanza_mgrs:\n            name = stanza_mgr.name\n            key_values = self._decrypt_stanza(name, stanza_mgr.content)\n            key_values[\"eai:access\"] = stanza_mgr.access\n            key_values[\"eai:appName\"] = stanza_mgr.access.app\n            res[name] = key_values\n        return res\n\n    @retry(exceptions=[binding.HTTPError])\n    def update(self, stanza_name: str, stanza: dict, encrypt_keys: List[str] = None):\n\"\"\"Update stanza.\n\n        It will try to encrypt the credential automatically fist if\n        encrypt_keys are not None else keep stanza untouched.\n\n        Arguments:\n            stanza_name: Stanza name.\n            stanza: Stanza to update.\n            encrypt_keys: Field names to encrypt.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import conf_manager\n           &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                              'Splunk_TA_test')\n           &gt;&gt;&gt; conf = cfm.get_conf('test')\n           &gt;&gt;&gt; conf.update('test_stanza', {'k1': 1, 'k2': 2}, ['k1'])\n        \"\"\"\n\n        stanza = self._filter_stanza(stanza)\n        encrypted_stanza = self._encrypt_stanza(stanza_name, stanza, encrypt_keys)\n\n        try:\n            stanza_mgr = self._conf.list(name=stanza_name)[0]\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            stanza_mgr = self._conf.create(stanza_name)\n\n        stanza_mgr.submit(encrypted_stanza)\n\n    @retry(exceptions=[binding.HTTPError])\n    def delete(self, stanza_name: str):\n\"\"\"Delete stanza.\n\n        Arguments:\n            stanza_name: Stanza name to delete.\n\n        Raises:\n            ConfStanzaNotExistException: If stanza does not exist.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import conf_manager\n           &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                              'Splunk_TA_test')\n           &gt;&gt;&gt; conf = cfm.get_conf('test')\n           &gt;&gt;&gt; conf.delete('test_stanza')\n        \"\"\"\n\n        try:\n            self._cred_mgr.delete_password(stanza_name)\n        except CredentialNotExistException:\n            pass\n\n        try:\n            self._conf.delete(stanza_name)\n        except KeyError:\n            logging.error(\n                \"Delete stanza: %s error: %s.\", stanza_name, traceback.format_exc()\n            )\n            raise ConfStanzaNotExistException(\n                f\"Stanza: {stanza_name} does not exist in {self._name}.conf\"\n            )\n\n    @retry(exceptions=[binding.HTTPError])\n    def reload(self):\n\"\"\"Reload configuration file.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import conf_manager\n           &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                              'Splunk_TA_test')\n           &gt;&gt;&gt; conf = cfm.get_conf('test')\n           &gt;&gt;&gt; conf.reload()\n        \"\"\"\n\n        self._conf.get(\"_reload\")\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.ENCRYPTED_TOKEN","title":"<code>ENCRYPTED_TOKEN = '******'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.reserved_keys","title":"<code>reserved_keys = ('userName', 'appName')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.__init__","title":"<code>__init__(name, conf, session_key, app, owner='nobody', scheme=None, host=None, port=None, realm=None, **context)</code>","text":"<p>Initializes ConfFile.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Configuration file name.</p> required <code>conf</code> <code>client.ConfigurationFile</code> <p>Configuration file object.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>str</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>realm</code> <code>str</code> <p>(optional) Realm of credential, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/conf_manager.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    conf: client.ConfigurationFile,\n    session_key: str,\n    app: str,\n    owner: str = \"nobody\",\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    realm: str = None,\n    **context: dict,\n):\n\"\"\"Initializes ConfFile.\n\n    Arguments:\n        name: Configuration file name.\n        conf: Configuration file object.\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        realm: (optional) Realm of credential, default is None.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    self._name = name\n    self._conf = conf\n    self._session_key = session_key\n    self._app = app\n    self._owner = owner\n    self._scheme = scheme\n    self._host = host\n    self._port = port\n    self._context = context\n    self._cred_manager = None\n    # 'realm' is set to provided 'realm' argument otherwise as default\n    # behaviour it is set to 'APP_NAME'.\n    if realm is None:\n        self._realm = self._app\n    else:\n        self._realm = realm\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.delete","title":"<code>delete(stanza_name)</code>","text":"<p>Delete stanza.</p> <p>Parameters:</p> Name Type Description Default <code>stanza_name</code> <code>str</code> <p>Stanza name to delete.</p> required <p>Raises:</p> Type Description <code>ConfStanzaNotExistException</code> <p>If stanza does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                   'Splunk_TA_test')\n&gt;&gt;&gt; conf = cfm.get_conf('test')\n&gt;&gt;&gt; conf.delete('test_stanza')\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef delete(self, stanza_name: str):\n\"\"\"Delete stanza.\n\n    Arguments:\n        stanza_name: Stanza name to delete.\n\n    Raises:\n        ConfStanzaNotExistException: If stanza does not exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import conf_manager\n       &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n       &gt;&gt;&gt; conf = cfm.get_conf('test')\n       &gt;&gt;&gt; conf.delete('test_stanza')\n    \"\"\"\n\n    try:\n        self._cred_mgr.delete_password(stanza_name)\n    except CredentialNotExistException:\n        pass\n\n    try:\n        self._conf.delete(stanza_name)\n    except KeyError:\n        logging.error(\n            \"Delete stanza: %s error: %s.\", stanza_name, traceback.format_exc()\n        )\n        raise ConfStanzaNotExistException(\n            f\"Stanza: {stanza_name} does not exist in {self._name}.conf\"\n        )\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.get","title":"<code>get(stanza_name, only_current_app=False)</code>","text":"<p>Get stanza from configuration file.</p> Result is like <p>{     \u2018disabled\u2019: \u20180\u2019,     \u2018eai:appName\u2019: \u2018solnlib_demo\u2019,     \u2018eai:userName\u2019: \u2018nobody\u2019,     \u2018k1\u2019: \u20181\u2019,     \u2018k2\u2019: \u20182\u2019 }</p> <p>Parameters:</p> Name Type Description Default <code>stanza_name</code> <code>str</code> <p>Stanza name.</p> required <code>only_current_app</code> <code>bool</code> <p>Only include current app.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Stanza.</p> <p>Raises:</p> Type Description <code>ConfStanzaNotExistException</code> <p>If stanza does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                   'Splunk_TA_test')\n&gt;&gt;&gt; conf = cfm.get_conf('test')\n&gt;&gt;&gt; conf.get('test_stanza')\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get(self, stanza_name: str, only_current_app: bool = False) -&gt; dict:\n\"\"\"Get stanza from configuration file.\n\n    Result is like:\n\n        {\n            'disabled': '0',\n            'eai:appName': 'solnlib_demo',\n            'eai:userName': 'nobody',\n            'k1': '1',\n            'k2': '2'\n        }\n\n    Arguments:\n        stanza_name: Stanza name.\n        only_current_app: Only include current app.\n\n    Returns:\n        Stanza.\n\n    Raises:\n        ConfStanzaNotExistException: If stanza does not exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import conf_manager\n       &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n       &gt;&gt;&gt; conf = cfm.get_conf('test')\n       &gt;&gt;&gt; conf.get('test_stanza')\n    \"\"\"\n\n    try:\n        if only_current_app:\n            stanza_mgrs = self._conf.list(\n                search=\"eai:acl.app={} name={}\".format(\n                    self._app, stanza_name.replace(\"=\", r\"\\=\")\n                )\n            )\n        else:\n            stanza_mgrs = self._conf.list(name=stanza_name)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise ConfStanzaNotExistException(\n            f\"Stanza: {stanza_name} does not exist in {self._name}.conf\"\n        )\n\n    if len(stanza_mgrs) == 0:\n        raise ConfStanzaNotExistException(\n            f\"Stanza: {stanza_name} does not exist in {self._name}.conf\"\n        )\n\n    stanza = self._decrypt_stanza(stanza_mgrs[0].name, stanza_mgrs[0].content)\n    stanza[\"eai:access\"] = stanza_mgrs[0].access\n    stanza[\"eai:appName\"] = stanza_mgrs[0].access.app\n    return stanza\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.get_all","title":"<code>get_all(only_current_app=False)</code>","text":"<p>Get all stanzas from configuration file.</p> Result is like <p>{     \u2018test\u2019:         {             \u2018disabled\u2019: \u20180\u2019,             \u2018eai:appName\u2019: \u2018solnlib_demo\u2019,             \u2018eai:userName\u2019: \u2018nobody\u2019,             \u2018k1\u2019: \u20181\u2019,             \u2018k2\u2019: \u20182\u2019         } }</p> <p>Parameters:</p> Name Type Description Default <code>only_current_app</code> <code>bool</code> <p>Only include current app.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dict of stanzas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                   'Splunk_TA_test')\n&gt;&gt;&gt; conf = cfm.get_conf('test')\n&gt;&gt;&gt; conf.get_all()\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get_all(self, only_current_app: bool = False) -&gt; dict:\n\"\"\"Get all stanzas from configuration file.\n\n    Result is like:\n\n        {\n            'test':\n                {\n                    'disabled': '0',\n                    'eai:appName': 'solnlib_demo',\n                    'eai:userName': 'nobody',\n                    'k1': '1',\n                    'k2': '2'\n                }\n        }\n\n    Arguments:\n        only_current_app: Only include current app.\n\n    Returns:\n        Dict of stanzas.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import conf_manager\n       &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n       &gt;&gt;&gt; conf = cfm.get_conf('test')\n       &gt;&gt;&gt; conf.get_all()\n    \"\"\"\n\n    if only_current_app:\n        stanza_mgrs = self._conf.list(search=f\"eai:acl.app={self._app}\")\n    else:\n        stanza_mgrs = self._conf.list()\n    res = {}\n    for stanza_mgr in stanza_mgrs:\n        name = stanza_mgr.name\n        key_values = self._decrypt_stanza(name, stanza_mgr.content)\n        key_values[\"eai:access\"] = stanza_mgr.access\n        key_values[\"eai:appName\"] = stanza_mgr.access.app\n        res[name] = key_values\n    return res\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.reload","title":"<code>reload()</code>","text":"<p>Reload configuration file.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                   'Splunk_TA_test')\n&gt;&gt;&gt; conf = cfm.get_conf('test')\n&gt;&gt;&gt; conf.reload()\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef reload(self):\n\"\"\"Reload configuration file.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import conf_manager\n       &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n       &gt;&gt;&gt; conf = cfm.get_conf('test')\n       &gt;&gt;&gt; conf.reload()\n    \"\"\"\n\n    self._conf.get(\"_reload\")\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.stanza_exist","title":"<code>stanza_exist(stanza_name)</code>","text":"<p>Check whether stanza exists.</p> <p>Parameters:</p> Name Type Description Default <code>stanza_name</code> <code>str</code> <p>Stanza name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if stanza exists else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                   'Splunk_TA_test')\n&gt;&gt;&gt; conf = cfm.get_conf('test')\n&gt;&gt;&gt; conf.stanza_exist('test_stanza')\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef stanza_exist(self, stanza_name: str) -&gt; bool:\n\"\"\"Check whether stanza exists.\n\n    Arguments:\n        stanza_name: Stanza name.\n\n    Returns:\n        True if stanza exists else False.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import conf_manager\n       &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n       &gt;&gt;&gt; conf = cfm.get_conf('test')\n       &gt;&gt;&gt; conf.stanza_exist('test_stanza')\n    \"\"\"\n\n    try:\n        self._conf.list(name=stanza_name)[0]\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        return False\n\n    return True\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfFile.update","title":"<code>update(stanza_name, stanza, encrypt_keys=None)</code>","text":"<p>Update stanza.</p> <p>It will try to encrypt the credential automatically fist if encrypt_keys are not None else keep stanza untouched.</p> <p>Parameters:</p> Name Type Description Default <code>stanza_name</code> <code>str</code> <p>Stanza name.</p> required <code>stanza</code> <code>dict</code> <p>Stanza to update.</p> required <code>encrypt_keys</code> <code>List[str]</code> <p>Field names to encrypt.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                   'Splunk_TA_test')\n&gt;&gt;&gt; conf = cfm.get_conf('test')\n&gt;&gt;&gt; conf.update('test_stanza', {'k1': 1, 'k2': 2}, ['k1'])\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef update(self, stanza_name: str, stanza: dict, encrypt_keys: List[str] = None):\n\"\"\"Update stanza.\n\n    It will try to encrypt the credential automatically fist if\n    encrypt_keys are not None else keep stanza untouched.\n\n    Arguments:\n        stanza_name: Stanza name.\n        stanza: Stanza to update.\n        encrypt_keys: Field names to encrypt.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import conf_manager\n       &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n       &gt;&gt;&gt; conf = cfm.get_conf('test')\n       &gt;&gt;&gt; conf.update('test_stanza', {'k1': 1, 'k2': 2}, ['k1'])\n    \"\"\"\n\n    stanza = self._filter_stanza(stanza)\n    encrypted_stanza = self._encrypt_stanza(stanza_name, stanza, encrypt_keys)\n\n    try:\n        stanza_mgr = self._conf.list(name=stanza_name)[0]\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        stanza_mgr = self._conf.create(stanza_name)\n\n    stanza_mgr.submit(encrypted_stanza)\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager","title":"<code>ConfManager</code>","text":"<p>Configuration file manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                  'Splunk_TA_test')\n</code></pre> <p>Examples:</p> <p>If stanza in passwords.conf is formatted as below:</p> <p><code>credential:__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME:STANZA_NAME``splunk_cred_sep``1:</code></p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; cfm = conf_manager.ConfManager(\n        session_key,\n        'Splunk_TA_test',\n        realm='__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME'\n    )\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>class ConfManager:\n\"\"\"Configuration file manager.\n\n    Examples:\n\n        &gt;&gt;&gt; from solnlib import conf_manager\n        &gt;&gt;&gt; cfm = conf_manager.ConfManager(session_key,\n                                          'Splunk_TA_test')\n\n    Examples:\n        If stanza in passwords.conf is formatted as below:\n\n        `credential:__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME:STANZA_NAME``splunk_cred_sep``1:`\n\n        &gt;&gt;&gt; from solnlib import conf_manager\n        &gt;&gt;&gt; cfm = conf_manager.ConfManager(\n                session_key,\n                'Splunk_TA_test',\n                realm='__REST_CREDENTIAL__#Splunk_TA_test#configs/conf-CONF_FILENAME'\n            )\n    \"\"\"\n\n    def __init__(\n        self,\n        session_key: str,\n        app: str,\n        owner: str = \"nobody\",\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        realm: str = None,\n        **context: dict,\n    ):\n\"\"\"Initializes ConfManager.\n\n        Arguments:\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            realm: (optional) Realm of credential, default is None.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        self._session_key = session_key\n        self._app = app\n        self._owner = owner\n        self._scheme = scheme\n        self._host = host\n        self._port = port\n        self._context = context\n        self._rest_client = rest_client.SplunkRestClient(\n            self._session_key,\n            self._app,\n            owner=self._owner,\n            scheme=self._scheme,\n            host=self._host,\n            port=self._port,\n            **self._context,\n        )\n        self._confs = None\n        self._realm = realm\n\n    @retry(exceptions=[binding.HTTPError])\n    def get_conf(self, name: str, refresh: bool = False) -&gt; ConfFile:\n\"\"\"Get conf file.\n\n        Arguments:\n            name: Conf file name.\n            refresh: (optional) Flag to refresh conf file list, default is False.\n\n        Returns:\n            Conf file object.\n\n        Raises:\n            ConfManagerException: If `conf_file` does not exist.\n        \"\"\"\n\n        if self._confs is None or refresh:\n            # Fix bug that can't pass `-` as app name.\n            curr_app = self._rest_client.namespace.app\n            self._rest_client.namespace.app = \"dummy\"\n            self._confs = self._rest_client.confs\n            self._rest_client.namespace.app = curr_app\n\n        try:\n            conf = self._confs[name]\n        except KeyError:\n            raise ConfManagerException(f\"Config file: {name} does not exist.\")\n\n        return ConfFile(\n            name,\n            conf,\n            self._session_key,\n            self._app,\n            self._owner,\n            self._scheme,\n            self._host,\n            self._port,\n            self._realm,\n            **self._context,\n        )\n\n    @retry(exceptions=[binding.HTTPError])\n    def create_conf(self, name: str) -&gt; ConfFile:\n\"\"\"Create conf file.\n\n        Arguments:\n            name: Conf file name.\n\n        Returns:\n            Conf file object.\n        \"\"\"\n\n        if self._confs is None:\n            self._confs = self._rest_client.confs\n\n        conf = self._confs.create(name)\n        return ConfFile(\n            name,\n            conf,\n            self._session_key,\n            self._app,\n            self._owner,\n            self._scheme,\n            self._host,\n            self._port,\n            self._realm,\n            **self._context,\n        )\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager.__init__","title":"<code>__init__(session_key, app, owner='nobody', scheme=None, host=None, port=None, realm=None, **context)</code>","text":"<p>Initializes ConfManager.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>str</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>realm</code> <code>str</code> <p>(optional) Realm of credential, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/conf_manager.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    app: str,\n    owner: str = \"nobody\",\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    realm: str = None,\n    **context: dict,\n):\n\"\"\"Initializes ConfManager.\n\n    Arguments:\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        realm: (optional) Realm of credential, default is None.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    self._session_key = session_key\n    self._app = app\n    self._owner = owner\n    self._scheme = scheme\n    self._host = host\n    self._port = port\n    self._context = context\n    self._rest_client = rest_client.SplunkRestClient(\n        self._session_key,\n        self._app,\n        owner=self._owner,\n        scheme=self._scheme,\n        host=self._host,\n        port=self._port,\n        **self._context,\n    )\n    self._confs = None\n    self._realm = realm\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager.create_conf","title":"<code>create_conf(name)</code>","text":"<p>Create conf file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Conf file name.</p> required <p>Returns:</p> Type Description <code>ConfFile</code> <p>Conf file object.</p> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef create_conf(self, name: str) -&gt; ConfFile:\n\"\"\"Create conf file.\n\n    Arguments:\n        name: Conf file name.\n\n    Returns:\n        Conf file object.\n    \"\"\"\n\n    if self._confs is None:\n        self._confs = self._rest_client.confs\n\n    conf = self._confs.create(name)\n    return ConfFile(\n        name,\n        conf,\n        self._session_key,\n        self._app,\n        self._owner,\n        self._scheme,\n        self._host,\n        self._port,\n        self._realm,\n        **self._context,\n    )\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.ConfManager.get_conf","title":"<code>get_conf(name, refresh=False)</code>","text":"<p>Get conf file.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Conf file name.</p> required <code>refresh</code> <code>bool</code> <p>(optional) Flag to refresh conf file list, default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>ConfFile</code> <p>Conf file object.</p> <p>Raises:</p> Type Description <code>ConfManagerException</code> <p>If <code>conf_file</code> does not exist.</p> Source code in <code>solnlib/conf_manager.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get_conf(self, name: str, refresh: bool = False) -&gt; ConfFile:\n\"\"\"Get conf file.\n\n    Arguments:\n        name: Conf file name.\n        refresh: (optional) Flag to refresh conf file list, default is False.\n\n    Returns:\n        Conf file object.\n\n    Raises:\n        ConfManagerException: If `conf_file` does not exist.\n    \"\"\"\n\n    if self._confs is None or refresh:\n        # Fix bug that can't pass `-` as app name.\n        curr_app = self._rest_client.namespace.app\n        self._rest_client.namespace.app = \"dummy\"\n        self._confs = self._rest_client.confs\n        self._rest_client.namespace.app = curr_app\n\n    try:\n        conf = self._confs[name]\n    except KeyError:\n        raise ConfManagerException(f\"Config file: {name} does not exist.\")\n\n    return ConfFile(\n        name,\n        conf,\n        self._session_key,\n        self._app,\n        self._owner,\n        self._scheme,\n        self._host,\n        self._port,\n        self._realm,\n        **self._context,\n    )\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.get_log_level","title":"<code>get_log_level(*, logger, session_key, app_name, conf_name, log_stanza='logging', log_level_field='loglevel', default_log_level='INFO')</code>","text":"<p>This function returns the log level for the addon from configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>logging.Logger</code> <p>Logger.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app_name</code> <code>str</code> <p>Add-on name.</p> required <code>conf_name</code> <code>str</code> <p>Configuration file name where logging stanza is.</p> required <code>log_stanza</code> <code>str</code> <p>Logging stanza to define <code>log_level_field</code> and its value.</p> <code>'logging'</code> <code>log_level_field</code> <code>str</code> <p>Logging level field name under logging stanza.</p> <code>'loglevel'</code> <code>default_log_level</code> <code>str</code> <p>Default log level to return in case of errors.</p> <code>'INFO'</code> <p>Returns:</p> Type Description <code>str</code> <p>Log level defined under <code>logging.log_level_field</code> field in <code>conf_name</code></p> <code>str</code> <p>file. In case of any error, <code>default_log_level</code> will be returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; log_level = conf_manager.get_log_level(\n&gt;&gt;&gt;     logger,\n&gt;&gt;&gt;     \"session_key\",\n&gt;&gt;&gt;     \"ADDON_NAME\",\n&gt;&gt;&gt;     \"splunk_ta_addon_settings\",\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>def get_log_level(\n    *,\n    logger: logging.Logger,\n    session_key: str,\n    app_name: str,\n    conf_name: str,\n    log_stanza: str = \"logging\",\n    log_level_field: str = \"loglevel\",\n    default_log_level: str = \"INFO\",\n) -&gt; str:\n\"\"\"This function returns the log level for the addon from configuration\n    file.\n\n    Arguments:\n        logger: Logger.\n        session_key: Splunk access token.\n        app_name: Add-on name.\n        conf_name: Configuration file name where logging stanza is.\n        log_stanza: Logging stanza to define `log_level_field` and its value.\n        log_level_field: Logging level field name under logging stanza.\n        default_log_level: Default log level to return in case of errors.\n\n    Returns:\n        Log level defined under `logging.log_level_field` field in `conf_name`\n        file. In case of any error, `default_log_level` will be returned.\n\n    Examples:\n        &gt;&gt;&gt; from solnlib import conf_manager\n        &gt;&gt;&gt; log_level = conf_manager.get_log_level(\n        &gt;&gt;&gt;     logger,\n        &gt;&gt;&gt;     \"session_key\",\n        &gt;&gt;&gt;     \"ADDON_NAME\",\n        &gt;&gt;&gt;     \"splunk_ta_addon_settings\",\n        &gt;&gt;&gt; )\n    \"\"\"\n    try:\n        cfm = ConfManager(\n            session_key,\n            app_name,\n            realm=f\"__REST_CREDENTIAL__#{app_name}#configs/conf-{conf_name}\",\n        )\n        conf = cfm.get_conf(conf_name)\n    except ConfManagerException:\n        logger.error(\n            f\"Failed to fetch configuration file {conf_name}, \"\n            f\"taking {default_log_level} as log level.\"\n        )\n        return default_log_level\n    try:\n        logging_details = conf.get(log_stanza)\n        return logging_details.get(log_level_field, default_log_level)\n    except ConfStanzaNotExistException:\n        logger.error(\n            f'\"logging\" stanza does not exist under {conf_name}, '\n            f\"taking {default_log_level} as log level.\"\n        )\n        return default_log_level\n</code></pre>"},{"location":"conf_manager/#solnlib.conf_manager.get_proxy_dict","title":"<code>get_proxy_dict(logger, session_key, app_name, conf_name, proxy_stanza='proxy', **kwargs)</code>","text":"<p>This function returns the proxy settings for the addon from configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>logging.Logger</code> <p>Logger.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app_name</code> <code>str</code> <p>Add-on name.</p> required <code>conf_name</code> <code>str</code> <p>Configuration file name where logging stanza is.</p> required <code>proxy_stanza</code> <code>str</code> <p>Proxy stanza that would contain the Proxy details</p> <code>'proxy'</code> <p>Returns:</p> Type Description <code>Union[Dict[str, str], NoReturn]</code> <p>A dictionary is returned with stanza details present in the file.</p> <code>Union[Dict[str, str], NoReturn]</code> <p>The keys related to <code>eai</code> are removed before returning.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import conf_manager\n&gt;&gt;&gt; proxy_details = conf_manager.get_proxy_dict(\n&gt;&gt;&gt;     logger,\n&gt;&gt;&gt;     \"session_key\",\n&gt;&gt;&gt;     \"ADDON_NAME\",\n&gt;&gt;&gt;     \"splunk_ta_addon_settings\",\n&gt;&gt;&gt; )\n</code></pre> Source code in <code>solnlib/conf_manager.py</code> <pre><code>def get_proxy_dict(\n    logger: logging.Logger,\n    session_key: str,\n    app_name: str,\n    conf_name: str,\n    proxy_stanza: str = \"proxy\",\n    **kwargs,\n) -&gt; Union[Dict[str, str], NoReturn]:\n\"\"\"This function returns the proxy settings for the addon from\n    configuration file.\n\n    Arguments:\n        logger: Logger.\n        session_key: Splunk access token.\n        app_name: Add-on name.\n        conf_name: Configuration file name where logging stanza is.\n        proxy_stanza: Proxy stanza that would contain the Proxy details\n    Returns:\n        A dictionary is returned with stanza details present in the file.\n        The keys related to `eai` are removed before returning.\n\n    Examples:\n        &gt;&gt;&gt; from solnlib import conf_manager\n        &gt;&gt;&gt; proxy_details = conf_manager.get_proxy_dict(\n        &gt;&gt;&gt;     logger,\n        &gt;&gt;&gt;     \"session_key\",\n        &gt;&gt;&gt;     \"ADDON_NAME\",\n        &gt;&gt;&gt;     \"splunk_ta_addon_settings\",\n        &gt;&gt;&gt; )\n    \"\"\"\n    proxy_dict = {}\n    try:\n        cfm = ConfManager(\n            session_key,\n            app_name,\n            realm=f\"__REST_CREDENTIAL__#{app_name}#configs/conf-{conf_name}\",\n        )\n        conf = cfm.get_conf(conf_name)\n    except Exception:\n        raise ConfManagerException(f\"Failed to fetch configuration file '{conf_name}'.\")\n    else:\n        try:\n            proxy_dict = conf.get(proxy_stanza)\n        except Exception:\n            raise ConfStanzaNotExistException(\n                f\"Failed to fetch '{proxy_stanza}' from the configuration file '{conf_name}'. \"\n            )\n        else:\n            # remove the other fields that are added by ConfFile class\n            proxy_dict.pop(\"disabled\", None)\n            proxy_dict.pop(\"eai:access\", None)\n            proxy_dict.pop(\"eai:appName\", None)\n            proxy_dict.pop(\"eai:userName\", None)\n\n            if \"proxy_port\" in kwargs:\n                if not is_valid_port(proxy_dict.get(kwargs[\"proxy_port\"])):\n                    logger.error(\"Invalid proxy port provided.\")\n                    raise InvalidPortError(\"The provided port is not valid.\")\n            if \"proxy_host\" in kwargs:\n                if not is_valid_hostname(proxy_dict.get(kwargs[\"proxy_host\"])):\n                    logger.error(\"Invalid proxy host provided.\")\n                    raise InvalidHostnameError(\"The provided hostname is not valid.\")\n    return proxy_dict\n</code></pre>"},{"location":"credentials/","title":"credentials.py","text":"<p>This module contains Splunk credential related interfaces.</p>"},{"location":"credentials/#solnlib.credentials.__all__","title":"<code>__all__ = ['CredentialException', 'CredentialNotExistException', 'CredentialManager']</code>  <code>module-attribute</code>","text":""},{"location":"credentials/#solnlib.credentials.CredentialException","title":"<code>CredentialException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>General exception regarding credentials.</p> Source code in <code>solnlib/credentials.py</code> <pre><code>class CredentialException(Exception):\n\"\"\"General exception regarding credentials.\"\"\"\n\n    pass\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager","title":"<code>CredentialManager</code>","text":"<p>Credential manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import credentials\n&gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                       'Splunk_TA_test',\n                                       realm='realm_test')\n</code></pre> Source code in <code>solnlib/credentials.py</code> <pre><code>class CredentialManager:\n\"\"\"Credential manager.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import credentials\n       &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                              'Splunk_TA_test',\n                                              realm='realm_test')\n    \"\"\"\n\n    # Splunk can only encrypt string with length &lt;=255\n    SPLUNK_CRED_LEN_LIMIT = 255\n\n    # Splunk credential separator\n    SEP = \"``splunk_cred_sep``\"\n\n    # Splunk credential end mark\n    END_MARK = (\n        \"``splunk_cred_sep``S``splunk_cred_sep``P``splunk_cred_sep``L``splunk_cred_sep``\"\n        \"U``splunk_cred_sep``N``splunk_cred_sep``K``splunk_cred_sep``\"\n    )\n\n    def __init__(\n        self,\n        session_key: str,\n        app: str,\n        owner: str = \"nobody\",\n        realm: str = None,\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        **context: dict,\n    ):\n\"\"\"Initializes CredentialManager.\n\n        Arguments:\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            realm: (optional) Realm of credential, default is None.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        self._realm = realm\n        self.service = rest_client.SplunkRestClient(\n            session_key,\n            app,\n            owner=owner,\n            scheme=scheme,\n            host=host,\n            port=port,\n            **context,\n        )\n        self._storage_passwords = self.service.storage_passwords\n\n    @retry(exceptions=[binding.HTTPError])\n    def get_password(self, user: str) -&gt; str:\n\"\"\"Get password.\n\n        Arguments:\n            user: User name.\n\n        Returns:\n            Clear user password.\n\n        Raises:\n            CredentialNotExistException: If password for 'realm:user' doesn't exist.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import credentials\n           &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                                  'Splunk_TA_test',\n                                                  realm='realm_test')\n           &gt;&gt;&gt; cm.get_password('testuser2')\n        \"\"\"\n        if self._realm is not None:\n            passwords = self.get_clear_passwords_in_realm()\n        else:\n            passwords = self.get_clear_passwords()\n        for password in passwords:\n            if password[\"username\"] == user and password[\"realm\"] == self._realm:\n                return password[\"clear_password\"]\n\n        raise CredentialNotExistException(\n            f\"Failed to get password of realm={self._realm}, user={user}.\"\n        )\n\n    @retry(exceptions=[binding.HTTPError])\n    def set_password(self, user: str, password: str):\n\"\"\"Set password.\n\n        Arguments:\n            user: User name.\n            password: User password.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import credentials\n           &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                                  'Splunk_TA_test',\n                                                  realm='realm_test')\n           &gt;&gt;&gt; cm.set_password('testuser1', 'password1')\n        \"\"\"\n        length = 0\n        index = 1\n        while length &lt; len(password):\n            curr_str = password[\n                length : length + self.SPLUNK_CRED_LEN_LIMIT  # noqa: E203\n            ]\n            partial_user = self.SEP.join([user, str(index)])\n            self._update_password(partial_user, curr_str)\n            length += self.SPLUNK_CRED_LEN_LIMIT\n            index += 1\n\n        # Append another stanza to mark the end of the password\n        partial_user = self.SEP.join([user, str(index)])\n        self._update_password(partial_user, self.END_MARK)\n\n    @retry(exceptions=[binding.HTTPError])\n    def _update_password(self, user: str, password: str):\n\"\"\"Update password.\n\n        Arguments:\n            user: User name.\n            password: User password.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import credentials\n           &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                                  'Splunk_TA_test',\n                                                  realm='realm_test')\n           &gt;&gt;&gt; cm._update_password('testuser1', 'password1')\n        \"\"\"\n        try:\n            self._storage_passwords.create(password, user, self._realm)\n        except binding.HTTPError as ex:\n            if ex.status == 409:\n                if self._realm is not None:\n                    passwords = self.get_raw_passwords_in_realm()\n                else:\n                    passwords = self.get_raw_passwords()\n                for pwd_stanza in passwords:\n                    if pwd_stanza.realm == self._realm and pwd_stanza.username == user:\n                        pwd_stanza.update(password=password)\n                        return\n                raise ValueError(\n                    f\"Can not get the password object for realm: {self._realm} user: {user}\"\n                )\n            else:\n                raise ex\n\n    @retry(exceptions=[binding.HTTPError])\n    def delete_password(self, user: str):\n\"\"\"Delete password.\n\n        Arguments:\n            user: User name.\n\n        Raises:\n             CredentialNotExistException: If password of realm:user doesn't exist.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import credentials\n           &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                                  'Splunk_TA_test',\n                                                  realm='realm_test')\n           &gt;&gt;&gt; cm.delete_password('testuser1')\n        \"\"\"\n        if self._realm is not None:\n            passwords = self.get_raw_passwords_in_realm()\n        else:\n            passwords = self.get_raw_passwords()\n        deleted = False\n        ent_pattern = re.compile(\n            r\"({}{}\\d+)\".format(user.replace(\"\\\\\", \"\\\\\\\\\"), self.SEP)\n        )\n        for password in passwords:\n            match = (user == password.username) or ent_pattern.match(password.username)\n            if match and password.realm == self._realm:\n                password.delete()\n                deleted = True\n\n        if not deleted:\n            raise CredentialNotExistException(\n                f\"Failed to delete password of realm={self._realm}, user={user}\"\n            )\n\n    def get_raw_passwords(self) -&gt; List[client.StoragePassword]:\n\"\"\"Returns all passwords in the \"raw\" format.\"\"\"\n        warnings.warn(\n            \"Please pass realm to the CredentialManager, \"\n            \"so it can utilize get_raw_passwords_in_realm method instead.\"\n        )\n        return self._storage_passwords.list(count=-1)\n\n    def get_raw_passwords_in_realm(self) -&gt; List[client.StoragePassword]:\n\"\"\"Returns all passwords within the realm in the \"raw\" format.\"\"\"\n        if self._realm is None:\n            raise ValueError(\"No realm was specified\")\n        return self._storage_passwords.list(count=-1, search=f\"realm={self._realm}\")\n\n    def get_clear_passwords(self) -&gt; List[Dict[str, str]]:\n\"\"\"Returns all passwords in the \"clear\" format.\"\"\"\n        warnings.warn(\n            \"Please pass realm to the CredentialManager, \"\n            \"so it can utilize get_clear_passwords_in_realm method instead.\"\n        )\n        raw_passwords = self.get_raw_passwords()\n        return self._get_clear_passwords(raw_passwords)\n\n    def get_clear_passwords_in_realm(self) -&gt; List[Dict[str, str]]:\n\"\"\"Returns all passwords within the realm in the \"clear\" format.\"\"\"\n        if self._realm is None:\n            raise ValueError(\"No realm was specified\")\n        raw_passwords = self.get_raw_passwords_in_realm()\n        return self._get_clear_passwords(raw_passwords)\n\n    def _get_all_passwords_in_realm(self) -&gt; List[client.StoragePassword]:\n        warnings.warn(\n            \"_get_all_passwords_in_realm is deprecated, \"\n            \"please use get_raw_passwords_in_realm instead.\",\n            stacklevel=2,\n        )\n        if self._realm:\n            all_passwords = self._storage_passwords.list(\n                count=-1, search=f\"realm={self._realm}\"\n            )\n        else:\n            all_passwords = self._storage_passwords.list(count=-1, search=\"\")\n        return all_passwords\n\n    def _get_clear_passwords(\n        self, passwords: List[client.StoragePassword]\n    ) -&gt; List[Dict[str, str]]:\n        results = {}\n        ptn = re.compile(rf\"(.+){self.SEP}(\\d+)\")\n        for password in passwords:\n            match = ptn.match(password.name)\n            if match:\n                actual_name = match.group(1) + \":\"\n                index = int(match.group(2))\n                if actual_name in results:\n                    exist_stanza = results[actual_name]\n                else:\n                    exist_stanza = {}\n                    exist_stanza[\"name\"] = actual_name\n                    exist_stanza[\"realm\"] = password.realm\n                    exist_stanza[\"username\"] = password.username.split(self.SEP)[0]\n                    exist_stanza[\"clears\"] = {}\n                    results[actual_name] = exist_stanza\n\n                exist_stanza[\"clears\"][index] = password.clear_password\n\n        # Backward compatibility\n        # To deal with the password with only one stanza which is generated by the old version.\n        for password in passwords:\n            match = ptn.match(password.name)\n            if (not match) and (password.name not in results):\n                results[password.name] = {\n                    \"name\": password.name,\n                    \"realm\": password.realm,\n                    \"username\": password.username,\n                    \"clear_password\": password.clear_password,\n                }\n\n        # Merge password by index\n        for name, values in list(results.items()):\n            field_clear = values.get(\"clears\")\n            if field_clear:\n                clear_password = \"\"\n                for index in sorted(field_clear.keys()):\n                    if field_clear[index] != self.END_MARK:\n                        clear_password += field_clear[index]\n                    else:\n                        break\n                values[\"clear_password\"] = clear_password\n\n                del values[\"clears\"]\n\n        return list(results.values())\n\n    @retry(exceptions=[binding.HTTPError])\n    def _get_all_passwords(self) -&gt; List[Dict[str, str]]:\n        warnings.warn(\n            \"_get_all_passwords is deprecated, \"\n            \"please use get_all_passwords_in_realm instead.\",\n            stacklevel=2,\n        )\n        passwords = self._storage_passwords.list(count=-1)\n        return self._get_clear_passwords(passwords)\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.END_MARK","title":"<code>END_MARK = '``splunk_cred_sep``S``splunk_cred_sep``P``splunk_cred_sep``L``splunk_cred_sep``U``splunk_cred_sep``N``splunk_cred_sep``K``splunk_cred_sep``'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"credentials/#solnlib.credentials.CredentialManager.SEP","title":"<code>SEP = '``splunk_cred_sep``'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"credentials/#solnlib.credentials.CredentialManager.SPLUNK_CRED_LEN_LIMIT","title":"<code>SPLUNK_CRED_LEN_LIMIT = 255</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"credentials/#solnlib.credentials.CredentialManager.service","title":"<code>service = rest_client.SplunkRestClient(session_key, app, owner=owner, scheme=scheme, host=host, port=port, None=context)</code>  <code>instance-attribute</code>","text":""},{"location":"credentials/#solnlib.credentials.CredentialManager.__init__","title":"<code>__init__(session_key, app, owner='nobody', realm=None, scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes CredentialManager.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>str</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>realm</code> <code>str</code> <p>(optional) Realm of credential, default is None.</p> <code>None</code> <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/credentials.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    app: str,\n    owner: str = \"nobody\",\n    realm: str = None,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n):\n\"\"\"Initializes CredentialManager.\n\n    Arguments:\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        realm: (optional) Realm of credential, default is None.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    self._realm = realm\n    self.service = rest_client.SplunkRestClient(\n        session_key,\n        app,\n        owner=owner,\n        scheme=scheme,\n        host=host,\n        port=port,\n        **context,\n    )\n    self._storage_passwords = self.service.storage_passwords\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.delete_password","title":"<code>delete_password(user)</code>","text":"<p>Delete password.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User name.</p> required <p>Raises:</p> Type Description <code>CredentialNotExistException</code> <p>If password of realm:user doesn\u2019t exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import credentials\n&gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                       'Splunk_TA_test',\n                                       realm='realm_test')\n&gt;&gt;&gt; cm.delete_password('testuser1')\n</code></pre> Source code in <code>solnlib/credentials.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef delete_password(self, user: str):\n\"\"\"Delete password.\n\n    Arguments:\n        user: User name.\n\n    Raises:\n         CredentialNotExistException: If password of realm:user doesn't exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import credentials\n       &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                              'Splunk_TA_test',\n                                              realm='realm_test')\n       &gt;&gt;&gt; cm.delete_password('testuser1')\n    \"\"\"\n    if self._realm is not None:\n        passwords = self.get_raw_passwords_in_realm()\n    else:\n        passwords = self.get_raw_passwords()\n    deleted = False\n    ent_pattern = re.compile(\n        r\"({}{}\\d+)\".format(user.replace(\"\\\\\", \"\\\\\\\\\"), self.SEP)\n    )\n    for password in passwords:\n        match = (user == password.username) or ent_pattern.match(password.username)\n        if match and password.realm == self._realm:\n            password.delete()\n            deleted = True\n\n    if not deleted:\n        raise CredentialNotExistException(\n            f\"Failed to delete password of realm={self._realm}, user={user}\"\n        )\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.get_clear_passwords","title":"<code>get_clear_passwords()</code>","text":"<p>Returns all passwords in the \u201cclear\u201d format.</p> Source code in <code>solnlib/credentials.py</code> <pre><code>def get_clear_passwords(self) -&gt; List[Dict[str, str]]:\n\"\"\"Returns all passwords in the \"clear\" format.\"\"\"\n    warnings.warn(\n        \"Please pass realm to the CredentialManager, \"\n        \"so it can utilize get_clear_passwords_in_realm method instead.\"\n    )\n    raw_passwords = self.get_raw_passwords()\n    return self._get_clear_passwords(raw_passwords)\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.get_clear_passwords_in_realm","title":"<code>get_clear_passwords_in_realm()</code>","text":"<p>Returns all passwords within the realm in the \u201cclear\u201d format.</p> Source code in <code>solnlib/credentials.py</code> <pre><code>def get_clear_passwords_in_realm(self) -&gt; List[Dict[str, str]]:\n\"\"\"Returns all passwords within the realm in the \"clear\" format.\"\"\"\n    if self._realm is None:\n        raise ValueError(\"No realm was specified\")\n    raw_passwords = self.get_raw_passwords_in_realm()\n    return self._get_clear_passwords(raw_passwords)\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.get_password","title":"<code>get_password(user)</code>","text":"<p>Get password.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Clear user password.</p> <p>Raises:</p> Type Description <code>CredentialNotExistException</code> <p>If password for \u2018realm:user\u2019 doesn\u2019t exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import credentials\n&gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                       'Splunk_TA_test',\n                                       realm='realm_test')\n&gt;&gt;&gt; cm.get_password('testuser2')\n</code></pre> Source code in <code>solnlib/credentials.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get_password(self, user: str) -&gt; str:\n\"\"\"Get password.\n\n    Arguments:\n        user: User name.\n\n    Returns:\n        Clear user password.\n\n    Raises:\n        CredentialNotExistException: If password for 'realm:user' doesn't exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import credentials\n       &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                              'Splunk_TA_test',\n                                              realm='realm_test')\n       &gt;&gt;&gt; cm.get_password('testuser2')\n    \"\"\"\n    if self._realm is not None:\n        passwords = self.get_clear_passwords_in_realm()\n    else:\n        passwords = self.get_clear_passwords()\n    for password in passwords:\n        if password[\"username\"] == user and password[\"realm\"] == self._realm:\n            return password[\"clear_password\"]\n\n    raise CredentialNotExistException(\n        f\"Failed to get password of realm={self._realm}, user={user}.\"\n    )\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.get_raw_passwords","title":"<code>get_raw_passwords()</code>","text":"<p>Returns all passwords in the \u201craw\u201d format.</p> Source code in <code>solnlib/credentials.py</code> <pre><code>def get_raw_passwords(self) -&gt; List[client.StoragePassword]:\n\"\"\"Returns all passwords in the \"raw\" format.\"\"\"\n    warnings.warn(\n        \"Please pass realm to the CredentialManager, \"\n        \"so it can utilize get_raw_passwords_in_realm method instead.\"\n    )\n    return self._storage_passwords.list(count=-1)\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.get_raw_passwords_in_realm","title":"<code>get_raw_passwords_in_realm()</code>","text":"<p>Returns all passwords within the realm in the \u201craw\u201d format.</p> Source code in <code>solnlib/credentials.py</code> <pre><code>def get_raw_passwords_in_realm(self) -&gt; List[client.StoragePassword]:\n\"\"\"Returns all passwords within the realm in the \"raw\" format.\"\"\"\n    if self._realm is None:\n        raise ValueError(\"No realm was specified\")\n    return self._storage_passwords.list(count=-1, search=f\"realm={self._realm}\")\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialManager.set_password","title":"<code>set_password(user, password)</code>","text":"<p>Set password.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User name.</p> required <code>password</code> <code>str</code> <p>User password.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import credentials\n&gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                       'Splunk_TA_test',\n                                       realm='realm_test')\n&gt;&gt;&gt; cm.set_password('testuser1', 'password1')\n</code></pre> Source code in <code>solnlib/credentials.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef set_password(self, user: str, password: str):\n\"\"\"Set password.\n\n    Arguments:\n        user: User name.\n        password: User password.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import credentials\n       &gt;&gt;&gt; cm = credentials.CredentialManager(session_key,\n                                              'Splunk_TA_test',\n                                              realm='realm_test')\n       &gt;&gt;&gt; cm.set_password('testuser1', 'password1')\n    \"\"\"\n    length = 0\n    index = 1\n    while length &lt; len(password):\n        curr_str = password[\n            length : length + self.SPLUNK_CRED_LEN_LIMIT  # noqa: E203\n        ]\n        partial_user = self.SEP.join([user, str(index)])\n        self._update_password(partial_user, curr_str)\n        length += self.SPLUNK_CRED_LEN_LIMIT\n        index += 1\n\n    # Append another stanza to mark the end of the password\n    partial_user = self.SEP.join([user, str(index)])\n    self._update_password(partial_user, self.END_MARK)\n</code></pre>"},{"location":"credentials/#solnlib.credentials.CredentialNotExistException","title":"<code>CredentialNotExistException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception is raised when credentials do not exist.</p> Source code in <code>solnlib/credentials.py</code> <pre><code>class CredentialNotExistException(Exception):\n\"\"\"Exception is raised when credentials do not exist.\"\"\"\n\n    pass\n</code></pre>"},{"location":"file_monitor/","title":"file_monitor.py","text":"<p>This module contains file monitoring class that can be used to check files change periodically and call callback function to handle properly when detecting files change.</p>"},{"location":"file_monitor/#solnlib.file_monitor.__all__","title":"<code>__all__ = ['FileChangesChecker', 'FileMonitor']</code>  <code>module-attribute</code>","text":""},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker","title":"<code>FileChangesChecker</code>","text":"<p>Files change checker.</p> Source code in <code>solnlib/file_monitor.py</code> <pre><code>class FileChangesChecker:\n\"\"\"Files change checker.\"\"\"\n\n    def __init__(self, callback: Callable[[List[str]], Any], files: List):\n\"\"\"Initializes FileChangesChecker.\n\n        Arguments:\n            callback: Callback function for files change.\n            files: Files to be monitored with full path.\n        \"\"\"\n        self._callback = callback\n        self._files = files\n\n        self.file_mtimes = {file_name: None for file_name in self._files}\n        for k in self.file_mtimes:\n            try:\n                self.file_mtimes[k] = op.getmtime(k)\n            except OSError:\n                logging.debug(f\"Getmtime for {k}, failed: {traceback.format_exc()}\")\n\n    def check_changes(self) -&gt; bool:\n\"\"\"Check files change.\n\n        If some files are changed and callback function is not None, call\n        callback function to handle files change.\n\n        Returns:\n            True if files changed else False\n        \"\"\"\n        logging.debug(f\"Checking files={self._files}\")\n        file_mtimes = self.file_mtimes\n        changed_files = []\n        for f, last_mtime in list(file_mtimes.items()):\n            try:\n                current_mtime = op.getmtime(f)\n                if current_mtime != last_mtime:\n                    file_mtimes[f] = current_mtime\n                    changed_files.append(f)\n                    logging.info(f\"Detect {f} has changed\", f)\n            except OSError:\n                pass\n        if changed_files:\n            if self._callback:\n                self._callback(changed_files)\n            return True\n        return False\n</code></pre>"},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker.file_mtimes","title":"<code>file_mtimes = {file_name: None for file_name in self._files}</code>  <code>instance-attribute</code>","text":""},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker.__init__","title":"<code>__init__(callback, files)</code>","text":"<p>Initializes FileChangesChecker.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[List[str]], Any]</code> <p>Callback function for files change.</p> required <code>files</code> <code>List</code> <p>Files to be monitored with full path.</p> required Source code in <code>solnlib/file_monitor.py</code> <pre><code>def __init__(self, callback: Callable[[List[str]], Any], files: List):\n\"\"\"Initializes FileChangesChecker.\n\n    Arguments:\n        callback: Callback function for files change.\n        files: Files to be monitored with full path.\n    \"\"\"\n    self._callback = callback\n    self._files = files\n\n    self.file_mtimes = {file_name: None for file_name in self._files}\n    for k in self.file_mtimes:\n        try:\n            self.file_mtimes[k] = op.getmtime(k)\n        except OSError:\n            logging.debug(f\"Getmtime for {k}, failed: {traceback.format_exc()}\")\n</code></pre>"},{"location":"file_monitor/#solnlib.file_monitor.FileChangesChecker.check_changes","title":"<code>check_changes()</code>","text":"<p>Check files change.</p> <p>If some files are changed and callback function is not None, call callback function to handle files change.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if files changed else False</p> Source code in <code>solnlib/file_monitor.py</code> <pre><code>def check_changes(self) -&gt; bool:\n\"\"\"Check files change.\n\n    If some files are changed and callback function is not None, call\n    callback function to handle files change.\n\n    Returns:\n        True if files changed else False\n    \"\"\"\n    logging.debug(f\"Checking files={self._files}\")\n    file_mtimes = self.file_mtimes\n    changed_files = []\n    for f, last_mtime in list(file_mtimes.items()):\n        try:\n            current_mtime = op.getmtime(f)\n            if current_mtime != last_mtime:\n                file_mtimes[f] = current_mtime\n                changed_files.append(f)\n                logging.info(f\"Detect {f} has changed\", f)\n        except OSError:\n            pass\n    if changed_files:\n        if self._callback:\n            self._callback(changed_files)\n        return True\n    return False\n</code></pre>"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor","title":"<code>FileMonitor</code>","text":"<p>Files change monitor.</p> <p>Monitor files change in a separated thread and call callback when there is files change.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import solnlib.file_monitor as fm\n&gt;&gt;&gt; fm = fm.FileMonitor(fm_callback, files_list, 5)\n&gt;&gt;&gt; fm.start()\n</code></pre> Source code in <code>solnlib/file_monitor.py</code> <pre><code>class FileMonitor:\n\"\"\"Files change monitor.\n\n    Monitor files change in a separated thread and call callback\n    when there is files change.\n\n    Examples:\n      &gt;&gt;&gt; import solnlib.file_monitor as fm\n      &gt;&gt;&gt; fm = fm.FileMonitor(fm_callback, files_list, 5)\n      &gt;&gt;&gt; fm.start()\n    \"\"\"\n\n    def __init__(\n        self, callback: Callable[[List[str]], Any], files: List, interval: int = 1\n    ):\n\"\"\"Initializes FileMonitor.\n\n        Arguments:\n            callback: Callback for handling files change.\n            files: Files to monitor.\n            interval: Interval to check files change.\n        \"\"\"\n        self._checker = FileChangesChecker(callback, files)\n        self._thr = threading.Thread(target=self._do_monitor)\n        self._thr.daemon = True\n        self._interval = interval\n        self._started = False\n\n    def start(self):\n\"\"\"Start file monitor.\n\n        Start a background thread to monitor files change.\n        \"\"\"\n\n        if self._started:\n            return\n        self._started = True\n\n        self._thr.start()\n\n    def stop(self):\n\"\"\"Stop file monitor.\n\n        Stop the background thread to monitor files change.\n        \"\"\"\n\n        self._started = False\n\n    def _do_monitor(self):\n        while self._started:\n            self._checker.check_changes()\n\n            for _ in range(self._interval):\n                if not self._started:\n                    break\n                time.sleep(1)\n</code></pre>"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor.__init__","title":"<code>__init__(callback, files, interval=1)</code>","text":"<p>Initializes FileMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[List[str]], Any]</code> <p>Callback for handling files change.</p> required <code>files</code> <code>List</code> <p>Files to monitor.</p> required <code>interval</code> <code>int</code> <p>Interval to check files change.</p> <code>1</code> Source code in <code>solnlib/file_monitor.py</code> <pre><code>def __init__(\n    self, callback: Callable[[List[str]], Any], files: List, interval: int = 1\n):\n\"\"\"Initializes FileMonitor.\n\n    Arguments:\n        callback: Callback for handling files change.\n        files: Files to monitor.\n        interval: Interval to check files change.\n    \"\"\"\n    self._checker = FileChangesChecker(callback, files)\n    self._thr = threading.Thread(target=self._do_monitor)\n    self._thr.daemon = True\n    self._interval = interval\n    self._started = False\n</code></pre>"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor.start","title":"<code>start()</code>","text":"<p>Start file monitor.</p> <p>Start a background thread to monitor files change.</p> Source code in <code>solnlib/file_monitor.py</code> <pre><code>def start(self):\n\"\"\"Start file monitor.\n\n    Start a background thread to monitor files change.\n    \"\"\"\n\n    if self._started:\n        return\n    self._started = True\n\n    self._thr.start()\n</code></pre>"},{"location":"file_monitor/#solnlib.file_monitor.FileMonitor.stop","title":"<code>stop()</code>","text":"<p>Stop file monitor.</p> <p>Stop the background thread to monitor files change.</p> Source code in <code>solnlib/file_monitor.py</code> <pre><code>def stop(self):\n\"\"\"Stop file monitor.\n\n    Stop the background thread to monitor files change.\n    \"\"\"\n\n    self._started = False\n</code></pre>"},{"location":"hec_config/","title":"hec_config.py","text":""},{"location":"hec_config/#solnlib.hec_config.__all__","title":"<code>__all__ = ['HECConfig']</code>  <code>module-attribute</code>","text":""},{"location":"hec_config/#solnlib.hec_config.HECConfig","title":"<code>HECConfig</code>","text":"<p>HTTP Event Collector configuration.</p> Source code in <code>solnlib/hec_config.py</code> <pre><code>class HECConfig:\n\"\"\"HTTP Event Collector configuration.\"\"\"\n\n    input_type = \"http\"\n\n    def __init__(\n        self,\n        session_key: str,\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        **context: dict\n    ):\n\"\"\"Initializes HECConfig.\n\n        Arguments:\n            session_key: Splunk access token.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        self._rest_client = rest_client.SplunkRestClient(\n            session_key,\n            \"splunk_httpinput\",\n            scheme=scheme,\n            host=host,\n            port=port,\n            **context\n        )\n\n    @retry(exceptions=[binding.HTTPError])\n    def get_settings(self) -&gt; dict:\n\"\"\"Get http data input global settings.\n\n        Returns:\n            HTTP global settings, for example:\n\n                {\n                    'enableSSL': 1,\n                    'disabled': 0,\n                    'useDeploymentServer': 0,\n                    'port': 8088\n                }\n        \"\"\"\n\n        return self._do_get_input(self.input_type).content\n\n    @retry(exceptions=[binding.HTTPError])\n    def update_settings(self, settings: dict):\n\"\"\"Update http data input global settings.\n\n        Arguments:\n            settings: HTTP global settings.\n        \"\"\"\n\n        res = self._do_get_input(self.input_type)\n        res.update(**settings)\n\n    @retry(exceptions=[binding.HTTPError])\n    def create_input(self, name: str, stanza: dict) -&gt; dict:\n\"\"\"Create http data input.\n\n        Arguments:\n            name: HTTP data input name.\n            stanza: Data input stanza content.\n\n        Returns:\n            Created input.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib.hec_config import HECConfig\n           &gt;&gt;&gt; hec = HECConfig(session_key)\n           &gt;&gt;&gt; hec.create_input('my_hec_data_input',\n                                {'index': 'main', 'sourcetype': 'hec'})\n        \"\"\"\n\n        res = self._rest_client.inputs.create(name, self.input_type, **stanza)\n        return res.content\n\n    @retry(exceptions=[binding.HTTPError])\n    def update_input(self, name: str, stanza: dict):\n\"\"\"Update http data input.\n\n        It will create if the data input doesn't exist.\n\n        Arguments:\n            name: HTTP data input name.\n            stanza: Data input stanza.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib import HEConfig\n           &gt;&gt;&gt; hec = HECConfig(session_key)\n           &gt;&gt;&gt; hec.update_input('my_hec_data_input',\n                                {'index': 'main', 'sourcetype': 'hec2'})\n        \"\"\"\n\n        res = self._do_get_input(name)\n        if res is None:\n            return self.create_input(name, stanza)\n        res.update(**stanza)\n\n    @retry(exceptions=[binding.HTTPError])\n    def delete_input(self, name: str):\n\"\"\"Delete http data input.\n\n        Arguments:\n            name: HTTP data input name.\n        \"\"\"\n\n        try:\n            self._rest_client.inputs.delete(name, self.input_type)\n        except KeyError:\n            pass\n\n    @retry(exceptions=[binding.HTTPError])\n    def get_input(self, name: str) -&gt; dict:\n\"\"\"Get http data input.\n\n        Arguments:\n            name: HTTP event collector data input name.\n\n        Returns:\n            HTTP event collector data input config dict.\n        \"\"\"\n\n        res = self._do_get_input(name)\n        if res:\n            return res.content\n        else:\n            return None\n\n    def _do_get_input(self, name):\n        try:\n            return self._rest_client.inputs[(name, self.input_type)]\n        except KeyError:\n            return None\n\n    @retry(exceptions=[binding.HTTPError])\n    def get_limits(self) -&gt; dict:\n\"\"\"Get HTTP input limits.\n\n        Returns:\n            HTTP input limits.\n        \"\"\"\n\n        return self._rest_client.confs[\"limits\"][\"http_input\"].content\n\n    @retry(exceptions=[binding.HTTPError])\n    def set_limits(self, limits: dict):\n\"\"\"Set HTTP input limits.\n\n        Arguments:\n            limits: HTTP input limits.\n        \"\"\"\n\n        res = self._rest_client.confs[\"limits\"][\"http_input\"]\n        res.submit(limits)\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.input_type","title":"<code>input_type = 'http'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"hec_config/#solnlib.hec_config.HECConfig.__init__","title":"<code>__init__(session_key, scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes HECConfig.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/hec_config.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict\n):\n\"\"\"Initializes HECConfig.\n\n    Arguments:\n        session_key: Splunk access token.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    self._rest_client = rest_client.SplunkRestClient(\n        session_key,\n        \"splunk_httpinput\",\n        scheme=scheme,\n        host=host,\n        port=port,\n        **context\n    )\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.create_input","title":"<code>create_input(name, stanza)</code>","text":"<p>Create http data input.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>HTTP data input name.</p> required <code>stanza</code> <code>dict</code> <p>Data input stanza content.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Created input.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.hec_config import HECConfig\n&gt;&gt;&gt; hec = HECConfig(session_key)\n&gt;&gt;&gt; hec.create_input('my_hec_data_input',\n                     {'index': 'main', 'sourcetype': 'hec'})\n</code></pre> Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef create_input(self, name: str, stanza: dict) -&gt; dict:\n\"\"\"Create http data input.\n\n    Arguments:\n        name: HTTP data input name.\n        stanza: Data input stanza content.\n\n    Returns:\n        Created input.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib.hec_config import HECConfig\n       &gt;&gt;&gt; hec = HECConfig(session_key)\n       &gt;&gt;&gt; hec.create_input('my_hec_data_input',\n                            {'index': 'main', 'sourcetype': 'hec'})\n    \"\"\"\n\n    res = self._rest_client.inputs.create(name, self.input_type, **stanza)\n    return res.content\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.delete_input","title":"<code>delete_input(name)</code>","text":"<p>Delete http data input.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>HTTP data input name.</p> required Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef delete_input(self, name: str):\n\"\"\"Delete http data input.\n\n    Arguments:\n        name: HTTP data input name.\n    \"\"\"\n\n    try:\n        self._rest_client.inputs.delete(name, self.input_type)\n    except KeyError:\n        pass\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.get_input","title":"<code>get_input(name)</code>","text":"<p>Get http data input.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>HTTP event collector data input name.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>HTTP event collector data input config dict.</p> Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get_input(self, name: str) -&gt; dict:\n\"\"\"Get http data input.\n\n    Arguments:\n        name: HTTP event collector data input name.\n\n    Returns:\n        HTTP event collector data input config dict.\n    \"\"\"\n\n    res = self._do_get_input(name)\n    if res:\n        return res.content\n    else:\n        return None\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.get_limits","title":"<code>get_limits()</code>","text":"<p>Get HTTP input limits.</p> <p>Returns:</p> Type Description <code>dict</code> <p>HTTP input limits.</p> Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get_limits(self) -&gt; dict:\n\"\"\"Get HTTP input limits.\n\n    Returns:\n        HTTP input limits.\n    \"\"\"\n\n    return self._rest_client.confs[\"limits\"][\"http_input\"].content\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.get_settings","title":"<code>get_settings()</code>","text":"<p>Get http data input global settings.</p> <p>Returns:</p> Type Description <code>dict</code> <p>HTTP global settings, for example:</p> <p>{     \u2018enableSSL\u2019: 1,     \u2018disabled\u2019: 0,     \u2018useDeploymentServer\u2019: 0,     \u2018port\u2019: 8088 }</p> Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef get_settings(self) -&gt; dict:\n\"\"\"Get http data input global settings.\n\n    Returns:\n        HTTP global settings, for example:\n\n            {\n                'enableSSL': 1,\n                'disabled': 0,\n                'useDeploymentServer': 0,\n                'port': 8088\n            }\n    \"\"\"\n\n    return self._do_get_input(self.input_type).content\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.set_limits","title":"<code>set_limits(limits)</code>","text":"<p>Set HTTP input limits.</p> <p>Parameters:</p> Name Type Description Default <code>limits</code> <code>dict</code> <p>HTTP input limits.</p> required Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef set_limits(self, limits: dict):\n\"\"\"Set HTTP input limits.\n\n    Arguments:\n        limits: HTTP input limits.\n    \"\"\"\n\n    res = self._rest_client.confs[\"limits\"][\"http_input\"]\n    res.submit(limits)\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.update_input","title":"<code>update_input(name, stanza)</code>","text":"<p>Update http data input.</p> <p>It will create if the data input doesn\u2019t exist.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>HTTP data input name.</p> required <code>stanza</code> <code>dict</code> <p>Data input stanza.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import HEConfig\n&gt;&gt;&gt; hec = HECConfig(session_key)\n&gt;&gt;&gt; hec.update_input('my_hec_data_input',\n                     {'index': 'main', 'sourcetype': 'hec2'})\n</code></pre> Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef update_input(self, name: str, stanza: dict):\n\"\"\"Update http data input.\n\n    It will create if the data input doesn't exist.\n\n    Arguments:\n        name: HTTP data input name.\n        stanza: Data input stanza.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import HEConfig\n       &gt;&gt;&gt; hec = HECConfig(session_key)\n       &gt;&gt;&gt; hec.update_input('my_hec_data_input',\n                            {'index': 'main', 'sourcetype': 'hec2'})\n    \"\"\"\n\n    res = self._do_get_input(name)\n    if res is None:\n        return self.create_input(name, stanza)\n    res.update(**stanza)\n</code></pre>"},{"location":"hec_config/#solnlib.hec_config.HECConfig.update_settings","title":"<code>update_settings(settings)</code>","text":"<p>Update http data input global settings.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>dict</code> <p>HTTP global settings.</p> required Source code in <code>solnlib/hec_config.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef update_settings(self, settings: dict):\n\"\"\"Update http data input global settings.\n\n    Arguments:\n        settings: HTTP global settings.\n    \"\"\"\n\n    res = self._do_get_input(self.input_type)\n    res.update(**settings)\n</code></pre>"},{"location":"log/","title":"log.py","text":"<p>This module provides log functionalities.</p>"},{"location":"log/#solnlib.log.__all__","title":"<code>__all__ = ['log_enter_exit', 'LogException', 'Logs']</code>  <code>module-attribute</code>","text":""},{"location":"log/#solnlib.log.log_authentication_error","title":"<code>log_authentication_error = partial(_base_error_log, exe_label='Authentication Error')</code>  <code>module-attribute</code>","text":""},{"location":"log/#solnlib.log.log_configuration_error","title":"<code>log_configuration_error = partial(_base_error_log, exe_label='Configuration Error')</code>  <code>module-attribute</code>","text":""},{"location":"log/#solnlib.log.log_connection_error","title":"<code>log_connection_error = partial(_base_error_log, exe_label='Connection Error')</code>  <code>module-attribute</code>","text":""},{"location":"log/#solnlib.log.log_permission_error","title":"<code>log_permission_error = partial(_base_error_log, exe_label='Permission Error')</code>  <code>module-attribute</code>","text":""},{"location":"log/#solnlib.log.log_server_error","title":"<code>log_server_error = partial(_base_error_log, exe_label='Server Error')</code>  <code>module-attribute</code>","text":""},{"location":"log/#solnlib.log.LogException","title":"<code>LogException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised by Logs class.</p> Source code in <code>solnlib/log.py</code> <pre><code>class LogException(Exception):\n\"\"\"Exception raised by Logs class.\"\"\"\n\n    pass\n</code></pre>"},{"location":"log/#solnlib.log.Logs","title":"<code>Logs</code>","text":"<p>A singleton class that manage all kinds of logger.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import log\n&gt;&gt;&gt; log.Logs.set_context(directory='/var/log/test',\n                         namespace='test')\n&gt;&gt;&gt; logger = log.Logs().get_logger('mymodule')\n&gt;&gt;&gt; logger.set_level(logging.DEBUG)\n&gt;&gt;&gt; logger.debug('a debug log')\n</code></pre> Source code in <code>solnlib/log.py</code> <pre><code>class Logs(metaclass=Singleton):\n\"\"\"A singleton class that manage all kinds of logger.\n\n    Examples:\n      &gt;&gt;&gt; from solnlib import log\n      &gt;&gt;&gt; log.Logs.set_context(directory='/var/log/test',\n                               namespace='test')\n      &gt;&gt;&gt; logger = log.Logs().get_logger('mymodule')\n      &gt;&gt;&gt; logger.set_level(logging.DEBUG)\n      &gt;&gt;&gt; logger.debug('a debug log')\n    \"\"\"\n\n    # Normal logger settings\n    _default_directory = None\n    _default_namespace = None\n    _default_log_format = (\n        \"%(asctime)s log_level=%(levelname)s pid=%(process)d tid=%(threadName)s \"\n        \"file=%(filename)s:%(funcName)s:%(lineno)d | %(message)s\"\n    )\n    _default_log_level = logging.INFO\n    _default_max_bytes = 25000000\n    _default_backup_count = 5\n\n    # Default root logger settings\n    _default_root_logger_log_file = \"solnlib\"\n\n    @classmethod\n    def set_context(cls, **context: dict):\n\"\"\"Set log context.\n\n        List of keyword arguments:\n\n            directory: Log directory, default is splunk log root directory.\n            namespace: Logger namespace, default is None.\n            log_format: Log format, default is `_default_log_format`.\n            log_level: Log level, default is logging.INFO.\n            max_bytes: The maximum log file size before rollover, default is 25000000.\n            backup_count: The number of log files to retain,default is 5.\n            root_logger_log_file: Root logger log file name, default is 'solnlib'   .\n\n        Arguments:\n            context: Keyword arguments. See list of arguments above.\n        \"\"\"\n        if \"directory\" in context:\n            cls._default_directory = context[\"directory\"]\n        if \"namespace\" in context:\n            cls._default_namespace = context[\"namespace\"]\n        if \"log_format\" in context:\n            cls._default_log_format = context[\"log_format\"]\n        if \"log_level\" in context:\n            cls._default_log_level = context[\"log_level\"]\n        if \"max_bytes\" in context:\n            cls._default_max_bytes = context[\"max_bytes\"]\n        if \"backup_count\" in context:\n            cls._default_backup_count = context[\"backup_count\"]\n        if \"root_logger_log_file\" in context:\n            cls._default_root_logger_log_file = context[\"root_logger_log_file\"]\n            cls._reset_root_logger()\n\n    @classmethod\n    def _reset_root_logger(cls):\n        logger = logging.getLogger()\n        log_file = cls._get_log_file(cls._default_root_logger_log_file)\n        file_handler = logging.handlers.RotatingFileHandler(\n            log_file,\n            mode=\"a\",\n            maxBytes=cls._default_max_bytes,\n            backupCount=cls._default_backup_count,\n        )\n        file_handler.setFormatter(logging.Formatter(cls._default_log_format))\n        logger.addHandler(file_handler)\n        logger.setLevel(cls._default_log_level)\n\n    @classmethod\n    def _get_log_file(cls, name):\n        if cls._default_namespace:\n            name = f\"{cls._default_namespace}_{name}.log\"\n        else:\n            name = f\"{name}.log\"\n\n        if cls._default_directory:\n            directory = cls._default_directory\n        else:\n            try:\n                directory = make_splunkhome_path([\"var\", \"log\", \"splunk\"])\n            except KeyError:\n                raise LogException(\n                    \"Log directory is empty, please set log directory \"\n                    'by calling Logs.set_context(directory=\"/var/log/...\").'\n                )\n        log_file = op.sep.join([directory, name])\n\n        return log_file\n\n    def __init__(self):\n        self._lock = Lock()\n        self._loggers = {}\n\n    def get_logger(self, name: str) -&gt; logging.Logger:\n\"\"\"Get logger with the name of `name`.\n\n        If logger with the name of `name` exists just return else create a new\n        logger with the name of `name`.\n\n        Arguments:\n            name: Logger name, it will be used as log file name too.\n\n        Returns:\n            A named logger.\n        \"\"\"\n\n        with self._lock:\n            log_file = self._get_log_file(name)\n            if log_file in self._loggers:\n                return self._loggers[log_file]\n\n            logger = logging.getLogger(log_file)\n            handler_exists = any(\n                [True for h in logger.handlers if h.baseFilename == log_file]\n            )\n            if not handler_exists:\n                file_handler = logging.handlers.RotatingFileHandler(\n                    log_file,\n                    mode=\"a\",\n                    maxBytes=self._default_max_bytes,\n                    backupCount=self._default_backup_count,\n                )\n                file_handler.setFormatter(logging.Formatter(self._default_log_format))\n                logger.addHandler(file_handler)\n                logger.setLevel(self._default_log_level)\n                logger.propagate = False\n\n            self._loggers[log_file] = logger\n            return logger\n\n    def set_level(self, level: int, name: str = None):\n\"\"\"Set log level of logger.\n\n        Set log level of all logger if `name` is None else of\n        logger with the name of `name`.\n\n        Arguments:\n            level: Log level to set.\n            name: The name of logger, default is None.\n        \"\"\"\n\n        with self._lock:\n            if name:\n                log_file = self._get_log_file(name)\n                logger = self._loggers.get(log_file)\n                if logger:\n                    logger.setLevel(level)\n            else:\n                self._default_log_level = level\n                for logger in list(self._loggers.values()):\n                    logger.setLevel(level)\n                logging.getLogger().setLevel(level)\n</code></pre>"},{"location":"log/#solnlib.log.Logs.__init__","title":"<code>__init__()</code>","text":"Source code in <code>solnlib/log.py</code> <pre><code>def __init__(self):\n    self._lock = Lock()\n    self._loggers = {}\n</code></pre>"},{"location":"log/#solnlib.log.Logs.get_logger","title":"<code>get_logger(name)</code>","text":"<p>Get logger with the name of <code>name</code>.</p> <p>If logger with the name of <code>name</code> exists just return else create a new logger with the name of <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name, it will be used as log file name too.</p> required <p>Returns:</p> Type Description <code>logging.Logger</code> <p>A named logger.</p> Source code in <code>solnlib/log.py</code> <pre><code>def get_logger(self, name: str) -&gt; logging.Logger:\n\"\"\"Get logger with the name of `name`.\n\n    If logger with the name of `name` exists just return else create a new\n    logger with the name of `name`.\n\n    Arguments:\n        name: Logger name, it will be used as log file name too.\n\n    Returns:\n        A named logger.\n    \"\"\"\n\n    with self._lock:\n        log_file = self._get_log_file(name)\n        if log_file in self._loggers:\n            return self._loggers[log_file]\n\n        logger = logging.getLogger(log_file)\n        handler_exists = any(\n            [True for h in logger.handlers if h.baseFilename == log_file]\n        )\n        if not handler_exists:\n            file_handler = logging.handlers.RotatingFileHandler(\n                log_file,\n                mode=\"a\",\n                maxBytes=self._default_max_bytes,\n                backupCount=self._default_backup_count,\n            )\n            file_handler.setFormatter(logging.Formatter(self._default_log_format))\n            logger.addHandler(file_handler)\n            logger.setLevel(self._default_log_level)\n            logger.propagate = False\n\n        self._loggers[log_file] = logger\n        return logger\n</code></pre>"},{"location":"log/#solnlib.log.Logs.set_context","title":"<code>set_context(**context)</code>  <code>classmethod</code>","text":"<p>Set log context.</p> List of keyword arguments <p>directory: Log directory, default is splunk log root directory. namespace: Logger namespace, default is None. log_format: Log format, default is <code>_default_log_format</code>. log_level: Log level, default is logging.INFO. max_bytes: The maximum log file size before rollover, default is 25000000. backup_count: The number of log files to retain,default is 5. root_logger_log_file: Root logger log file name, default is \u2018solnlib\u2019   .</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>dict</code> <p>Keyword arguments. See list of arguments above.</p> <code>{}</code> Source code in <code>solnlib/log.py</code> <pre><code>@classmethod\ndef set_context(cls, **context: dict):\n\"\"\"Set log context.\n\n    List of keyword arguments:\n\n        directory: Log directory, default is splunk log root directory.\n        namespace: Logger namespace, default is None.\n        log_format: Log format, default is `_default_log_format`.\n        log_level: Log level, default is logging.INFO.\n        max_bytes: The maximum log file size before rollover, default is 25000000.\n        backup_count: The number of log files to retain,default is 5.\n        root_logger_log_file: Root logger log file name, default is 'solnlib'   .\n\n    Arguments:\n        context: Keyword arguments. See list of arguments above.\n    \"\"\"\n    if \"directory\" in context:\n        cls._default_directory = context[\"directory\"]\n    if \"namespace\" in context:\n        cls._default_namespace = context[\"namespace\"]\n    if \"log_format\" in context:\n        cls._default_log_format = context[\"log_format\"]\n    if \"log_level\" in context:\n        cls._default_log_level = context[\"log_level\"]\n    if \"max_bytes\" in context:\n        cls._default_max_bytes = context[\"max_bytes\"]\n    if \"backup_count\" in context:\n        cls._default_backup_count = context[\"backup_count\"]\n    if \"root_logger_log_file\" in context:\n        cls._default_root_logger_log_file = context[\"root_logger_log_file\"]\n        cls._reset_root_logger()\n</code></pre>"},{"location":"log/#solnlib.log.Logs.set_level","title":"<code>set_level(level, name=None)</code>","text":"<p>Set log level of logger.</p> <p>Set log level of all logger if <code>name</code> is None else of logger with the name of <code>name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Log level to set.</p> required <code>name</code> <code>str</code> <p>The name of logger, default is None.</p> <code>None</code> Source code in <code>solnlib/log.py</code> <pre><code>def set_level(self, level: int, name: str = None):\n\"\"\"Set log level of logger.\n\n    Set log level of all logger if `name` is None else of\n    logger with the name of `name`.\n\n    Arguments:\n        level: Log level to set.\n        name: The name of logger, default is None.\n    \"\"\"\n\n    with self._lock:\n        if name:\n            log_file = self._get_log_file(name)\n            logger = self._loggers.get(log_file)\n            if logger:\n                logger.setLevel(level)\n        else:\n            self._default_log_level = level\n            for logger in list(self._loggers.values()):\n                logger.setLevel(level)\n            logging.getLogger().setLevel(level)\n</code></pre>"},{"location":"log/#solnlib.log.events_ingested","title":"<code>events_ingested(logger, modular_input_name, sourcetype, n_events, index, account=None, host=None, license_usage_source=None)</code>","text":"<p>Specific function to log the basic information of events ingested for the monitoring dashboard.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>logging.Logger</code> <p>Add-on logger.</p> required <code>modular_input_name</code> <code>str</code> <p>Full name of the modular input. It needs to be in a format <code>&lt;input_type&gt;://&lt;input_name&gt;</code>. In case of invalid format ValueError is raised.</p> required <code>sourcetype</code> <code>str</code> <p>Source type used to write event.</p> required <code>n_events</code> <code>int</code> <p>Number of ingested events.</p> required <code>index</code> <code>str</code> <p>Index used to write event.</p> required <code>license_usage_source</code> <code>str</code> <p>source used to match data with license_usage.log.</p> <code>None</code> <code>account</code> <code>str</code> <p>Account used to write event. (optional)</p> <code>None</code> <code>host</code> <code>str</code> <p>Host used to write event. (optional)</p> <code>None</code> Source code in <code>solnlib/log.py</code> <pre><code>def events_ingested(\n    logger: logging.Logger,\n    modular_input_name: str,\n    sourcetype: str,\n    n_events: int,\n    index: str,\n    account: str = None,\n    host: str = None,\n    license_usage_source: str = None,\n):\n\"\"\"Specific function to log the basic information of events ingested for\n    the monitoring dashboard.\n\n    Arguments:\n        logger: Add-on logger.\n        modular_input_name: Full name of the modular input. It needs to be in a format `&lt;input_type&gt;://&lt;input_name&gt;`.\n            In case of invalid format ValueError is raised.\n        sourcetype: Source type used to write event.\n        n_events: Number of ingested events.\n        index: Index used to write event.\n        license_usage_source: source used to match data with license_usage.log.\n        account: Account used to write event. (optional)\n        host: Host used to write event. (optional)\n    \"\"\"\n\n    if \"://\" in modular_input_name:\n        input_name = modular_input_name.split(\"/\")[-1]\n    else:\n        raise ValueError(\n            f\"Invalid modular input name: {modular_input_name}. \"\n            f\"It should be in format &lt;input_type&gt;://&lt;input_name&gt;\"\n        )\n\n    result = {\n        \"action\": \"events_ingested\",\n        \"modular_input_name\": license_usage_source\n        if license_usage_source\n        else modular_input_name,\n        \"sourcetype_ingested\": sourcetype,\n        \"n_events\": n_events,\n        \"event_input\": input_name,\n        \"event_index\": index,\n    }\n\n    if account:\n        result[\"event_account\"] = account\n\n    if host:\n        result[\"event_host\"] = host\n\n    log_event(logger, result)\n</code></pre>"},{"location":"log/#solnlib.log.log_enter_exit","title":"<code>log_enter_exit(logger)</code>","text":"<p>Decorator for logger to log function enter and exit.</p> <p>This decorator will generate a lot of debug log, please add this only when it is required.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>logging.Logger</code> <p>Logger to decorate.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; @log_enter_exit\n&gt;&gt;&gt; def myfunc():\n&gt;&gt;&gt;     doSomething()\n</code></pre> Source code in <code>solnlib/log.py</code> <pre><code>def log_enter_exit(logger: logging.Logger):\n\"\"\"Decorator for logger to log function enter and exit.\n\n    This decorator will generate a lot of debug log, please add this\n    only when it is required.\n\n    Arguments:\n        logger: Logger to decorate.\n\n    Examples:\n        &gt;&gt;&gt; @log_enter_exit\n        &gt;&gt;&gt; def myfunc():\n        &gt;&gt;&gt;     doSomething()\n    \"\"\"\n\n    def log_decorator(func):\n        def wrapper(*args, **kwargs):\n            logger.debug(\"%s entered\", func.__name__)\n            result = func(*args, **kwargs)\n            logger.debug(\"%s exited\", func.__name__)\n            return result\n\n        return wrapper\n\n    return log_decorator\n</code></pre>"},{"location":"log/#solnlib.log.log_event","title":"<code>log_event(logger, key_values, log_level=logging.INFO)</code>","text":"<p>General function to log any event in key-value format.</p> Source code in <code>solnlib/log.py</code> <pre><code>def log_event(\n    logger: logging.Logger, key_values: Dict[str, Any], log_level: int = logging.INFO\n):\n\"\"\"General function to log any event in key-value format.\"\"\"\n    message = \" \".join([f\"{k}={v}\" for k, v in key_values.items()])\n    logger.log(log_level, message)\n</code></pre>"},{"location":"log/#solnlib.log.log_exception","title":"<code>log_exception(logger, e, exc_label, full_msg=True, msg_before=None, msg_after=None, log_level=logging.ERROR)</code>","text":"<p>General function to log exceptions.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>logging.Logger</code> <p>Add-on logger.</p> required <code>e</code> <code>Exception</code> <p>Exception to log.</p> required <code>exc_label</code> <code>str</code> <p>label for the error to categorize it.</p> required <code>full_msg</code> <code>bool</code> <p>if set to True, full traceback will be logged. Default: True</p> <code>True</code> <code>msg_before</code> <code>str</code> <p>custom message before exception traceback. Default: None</p> <code>None</code> <code>msg_after</code> <code>str</code> <p>custom message after exception traceback. Default: None</p> <code>None</code> <code>log_level</code> <code>int</code> <p>Log level to log exception. Default: ERROR.</p> <code>logging.ERROR</code> Source code in <code>solnlib/log.py</code> <pre><code>def log_exception(\n    logger: logging.Logger,\n    e: Exception,\n    exc_label: str,\n    full_msg: bool = True,\n    msg_before: str = None,\n    msg_after: str = None,\n    log_level: int = logging.ERROR,\n):\n\"\"\"General function to log exceptions.\n\n    Arguments:\n        logger: Add-on logger.\n        e: Exception to log.\n        exc_label: label for the error to categorize it.\n        full_msg: if set to True, full traceback will be logged. Default: True\n        msg_before: custom message before exception traceback. Default: None\n        msg_after: custom message after exception traceback. Default: None\n        log_level: Log level to log exception. Default: ERROR.\n    \"\"\"\n\n    msg = _get_exception_message(e, full_msg, msg_before, msg_after)\n    logger.log(log_level, f'exc_l=\"{exc_label}\" {msg}')\n</code></pre>"},{"location":"log/#solnlib.log.modular_input_end","title":"<code>modular_input_end(logger, modular_input_name)</code>","text":"<p>Specific function to log the end of the modular input.</p> Source code in <code>solnlib/log.py</code> <pre><code>def modular_input_end(logger: logging.Logger, modular_input_name: str):\n\"\"\"Specific function to log the end of the modular input.\"\"\"\n    log_event(\n        logger,\n        {\n            \"action\": \"ended\",\n            \"modular_input_name\": modular_input_name,\n        },\n    )\n</code></pre>"},{"location":"log/#solnlib.log.modular_input_start","title":"<code>modular_input_start(logger, modular_input_name)</code>","text":"<p>Specific function to log the start of the modular input.</p> Source code in <code>solnlib/log.py</code> <pre><code>def modular_input_start(logger: logging.Logger, modular_input_name: str):\n\"\"\"Specific function to log the start of the modular input.\"\"\"\n    log_event(\n        logger,\n        {\n            \"action\": \"started\",\n            \"modular_input_name\": modular_input_name,\n        },\n    )\n</code></pre>"},{"location":"net_utils/","title":"net_utils.py","text":"<p>Net utilities.</p>"},{"location":"net_utils/#solnlib.net_utils.__all__","title":"<code>__all__ = ['resolve_hostname', 'validate_scheme_host_port']</code>  <code>module-attribute</code>","text":""},{"location":"net_utils/#solnlib.net_utils.is_valid_hostname","title":"<code>is_valid_hostname(hostname)</code>","text":"<p>Validate a host name.</p> <p>Parameters:</p> Name Type Description Default <code>hostname</code> <code>str</code> <p>host name to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if is valid else False.</p> Source code in <code>solnlib/net_utils.py</code> <pre><code>def is_valid_hostname(hostname: str) -&gt; bool:\n\"\"\"Validate a host name.\n\n    Arguments:\n        hostname: host name to validate.\n\n    Returns:\n        True if is valid else False.\n    \"\"\"\n    # Splunk IPv6 support.\n    # https://docs.splunk.com/Documentation/Splunk/9.0.0/Admin/ConfigureSplunkforIPv6#Change_the_prioritization_of_IPv4_and_IPv6_communications\n    if hostname == \"[::1]\":\n        return True\n\n    if len(hostname) &gt; 255:\n        return False\n    if hostname[-1:] == \".\":\n        hostname = hostname[:-1]\n    allowed = re.compile(r\"(?!-)(::)?[A-Z\\d-]{1,63}(?&lt;!-)$\", re.IGNORECASE)\n    return all(allowed.match(x) for x in hostname.split(\".\"))\n</code></pre>"},{"location":"net_utils/#solnlib.net_utils.is_valid_ip","title":"<code>is_valid_ip(addr)</code>","text":"<p>Validate an IPV4 address.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>IP address to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if is valid else False.</p> Source code in <code>solnlib/net_utils.py</code> <pre><code>def is_valid_ip(addr: str) -&gt; bool:\n\"\"\"Validate an IPV4 address.\n\n    Arguments:\n        addr: IP address to validate.\n\n    Returns:\n        True if is valid else False.\n    \"\"\"\n\n    ip_rx = re.compile(\nr\"\"\"\n        ^(((\n              [0-1]\\d{2}                  # matches 000-199\n            | 2[0-4]\\d                    # matches 200-249\n            | 25[0-5]                     # matches 250-255\n            | \\d{1,2}                     # matches 0-9, 00-99\n        )\\.){3})                          # 3 of the preceding stanzas\n        ([0-1]\\d{2}|2[0-4]\\d|25[0-5]|\\d{1,2})$     # final octet\n    \"\"\",\n        re.VERBOSE,\n    )\n\n    try:\n        return ip_rx.match(addr.strip())\n    except AttributeError:\n        # Value was not a string\n        return False\n</code></pre>"},{"location":"net_utils/#solnlib.net_utils.is_valid_port","title":"<code>is_valid_port(port)</code>","text":"<p>Validate a port.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>Union[str, int]</code> <p>port to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if is valid else False.</p> Source code in <code>solnlib/net_utils.py</code> <pre><code>def is_valid_port(port: Union[str, int]) -&gt; bool:\n\"\"\"Validate a port.\n\n    Arguments:\n        port: port to validate.\n\n    Returns:\n        True if is valid else False.\n    \"\"\"\n\n    try:\n        return 0 &lt; int(port) &lt;= 65535\n    except ValueError:\n        return False\n</code></pre>"},{"location":"net_utils/#solnlib.net_utils.is_valid_scheme","title":"<code>is_valid_scheme(scheme)</code>","text":"<p>Validate a scheme.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>scheme to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if is valid else False.</p> Source code in <code>solnlib/net_utils.py</code> <pre><code>def is_valid_scheme(scheme: str) -&gt; bool:\n\"\"\"Validate a scheme.\n\n    Arguments:\n        scheme: scheme to validate.\n\n    Returns:\n        True if is valid else False.\n    \"\"\"\n\n    return scheme.lower() in (\"http\", \"https\")\n</code></pre>"},{"location":"net_utils/#solnlib.net_utils.resolve_hostname","title":"<code>resolve_hostname(addr)</code>","text":"<p>Try to resolve an IP to a host name and returns None on common failures.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>IP address to resolve.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Host name if success else None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>addr</code> is not a valid address.</p> Source code in <code>solnlib/net_utils.py</code> <pre><code>def resolve_hostname(addr: str) -&gt; Optional[str]:\n\"\"\"Try to resolve an IP to a host name and returns None on common failures.\n\n    Arguments:\n        addr: IP address to resolve.\n\n    Returns:\n        Host name if success else None.\n\n    Raises:\n        ValueError: If `addr` is not a valid address.\n    \"\"\"\n\n    if is_valid_ip(addr):\n        try:\n            name, _, _ = socket.gethostbyaddr(addr)\n            return name\n        except socket.gaierror:\n            # [Errno 8] nodename nor servname provided, or not known\n            pass\n        except socket.herror:\n            # [Errno 1] Unknown host\n            pass\n        except socket.timeout:\n            # Timeout.\n            pass\n\n        return None\n    else:\n        raise ValueError(\"Invalid ip address.\")\n</code></pre>"},{"location":"net_utils/#solnlib.net_utils.validate_scheme_host_port","title":"<code>validate_scheme_host_port(scheme, host, port)</code>","text":"<p>Validates scheme, host and port.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>str</code> <p>scheme to validate.</p> required <code>host</code> <code>str</code> <p>hostname to validate.</p> required <code>port</code> <code>Union[str, int]</code> <p>port to validate.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if scheme, host or port are invalid.</p> Source code in <code>solnlib/net_utils.py</code> <pre><code>def validate_scheme_host_port(scheme: str, host: str, port: Union[str, int]):\n\"\"\"Validates scheme, host and port.\n\n    Arguments:\n        scheme: scheme to validate.\n        host: hostname to validate.\n        port: port to validate.\n\n    Raises:\n        ValueError: if scheme, host or port are invalid.\n    \"\"\"\n    if scheme is not None and not is_valid_scheme(scheme):\n        raise ValueError(\"Invalid scheme\")\n    if host is not None and not is_valid_hostname(host):\n        raise ValueError(\"Invalid host\")\n    if port is not None and not is_valid_port(port):\n        raise ValueError(\"Invalid port\")\n</code></pre>"},{"location":"orphan_process_monitor/","title":"orphan_process_monitor.py","text":"<p>Orphan process monitor.</p>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.__all__","title":"<code>__all__ = ['OrphanProcessChecker', 'OrphanProcessMonitor']</code>  <code>module-attribute</code>","text":""},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker","title":"<code>OrphanProcessChecker</code>","text":"<p>Orphan process checker.</p> <p>Only work for Linux platform. On Windows platform, is_orphan is always False and there is no need to do this monitoring on Windows.</p> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>class OrphanProcessChecker:\n\"\"\"Orphan process checker.\n\n    Only work for Linux platform. On Windows platform, is_orphan is\n    always False and there is no need to do this monitoring on Windows.\n    \"\"\"\n\n    def __init__(self, callback: Callable = None):\n\"\"\"Initializes OrphanProcessChecker.\n\n        Arguments:\n            callback: (optional) Callback for orphan process.\n        \"\"\"\n        if os.name == \"nt\":\n            self._ppid = 0\n        else:\n            self._ppid = os.getppid()\n        self._callback = callback\n\n    def is_orphan(self) -&gt; bool:\n\"\"\"Check process is orphan.\n\n        For windows platform just return False.\n\n        Returns:\n            True for orphan process else False.\n        \"\"\"\n\n        if os.name == \"nt\":\n            return False\n        return self._ppid != os.getppid()\n\n    def check_orphan(self) -&gt; bool:\n\"\"\"Check if the process becomes orphan.\n\n        If the process becomes orphan then call callback function\n        to handle properly.\n\n        Returns:\n            True for orphan process else False.\n        \"\"\"\n\n        res = self.is_orphan()\n        if res and self._callback:\n            self._callback()\n        return res\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker.__init__","title":"<code>__init__(callback=None)</code>","text":"<p>Initializes OrphanProcessChecker.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>(optional) Callback for orphan process.</p> <code>None</code> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>def __init__(self, callback: Callable = None):\n\"\"\"Initializes OrphanProcessChecker.\n\n    Arguments:\n        callback: (optional) Callback for orphan process.\n    \"\"\"\n    if os.name == \"nt\":\n        self._ppid = 0\n    else:\n        self._ppid = os.getppid()\n    self._callback = callback\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker.check_orphan","title":"<code>check_orphan()</code>","text":"<p>Check if the process becomes orphan.</p> <p>If the process becomes orphan then call callback function to handle properly.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True for orphan process else False.</p> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>def check_orphan(self) -&gt; bool:\n\"\"\"Check if the process becomes orphan.\n\n    If the process becomes orphan then call callback function\n    to handle properly.\n\n    Returns:\n        True for orphan process else False.\n    \"\"\"\n\n    res = self.is_orphan()\n    if res and self._callback:\n        self._callback()\n    return res\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessChecker.is_orphan","title":"<code>is_orphan()</code>","text":"<p>Check process is orphan.</p> <p>For windows platform just return False.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True for orphan process else False.</p> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>def is_orphan(self) -&gt; bool:\n\"\"\"Check process is orphan.\n\n    For windows platform just return False.\n\n    Returns:\n        True for orphan process else False.\n    \"\"\"\n\n    if os.name == \"nt\":\n        return False\n    return self._ppid != os.getppid()\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor","title":"<code>OrphanProcessMonitor</code>","text":"<p>Orphan process monitor.</p> <p>Check if process become orphan in background thread per interval and call callback if process become orphan.</p> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>class OrphanProcessMonitor:\n\"\"\"Orphan process monitor.\n\n    Check if process become orphan in background thread per interval and\n    call callback if process become orphan.\n    \"\"\"\n\n    def __init__(self, callback: Callable, interval: int = 1):\n\"\"\"Initializes OrphanProcessMonitor.\n\n        Arguments:\n            callback: Callback for orphan process monitor.\n            interval: (optional) Interval to monitor.\n        \"\"\"\n        self._checker = OrphanProcessChecker(callback)\n        self._thr = threading.Thread(target=self._do_monitor)\n        self._thr.daemon = True\n        self._started = False\n        self._interval = interval\n\n    def start(self):\n\"\"\"Start orphan process monitor.\"\"\"\n\n        if self._started:\n            return\n        self._started = True\n\n        self._thr.start()\n\n    def stop(self):\n\"\"\"Stop orphan process monitor.\"\"\"\n\n        joinable = self._started\n        self._started = False\n        if joinable:\n            self._thr.join(timeout=1)\n\n    def _do_monitor(self):\n        while self._started:\n            if self._checker.check_orphan():\n                break\n\n            for _ in range(self._interval):\n                if not self._started:\n                    break\n                time.sleep(1)\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor.__init__","title":"<code>__init__(callback, interval=1)</code>","text":"<p>Initializes OrphanProcessMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Callback for orphan process monitor.</p> required <code>interval</code> <code>int</code> <p>(optional) Interval to monitor.</p> <code>1</code> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>def __init__(self, callback: Callable, interval: int = 1):\n\"\"\"Initializes OrphanProcessMonitor.\n\n    Arguments:\n        callback: Callback for orphan process monitor.\n        interval: (optional) Interval to monitor.\n    \"\"\"\n    self._checker = OrphanProcessChecker(callback)\n    self._thr = threading.Thread(target=self._do_monitor)\n    self._thr.daemon = True\n    self._started = False\n    self._interval = interval\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor.start","title":"<code>start()</code>","text":"<p>Start orphan process monitor.</p> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>def start(self):\n\"\"\"Start orphan process monitor.\"\"\"\n\n    if self._started:\n        return\n    self._started = True\n\n    self._thr.start()\n</code></pre>"},{"location":"orphan_process_monitor/#solnlib.orphan_process_monitor.OrphanProcessMonitor.stop","title":"<code>stop()</code>","text":"<p>Stop orphan process monitor.</p> Source code in <code>solnlib/orphan_process_monitor.py</code> <pre><code>def stop(self):\n\"\"\"Stop orphan process monitor.\"\"\"\n\n    joinable = self._started\n    self._started = False\n    if joinable:\n        self._thr.join(timeout=1)\n</code></pre>"},{"location":"pattern/","title":"pattern.py","text":"<p>This module provides some common used patterns.</p>"},{"location":"pattern/#solnlib.pattern.__all__","title":"<code>__all__ = ['Singleton']</code>  <code>module-attribute</code>","text":""},{"location":"pattern/#solnlib.pattern.Singleton","title":"<code>Singleton</code>","text":"<p>         Bases: <code>type</code></p> <p>Singleton meta class.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Test(object):\n&gt;&gt;&gt;     __metaclass__ = Singleton\n&gt;&gt;&gt;\n&gt;&gt;&gt;     def __init__(self):\n&gt;&gt;&gt;         pass\n</code></pre> Source code in <code>solnlib/pattern.py</code> <pre><code>class Singleton(type):\n\"\"\"Singleton meta class.\n\n    Examples:\n       &gt;&gt;&gt; class Test(object):\n       &gt;&gt;&gt;     __metaclass__ = Singleton\n       &gt;&gt;&gt;\n       &gt;&gt;&gt;     def __init__(self):\n       &gt;&gt;&gt;         pass\n    \"\"\"\n\n    def __init__(cls, name, bases, attrs):\n        super().__init__(name, bases, attrs)\n        cls._instance = None\n\n    def __call__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__call__(*args, **kwargs)\n        return cls._instance\n</code></pre>"},{"location":"pattern/#solnlib.pattern.Singleton.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"Source code in <code>solnlib/pattern.py</code> <pre><code>def __call__(cls, *args, **kwargs):\n    if cls._instance is None:\n        cls._instance = super().__call__(*args, **kwargs)\n    return cls._instance\n</code></pre>"},{"location":"pattern/#solnlib.pattern.Singleton.__init__","title":"<code>__init__(name, bases, attrs)</code>","text":"Source code in <code>solnlib/pattern.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"release_6_0_0/","title":"Removed requests and urllib3 from solnlib","text":"<p>The <code>requests</code> and <code>urllib3</code> libraries has been removed from solnlib, so solnlib now depends on the <code>requests</code> and <code>urllib3</code> libraries from the running environment. By default, Splunk delivers the above libraries and their version depends on the Splunk version. More information here.</p> <p>IMPORTANT: <code>urllib3</code> is available in Splunk <code>v8.1.0</code> and later</p> <p>Please note that if <code>requests</code> or <code>urllib3</code> are installed in <code>&lt;Add-on&gt;/lib</code> e.g. as a dependency of another library, that version will be taken first. If <code>requests</code> or <code>urllib3</code> is missing in the add-on\u2019s <code>lib</code> directory, the version provided by Splunk will be used.</p>"},{"location":"release_6_0_0/#custom-version-of-requests-and-urllib3","title":"Custom Version of requests and urllib3","text":"<p>In case the Splunk\u2019s <code>requests</code> or <code>urllib3</code> version is not sufficient for you,  you can deliver version you need by simply adding it to the <code>requirements.txt</code> or <code>pyproject.toml</code> file in your add-on.</p>"},{"location":"release_6_0_0/#use-solnlib-outside-the-splunk","title":"Use solnlib outside the Splunk","text":"<p>Solnlib no longer provides <code>requests</code> and <code>urllib3</code> so if you want to use solnlib outside the Splunk, please note that you will need to provide these libraries yourself in the environment where solnlib is used.</p>"},{"location":"release_7_0_0/","title":"Removed usage of btool command from solnlib","text":"<p>As of version 7.0.0, the <code>btool</code> command has been removed from solnlib. Configuration stanzas and keys should now be accessed via the REST API.  Additionally, the <code>splunkenv</code> module can only be used in environments where Splunk is installed, as it relies on Splunk-specific methods for making internal calls.</p>"},{"location":"release_7_0_0/#session-key-is-now-mandatory-in-some-of-the-functions","title":"Session key is now mandatory in some of the functions","text":"<p>The affected functions now require a valid <code>session_key</code> to operate correctly. While solnlib attempts to retrieve the <code>session_key</code> automatically,  there are scenarios\u2014such as within a modular input script\u2014where this is not possible. In such cases, you must explicitly provide the <code>session_key</code>  to ensure proper authorization. Affected functions are:</p> <ul> <li><code>get_splunk_host_info</code></li> <li><code>get_splunkd_access_info</code></li> <li><code>get_scheme_from_hec_settings</code></li> <li><code>get_splunkd_uri</code></li> <li><code>get_conf_key_value</code></li> <li><code>get_conf_stanza</code></li> </ul>"},{"location":"release_7_0_0/#changed-arguments-in-get_conf_key_value-and-get_conf_stanza","title":"Changed arguments in <code>get_conf_key_value</code> and <code>get_conf_stanza</code>","text":"<p>As of version 7.0.0, the following changes have been made to the function:</p> <p><code>get_conf_key_value</code> now requires 4 mandatory arguments:</p> <ul> <li><code>conf_name</code></li> <li><code>stanza</code></li> <li><code>key</code></li> <li><code>app_name</code> (new)</li> </ul> <p><code>get_conf_stanza</code> now requires 3 mandatory arguments:</p> <ul> <li><code>conf_name</code></li> <li><code>stanza</code></li> <li><code>app_name</code> (new)</li> </ul> <p>Both functions also accept the following optional arguments:</p> <ul> <li><code>session_key</code> - Used for authentication. If not provided, a 401 Unauthorized error may occur depending on the context.</li> <li><code>users</code> - Limits results returned by the configuration endpoint. Defaults to <code>nobody</code>.</li> <li><code>raw_output</code> - If set to <code>True</code>, the full decoded JSON response is returned.  This should be enabled when <code>app_name</code> is set to the global context <code>(/-/)</code>, as the Splunk REST API may return multiple entries in that case.</li> </ul>"},{"location":"release_7_0_0/#the-get_session_key-function-has-been-removed-from-solnlib","title":"The <code>get_session_key</code> function has been removed from solnlib","text":"<p>This function relied on reading the <code>scheme</code>, <code>host</code> and <code>port</code> using the deprecated btool utility, which is no longer supported.</p>"},{"location":"server_info/","title":"server_info.py","text":"<p>This module contains Splunk server info related functionalities.</p>"},{"location":"server_info/#solnlib.server_info.__all__","title":"<code>__all__ = ['ServerInfo', 'ServerInfoException']</code>  <code>module-attribute</code>","text":""},{"location":"server_info/#solnlib.server_info.ServerInfo","title":"<code>ServerInfo</code>","text":"<p>This class is a wrapper of Splunk server info.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>class ServerInfo:\n\"\"\"This class is a wrapper of Splunk server info.\"\"\"\n\n    SHC_MEMBER_ENDPOINT = \"/services/shcluster/member/members\"\n    SHC_CAPTAIN_INFO_ENDPOINT = \"/services/shcluster/captain/info\"\n\n    def __init__(\n        self,\n        session_key: str,\n        scheme: Optional[str] = None,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        **context: Any\n    ):\n\"\"\"Initializes ServerInfo.\n\n        Arguments:\n            session_key: Splunk access token.\n            scheme: The access scheme, default is None.\n            host: The host name, default is None.\n            port: The port number, default is None.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        is_localhost = False\n        if not all([scheme, host, port]) and os.environ.get(\"SPLUNK_HOME\"):\n            scheme, host, port = get_splunkd_access_info(session_key)\n            is_localhost = (\n                host == \"localhost\" or host == \"127.0.0.1\" or host in (\"::1\", \"[::1]\")\n            )\n\n        web_key_file = getWebKeyFile()\n        web_cert_file = getWebCertFile()\n        if web_cert_file and (\n            web_key_file is None or not is_cert_or_key_encrypted(web_key_file)\n        ):\n            context[\"cert_file\"] = web_cert_file\n\n            if web_key_file is not None:\n                context[\"key_file\"] = web_key_file\n\n            if all([is_localhost, context.get(\"verify\") is None]):\n                # NOTE: this is specifically for mTLS communication\n                # ONLY if scheme, host, port aren't provided AND user hasn't provided server certificate\n                # we set verify to off (similar to 'rest.simpleRequest' implementation)\n                context[\"verify\"] = False\n\n        self._rest_client = rest_client.SplunkRestClient(\n            session_key, \"-\", scheme=scheme, host=host, port=port, **context\n        )\n\n    @classmethod\n    def from_server_uri(\n        cls, server_uri: str, session_key: str, **context: Any\n    ) -&gt; \"ServerInfo\":\n\"\"\"Creates ServerInfo class using server_uri and session_key.\n\n        Note: splunktalib uses these parameters to create it's ServerInfo class,\n        so this method should ease the transition from splunktalib to solnlib.\n\n        Arguments:\n            server_uri: splunkd URI.\n            session_key: Splunk access token.\n            context: Other configurations for Splunk rest client.\n\n        Returns:\n            An instance of `ServerInfo`.\n\n        Raises:\n            ValueError: server_uri is in the wrong format.\n        \"\"\"\n        scheme, host, port = utils.extract_http_scheme_host_port(server_uri)\n        return ServerInfo(\n            session_key,\n            scheme=scheme,\n            host=host,\n            port=port,\n            **context,\n        )\n\n    def to_dict(self) -&gt; Dict:\n\"\"\"Returns server information in a form dictionary.\n\n        Note: This method is implemented here to have compatibility with splunktalib's\n        analogue.\n\n        Returns:\n            Server information in a dictionary format.\n        \"\"\"\n        return self._server_info()\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def _server_info(self):\n        return self._rest_client.info\n\n    @property\n    def server_name(self) -&gt; str:\n\"\"\"Get server name.\n\n        Returns:\n            Server name.\n        \"\"\"\n        return self._server_info()[\"serverName\"]\n\n    @property\n    def guid(self) -&gt; str:\n\"\"\"Get guid for the server.\n\n        Returns:\n            Server GUID.\n        \"\"\"\n        return self._server_info()[\"guid\"]\n\n    @property\n    def version(self) -&gt; str:\n\"\"\"Get Splunk server version.\n\n        Returns:\n            Splunk version.\n        \"\"\"\n        return self._server_info()[\"version\"]\n\n    def is_captain(self) -&gt; bool:\n\"\"\"Check if this server is SHC captain.\n\n        Note during a rolling start of SH members, the captain may be changed\n        from machine to machine. To avoid the race condition, client may need\n        do necessary sleep and then poll `is_captain_ready() == True` and then\n        check `is_captain()`. See `is_captain_ready()` for more details.\n\n        Returns:\n            True if this server is SHC captain else False.\n        \"\"\"\n\n        return \"shc_captain\" in self._server_info()[\"server_roles\"]\n\n    def is_cloud_instance(self) -&gt; bool:\n\"\"\"Check if this server is a cloud instance.\n\n        Returns:\n            True if this server is a cloud instance else False.\n        \"\"\"\n\n        try:\n            return self._server_info()[\"instance_type\"] == \"cloud\"\n        except KeyError:\n            return False\n\n    def is_search_head(self) -&gt; bool:\n\"\"\"Check if this server is a search head.\n\n        Returns:\n            True if this server is a search head else False.\n        \"\"\"\n\n        server_info = self._server_info()\n        for sh in (\"search_head\", \"cluster_search_head\"):\n            if sh in server_info[\"server_roles\"]:\n                return True\n\n        return False\n\n    def is_shc_member(self) -&gt; bool:\n\"\"\"Check if this server is a SHC member.\n\n        Returns:\n            True if this server is a SHC member else False.\n        \"\"\"\n\n        server_info = self._server_info()\n        for sh in (\"shc_member\", \"shc_captain\"):\n            if sh in server_info[\"server_roles\"]:\n                return True\n\n        return False\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def get_shc_members(self) -&gt; list:\n\"\"\"Get SHC members.\n\n        Raises:\n            ServerInfoException: If this server has no SHC members.\n\n        Returns:\n            List of SHC members [(label, peer_scheme_host_port) ...].\n        \"\"\"\n        try:\n            content = self._rest_client.get(\n                self.SHC_MEMBER_ENDPOINT, output_mode=\"json\"\n            ).body.read()\n        except binding.HTTPError as e:\n            if e.status != 404 and e.status != 503:\n                raise\n\n            raise ServerInfoException(\n                \"This server is not a SHC member and has no SHC members.\"\n            )\n\n        members = []\n        for member in json.loads(content)[\"entry\"]:\n            content = member[\"content\"]\n            members.append((content[\"label\"], content[\"peer_scheme_host_port\"]))\n\n        return members\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def is_captain_ready(self) -&gt; bool:\n\"\"\"Check if captain is ready.\n\n        Client usually first polls this function until captain is ready\n        and then call is_captain to detect current captain machine\n\n        Returns:\n            True if captain is ready else False.\n\n        Examples:\n            &gt;&gt;&gt; from solnlib import server_info\n            &gt;&gt;&gt; serverinfo = server_info.ServerInfo(session_key)\n            &gt;&gt;&gt; while 1:\n            &gt;&gt;&gt;    if serverinfo.is_captain_ready():\n            &gt;&gt;&gt;        break\n            &gt;&gt;&gt;    time.sleep(2)\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # If do_stuff can only be executed in SH captain\n            &gt;&gt;&gt; if serverinfo.is_captain():\n            &gt;&gt;&gt;    do_stuff()\n        \"\"\"\n\n        cap_info = self.captain_info()\n        return utils.is_true(cap_info[\"service_ready_flag\"]) and utils.is_false(\n            cap_info[\"maintenance_mode\"]\n        )\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def captain_info(self) -&gt; dict:\n\"\"\"Get captain information.\n\n        Raises:\n            ServerInfoException: If there is SHC is not enabled.\n\n        Returns:\n            Captain information.\n        \"\"\"\n\n        try:\n            content = self._rest_client.get(\n                self.SHC_CAPTAIN_INFO_ENDPOINT, output_mode=\"json\"\n            ).body.read()\n        except binding.HTTPError as e:\n            if e.status == 503 and \"not available\" in str(e):\n                raise ServerInfoException(str(e))\n            raise\n\n        return json.loads(content)[\"entry\"][0][\"content\"]\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.SHC_CAPTAIN_INFO_ENDPOINT","title":"<code>SHC_CAPTAIN_INFO_ENDPOINT = '/services/shcluster/captain/info'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"server_info/#solnlib.server_info.ServerInfo.SHC_MEMBER_ENDPOINT","title":"<code>SHC_MEMBER_ENDPOINT = '/services/shcluster/member/members'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"server_info/#solnlib.server_info.ServerInfo.guid","title":"<code>guid: str</code>  <code>property</code>","text":"<p>Get guid for the server.</p> <p>Returns:</p> Type Description <code>str</code> <p>Server GUID.</p>"},{"location":"server_info/#solnlib.server_info.ServerInfo.server_name","title":"<code>server_name: str</code>  <code>property</code>","text":"<p>Get server name.</p> <p>Returns:</p> Type Description <code>str</code> <p>Server name.</p>"},{"location":"server_info/#solnlib.server_info.ServerInfo.version","title":"<code>version: str</code>  <code>property</code>","text":"<p>Get Splunk server version.</p> <p>Returns:</p> Type Description <code>str</code> <p>Splunk version.</p>"},{"location":"server_info/#solnlib.server_info.ServerInfo.__init__","title":"<code>__init__(session_key, scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes ServerInfo.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>scheme</code> <code>Optional[str]</code> <p>The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>Optional[str]</code> <p>The host name, default is None.</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>The port number, default is None.</p> <code>None</code> <code>context</code> <code>Any</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/server_info.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    scheme: Optional[str] = None,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    **context: Any\n):\n\"\"\"Initializes ServerInfo.\n\n    Arguments:\n        session_key: Splunk access token.\n        scheme: The access scheme, default is None.\n        host: The host name, default is None.\n        port: The port number, default is None.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    is_localhost = False\n    if not all([scheme, host, port]) and os.environ.get(\"SPLUNK_HOME\"):\n        scheme, host, port = get_splunkd_access_info(session_key)\n        is_localhost = (\n            host == \"localhost\" or host == \"127.0.0.1\" or host in (\"::1\", \"[::1]\")\n        )\n\n    web_key_file = getWebKeyFile()\n    web_cert_file = getWebCertFile()\n    if web_cert_file and (\n        web_key_file is None or not is_cert_or_key_encrypted(web_key_file)\n    ):\n        context[\"cert_file\"] = web_cert_file\n\n        if web_key_file is not None:\n            context[\"key_file\"] = web_key_file\n\n        if all([is_localhost, context.get(\"verify\") is None]):\n            # NOTE: this is specifically for mTLS communication\n            # ONLY if scheme, host, port aren't provided AND user hasn't provided server certificate\n            # we set verify to off (similar to 'rest.simpleRequest' implementation)\n            context[\"verify\"] = False\n\n    self._rest_client = rest_client.SplunkRestClient(\n        session_key, \"-\", scheme=scheme, host=host, port=port, **context\n    )\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.captain_info","title":"<code>captain_info()</code>","text":"<p>Get captain information.</p> <p>Raises:</p> Type Description <code>ServerInfoException</code> <p>If there is SHC is not enabled.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Captain information.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef captain_info(self) -&gt; dict:\n\"\"\"Get captain information.\n\n    Raises:\n        ServerInfoException: If there is SHC is not enabled.\n\n    Returns:\n        Captain information.\n    \"\"\"\n\n    try:\n        content = self._rest_client.get(\n            self.SHC_CAPTAIN_INFO_ENDPOINT, output_mode=\"json\"\n        ).body.read()\n    except binding.HTTPError as e:\n        if e.status == 503 and \"not available\" in str(e):\n            raise ServerInfoException(str(e))\n        raise\n\n    return json.loads(content)[\"entry\"][0][\"content\"]\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.from_server_uri","title":"<code>from_server_uri(server_uri, session_key, **context)</code>  <code>classmethod</code>","text":"<p>Creates ServerInfo class using server_uri and session_key.</p> <p>Note: splunktalib uses these parameters to create it\u2019s ServerInfo class, so this method should ease the transition from splunktalib to solnlib.</p> <p>Parameters:</p> Name Type Description Default <code>server_uri</code> <code>str</code> <p>splunkd URI.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>context</code> <code>Any</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Returns:</p> Type Description <code>ServerInfo</code> <p>An instance of <code>ServerInfo</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>server_uri is in the wrong format.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>@classmethod\ndef from_server_uri(\n    cls, server_uri: str, session_key: str, **context: Any\n) -&gt; \"ServerInfo\":\n\"\"\"Creates ServerInfo class using server_uri and session_key.\n\n    Note: splunktalib uses these parameters to create it's ServerInfo class,\n    so this method should ease the transition from splunktalib to solnlib.\n\n    Arguments:\n        server_uri: splunkd URI.\n        session_key: Splunk access token.\n        context: Other configurations for Splunk rest client.\n\n    Returns:\n        An instance of `ServerInfo`.\n\n    Raises:\n        ValueError: server_uri is in the wrong format.\n    \"\"\"\n    scheme, host, port = utils.extract_http_scheme_host_port(server_uri)\n    return ServerInfo(\n        session_key,\n        scheme=scheme,\n        host=host,\n        port=port,\n        **context,\n    )\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.get_shc_members","title":"<code>get_shc_members()</code>","text":"<p>Get SHC members.</p> <p>Raises:</p> Type Description <code>ServerInfoException</code> <p>If this server has no SHC members.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of SHC members [(label, peer_scheme_host_port) \u2026].</p> Source code in <code>solnlib/server_info.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_shc_members(self) -&gt; list:\n\"\"\"Get SHC members.\n\n    Raises:\n        ServerInfoException: If this server has no SHC members.\n\n    Returns:\n        List of SHC members [(label, peer_scheme_host_port) ...].\n    \"\"\"\n    try:\n        content = self._rest_client.get(\n            self.SHC_MEMBER_ENDPOINT, output_mode=\"json\"\n        ).body.read()\n    except binding.HTTPError as e:\n        if e.status != 404 and e.status != 503:\n            raise\n\n        raise ServerInfoException(\n            \"This server is not a SHC member and has no SHC members.\"\n        )\n\n    members = []\n    for member in json.loads(content)[\"entry\"]:\n        content = member[\"content\"]\n        members.append((content[\"label\"], content[\"peer_scheme_host_port\"]))\n\n    return members\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_captain","title":"<code>is_captain()</code>","text":"<p>Check if this server is SHC captain.</p> <p>Note during a rolling start of SH members, the captain may be changed from machine to machine. To avoid the race condition, client may need do necessary sleep and then poll <code>is_captain_ready() == True</code> and then check <code>is_captain()</code>. See <code>is_captain_ready()</code> for more details.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this server is SHC captain else False.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>def is_captain(self) -&gt; bool:\n\"\"\"Check if this server is SHC captain.\n\n    Note during a rolling start of SH members, the captain may be changed\n    from machine to machine. To avoid the race condition, client may need\n    do necessary sleep and then poll `is_captain_ready() == True` and then\n    check `is_captain()`. See `is_captain_ready()` for more details.\n\n    Returns:\n        True if this server is SHC captain else False.\n    \"\"\"\n\n    return \"shc_captain\" in self._server_info()[\"server_roles\"]\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_captain_ready","title":"<code>is_captain_ready()</code>","text":"<p>Check if captain is ready.</p> <p>Client usually first polls this function until captain is ready and then call is_captain to detect current captain machine</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if captain is ready else False.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import server_info\n&gt;&gt;&gt; serverinfo = server_info.ServerInfo(session_key)\n&gt;&gt;&gt; while 1:\n&gt;&gt;&gt;    if serverinfo.is_captain_ready():\n&gt;&gt;&gt;        break\n&gt;&gt;&gt;    time.sleep(2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # If do_stuff can only be executed in SH captain\n&gt;&gt;&gt; if serverinfo.is_captain():\n&gt;&gt;&gt;    do_stuff()\n</code></pre> Source code in <code>solnlib/server_info.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef is_captain_ready(self) -&gt; bool:\n\"\"\"Check if captain is ready.\n\n    Client usually first polls this function until captain is ready\n    and then call is_captain to detect current captain machine\n\n    Returns:\n        True if captain is ready else False.\n\n    Examples:\n        &gt;&gt;&gt; from solnlib import server_info\n        &gt;&gt;&gt; serverinfo = server_info.ServerInfo(session_key)\n        &gt;&gt;&gt; while 1:\n        &gt;&gt;&gt;    if serverinfo.is_captain_ready():\n        &gt;&gt;&gt;        break\n        &gt;&gt;&gt;    time.sleep(2)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # If do_stuff can only be executed in SH captain\n        &gt;&gt;&gt; if serverinfo.is_captain():\n        &gt;&gt;&gt;    do_stuff()\n    \"\"\"\n\n    cap_info = self.captain_info()\n    return utils.is_true(cap_info[\"service_ready_flag\"]) and utils.is_false(\n        cap_info[\"maintenance_mode\"]\n    )\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_cloud_instance","title":"<code>is_cloud_instance()</code>","text":"<p>Check if this server is a cloud instance.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this server is a cloud instance else False.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>def is_cloud_instance(self) -&gt; bool:\n\"\"\"Check if this server is a cloud instance.\n\n    Returns:\n        True if this server is a cloud instance else False.\n    \"\"\"\n\n    try:\n        return self._server_info()[\"instance_type\"] == \"cloud\"\n    except KeyError:\n        return False\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_search_head","title":"<code>is_search_head()</code>","text":"<p>Check if this server is a search head.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this server is a search head else False.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>def is_search_head(self) -&gt; bool:\n\"\"\"Check if this server is a search head.\n\n    Returns:\n        True if this server is a search head else False.\n    \"\"\"\n\n    server_info = self._server_info()\n    for sh in (\"search_head\", \"cluster_search_head\"):\n        if sh in server_info[\"server_roles\"]:\n            return True\n\n    return False\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.is_shc_member","title":"<code>is_shc_member()</code>","text":"<p>Check if this server is a SHC member.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if this server is a SHC member else False.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>def is_shc_member(self) -&gt; bool:\n\"\"\"Check if this server is a SHC member.\n\n    Returns:\n        True if this server is a SHC member else False.\n    \"\"\"\n\n    server_info = self._server_info()\n    for sh in (\"shc_member\", \"shc_captain\"):\n        if sh in server_info[\"server_roles\"]:\n            return True\n\n    return False\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfo.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns server information in a form dictionary.</p> <p>Note: This method is implemented here to have compatibility with splunktalib\u2019s analogue.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Server information in a dictionary format.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n\"\"\"Returns server information in a form dictionary.\n\n    Note: This method is implemented here to have compatibility with splunktalib's\n    analogue.\n\n    Returns:\n        Server information in a dictionary format.\n    \"\"\"\n    return self._server_info()\n</code></pre>"},{"location":"server_info/#solnlib.server_info.ServerInfoException","title":"<code>ServerInfoException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception raised by ServerInfo class.</p> Source code in <code>solnlib/server_info.py</code> <pre><code>class ServerInfoException(Exception):\n\"\"\"Exception raised by ServerInfo class.\"\"\"\n\n    pass\n</code></pre>"},{"location":"server_info/#solnlib.server_info.getWebCertFile","title":"<code>getWebCertFile()</code>","text":"Source code in <code>solnlib/server_info.py</code> <pre><code>def getWebCertFile():\n    return None\n</code></pre>"},{"location":"server_info/#solnlib.server_info.getWebKeyFile","title":"<code>getWebKeyFile()</code>","text":"Source code in <code>solnlib/server_info.py</code> <pre><code>def getWebKeyFile():\n    return None\n</code></pre>"},{"location":"server_info/#solnlib.server_info.is_cert_or_key_encrypted","title":"<code>is_cert_or_key_encrypted(cert_filename)</code>","text":"Source code in <code>solnlib/server_info.py</code> <pre><code>def is_cert_or_key_encrypted(cert_filename):\n    return False\n</code></pre>"},{"location":"splunk_rest_client/","title":"splunk_rest_client.py","text":"<p>This module proxy all REST call to splunklib SDK, it handles proxy, certs etc in this centralized location.</p> <p>All clients should use SplunkRestProxy to do REST call instead of calling splunklib SDK directly in business logic code.</p>"},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.MAX_REQUEST_RETRIES","title":"<code>MAX_REQUEST_RETRIES = 5</code>  <code>module-attribute</code>","text":""},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.__all__","title":"<code>__all__ = ['SplunkRestClient']</code>  <code>module-attribute</code>","text":""},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.SplunkRestClient","title":"<code>SplunkRestClient</code>","text":"<p>         Bases: <code>client.Service</code></p> <p>Splunk REST client.</p> Source code in <code>solnlib/splunk_rest_client.py</code> <pre><code>class SplunkRestClient(client.Service):\n\"\"\"Splunk REST client.\"\"\"\n\n    def __init__(\n        self,\n        session_key: str,\n        app: str,\n        owner: str = \"nobody\",\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        **context: dict,\n    ):\n\"\"\"Initializes SplunkRestClient.\n\n        Arguments `scheme`, `host` and `port` are optional in the Splunk\n        environment (when environment variable SPLUNK_HOME is set). In this\n        situation `get_splunkd_access_info` will be used to set `scheme`,\n        `host` and `port`. In case of using `SplunkRestClient` outside of\n        Splunk environment - `scheme`, `host` and `port` should be provided.\n\n        Arguments:\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: Owner of namespace, default is `nobody`.\n            scheme: The access scheme, default is None.\n            host: The host name, default is None.\n            port: The port number, default is None.\n            context: Other configurations, it can contain `proxy_hostname`,\n                `proxy_port`, `proxy_username`, `proxy_password`, then proxy will\n                be accounted and setup, all REST APIs to splunkd will be through\n                the proxy. If `context` contains `key_file`, `cert_file`, then\n                certification will be accounted and setup, all REST APIs to splunkd\n                will use certification. If `context` contains `pool_connections`,\n                `pool_maxsize`, then HTTP connection will be pooled.\n\n        Raises:\n            ValueError: if scheme, host or port are invalid.\n        \"\"\"\n        # Only do splunkd URI discovery in SPLUNK env (SPLUNK_HOME is set).\n        if not all([scheme, host, port]) and os.environ.get(\"SPLUNK_HOME\"):\n            scheme, host, port = get_splunkd_access_info(session_key)\n        if os.environ.get(\"SPLUNK_HOME\") is None:\n            if not all([scheme, host, port]):\n                raise ValueError(\n                    \"scheme, host, port should be provided outside of Splunk environment\"\n                )\n\n        validate_scheme_host_port(scheme, host, port)\n        if host == \"[::1]\":\n            host = \"::1\"\n\n        handler = _request_handler(context)\n        super().__init__(\n            handler=handler,\n            scheme=scheme,\n            host=host,\n            port=port,\n            token=session_key,\n            app=app,\n            owner=owner,\n            autologin=True,\n        )\n</code></pre>"},{"location":"splunk_rest_client/#solnlib.splunk_rest_client.SplunkRestClient.__init__","title":"<code>__init__(session_key, app, owner='nobody', scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes SplunkRestClient.</p> <p>Arguments <code>scheme</code>, <code>host</code> and <code>port</code> are optional in the Splunk environment (when environment variable SPLUNK_HOME is set). In this situation <code>get_splunkd_access_info</code> will be used to set <code>scheme</code>, <code>host</code> and <code>port</code>. In case of using <code>SplunkRestClient</code> outside of Splunk environment - <code>scheme</code>, <code>host</code> and <code>port</code> should be provided.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>str</code> <p>Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>str</code> <p>The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations, it can contain <code>proxy_hostname</code>, <code>proxy_port</code>, <code>proxy_username</code>, <code>proxy_password</code>, then proxy will be accounted and setup, all REST APIs to splunkd will be through the proxy. If <code>context</code> contains <code>key_file</code>, <code>cert_file</code>, then certification will be accounted and setup, all REST APIs to splunkd will use certification. If <code>context</code> contains <code>pool_connections</code>, <code>pool_maxsize</code>, then HTTP connection will be pooled.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if scheme, host or port are invalid.</p> Source code in <code>solnlib/splunk_rest_client.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    app: str,\n    owner: str = \"nobody\",\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n):\n\"\"\"Initializes SplunkRestClient.\n\n    Arguments `scheme`, `host` and `port` are optional in the Splunk\n    environment (when environment variable SPLUNK_HOME is set). In this\n    situation `get_splunkd_access_info` will be used to set `scheme`,\n    `host` and `port`. In case of using `SplunkRestClient` outside of\n    Splunk environment - `scheme`, `host` and `port` should be provided.\n\n    Arguments:\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: Owner of namespace, default is `nobody`.\n        scheme: The access scheme, default is None.\n        host: The host name, default is None.\n        port: The port number, default is None.\n        context: Other configurations, it can contain `proxy_hostname`,\n            `proxy_port`, `proxy_username`, `proxy_password`, then proxy will\n            be accounted and setup, all REST APIs to splunkd will be through\n            the proxy. If `context` contains `key_file`, `cert_file`, then\n            certification will be accounted and setup, all REST APIs to splunkd\n            will use certification. If `context` contains `pool_connections`,\n            `pool_maxsize`, then HTTP connection will be pooled.\n\n    Raises:\n        ValueError: if scheme, host or port are invalid.\n    \"\"\"\n    # Only do splunkd URI discovery in SPLUNK env (SPLUNK_HOME is set).\n    if not all([scheme, host, port]) and os.environ.get(\"SPLUNK_HOME\"):\n        scheme, host, port = get_splunkd_access_info(session_key)\n    if os.environ.get(\"SPLUNK_HOME\") is None:\n        if not all([scheme, host, port]):\n            raise ValueError(\n                \"scheme, host, port should be provided outside of Splunk environment\"\n            )\n\n    validate_scheme_host_port(scheme, host, port)\n    if host == \"[::1]\":\n        host = \"::1\"\n\n    handler = _request_handler(context)\n    super().__init__(\n        handler=handler,\n        scheme=scheme,\n        host=host,\n        port=port,\n        token=session_key,\n        app=app,\n        owner=owner,\n        autologin=True,\n    )\n</code></pre>"},{"location":"splunkenv/","title":"splunkenv.py","text":"<p>Splunk platform related utilities.</p>"},{"location":"splunkenv/#solnlib.splunkenv.APP_HEC","title":"<code>APP_HEC = 'splunk_httpinput'</code>  <code>module-attribute</code>","text":""},{"location":"splunkenv/#solnlib.splunkenv.APP_SYSTEM","title":"<code>APP_SYSTEM = 'system'</code>  <code>module-attribute</code>","text":""},{"location":"splunkenv/#solnlib.splunkenv.ETC_LEAF","title":"<code>ETC_LEAF = 'etc'</code>  <code>module-attribute</code>","text":""},{"location":"splunkenv/#solnlib.splunkenv.__all__","title":"<code>__all__ = ['make_splunkhome_path', 'get_splunk_host_info', 'get_splunk_bin', 'get_splunkd_access_info', 'get_scheme_from_hec_settings', 'get_splunkd_uri', 'get_conf_key_value', 'get_conf_stanza', 'get_conf_stanzas']</code>  <code>module-attribute</code>","text":""},{"location":"splunkenv/#solnlib.splunkenv.SessionKeyNotFound","title":"<code>SessionKeyNotFound</code>","text":"<p>         Bases: <code>Exception</code></p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>class SessionKeyNotFound(Exception):\n    pass\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.getSessionKey","title":"<code>getSessionKey(*args, **kwargs)</code>","text":"Source code in <code>solnlib/splunkenv.py</code> <pre><code>def getSessionKey(*args, **kwargs):\n    raise ImportError(\"This module requires Splunk to be installed.\")\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_conf_key_value","title":"<code>get_conf_key_value(conf_name, stanza, key, app_name, session_key=None, user='nobody', raw_output=False)</code>","text":"<p>Get value of <code>key</code> of <code>stanza</code> in <code>conf_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>conf_name</code> <code>str</code> <p>Config file.</p> required <code>stanza</code> <code>str</code> <p>Stanza name.</p> required <code>key</code> <code>str</code> <p>Key name in the stanza.</p> required <code>app_name</code> <code>str</code> <p>Application name. To make a call to global context use \u2018-\u2019 as app_name and set raw_output=True. In that case manual parsing is needed as response may be the list with multiple entries.</p> required <code>session_key</code> <code>Optional[str]</code> <p>Needed to make a call to config endpoint. If \u2018None\u2019, solnlib will try to get it from splunk.getSessionKey() and/or main module and if it won\u2019t get it, SessionKeyNotFound will be raised.</p> <code>None</code> <code>user</code> <code>str</code> <p>used for set user context in API call. Optional.</p> <code>'nobody'</code> <code>raw_output</code> <code>Optional[bool]</code> <p>if \u2018true\u2019 full, decoded response in json format will be returned. It should be set to True when app_name is a global context \u2018/-/\u2019. In that case splunk API may return multiple entries.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[str, List, dict]</code> <p>Config value.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>stanza</code> or <code>key</code> doesn\u2019t exist.</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_conf_key_value(\n    conf_name: str,\n    stanza: str,\n    key: str,\n    app_name: str,\n    session_key: Optional[str] = None,\n    user: str = \"nobody\",\n    raw_output: Optional[bool] = False,\n) -&gt; Union[str, List, dict]:\n\"\"\"Get value of `key` of `stanza` in `conf_name`.\n\n    Arguments:\n        conf_name: Config file.\n        stanza: Stanza name.\n        key: Key name in the stanza.\n        app_name: Application name. To make a call to global context use '-' as app_name and set raw_output=True.\n            In that case manual parsing is needed as response may be the list with multiple entries.\n        session_key: Needed to make a call to config endpoint. If 'None', solnlib will try to get it from\n            splunk.getSessionKey() and/or __main__ module and if it won't get it, SessionKeyNotFound will be raised.\n        user: used for set user context in API call. Optional.\n        raw_output: if 'true' full, decoded response in json format will be returned. It should be set to True when\n            app_name is a global context '/-/'. In that case splunk API may return multiple entries.\n\n    Returns:\n        Config value.\n\n    Raises:\n        KeyError: If `stanza` or `key` doesn't exist.\n    \"\"\"\n\n    if use_btool:\n        app = None if app_name == \"-\" else app_name\n        stanzas = get_conf_stanzas(conf_name, app)\n        return stanzas[stanza][key]\n\n    stanzas = _get_conf_stanzas_from_splunk_api(\n        conf_name, app_name, session_key=session_key, user=user, stanza=stanza\n    )\n\n    if raw_output:\n        return stanzas\n\n    stanza = stanzas.get(\"entry\")[0].get(\"content\")\n    requested_key = stanza[key]\n    return requested_key\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_conf_stanza","title":"<code>get_conf_stanza(conf_name, stanza, app_name, session_key=None, user='nobody', raw_output=False)</code>","text":"<p>Get <code>stanza</code> in <code>conf_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>conf_name</code> <code>str</code> <p>Config file.</p> required <code>stanza</code> <code>str</code> <p>Stanza name.</p> required <code>app_name</code> <code>str</code> <p>Application name. To make a call to global context use \u2018-\u2019 as app_name and set raw_output=True. In that case manual parsing is needed as response may be the list with multiple entries.</p> required <code>session_key</code> <code>Optional[str]</code> <p>Needed to make a call to config endpoint. If \u2018None\u2019, solnlib will try to get it from splunk.getSessionKey() and/or main module and if it won\u2019t get it, SessionKeyNotFound will be raised.</p> <code>None</code> <code>user</code> <code>str</code> <p>used for set user context in API call. Optional.</p> <code>'nobody'</code> <code>raw_output</code> <code>Optional[bool]</code> <p>if \u2018true\u2019 full, decoded response in json format will be returned. It should be set to True when app_name is a global context \u2018/-/\u2019. In that case splunk API may return multiple entries.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Config stanza.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If stanza doesn\u2019t exist.</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_conf_stanza(\n    conf_name: str,\n    stanza: str,\n    app_name: str,\n    session_key: Optional[str] = None,\n    user: str = \"nobody\",\n    raw_output: Optional[bool] = False,\n) -&gt; dict:\n\"\"\"Get `stanza` in `conf_name`.\n\n    Arguments:\n        conf_name: Config file.\n        stanza: Stanza name.\n        app_name: Application name. To make a call to global context use '-' as app_name and set raw_output=True.\n            In that case manual parsing is needed as response may be the list with multiple entries.\n        session_key: Needed to make a call to config endpoint. If 'None', solnlib will try to get it from\n            splunk.getSessionKey() and/or __main__ module and if it won't get it, SessionKeyNotFound will be raised.\n        user: used for set user context in API call. Optional.\n        raw_output: if 'true' full, decoded response in json format will be returned. It should be set to True when\n            app_name is a global context '/-/'. In that case splunk API may return multiple entries.\n\n    Returns:\n        Config stanza.\n\n    Raises:\n         KeyError: If stanza doesn't exist.\n    \"\"\"\n\n    if use_btool:\n        app = None if app_name == \"-\" else app_name\n        stanzas = get_conf_stanzas(conf_name, app)\n        return stanzas[stanza]\n\n    stanzas = _get_conf_stanzas_from_splunk_api(\n        conf_name, app_name, session_key=session_key, user=user, stanza=stanza\n    )\n\n    if raw_output:\n        return stanzas\n\n    stanza = stanzas.get(\"entry\")[0].get(\"content\")\n    return stanza\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_conf_stanzas","title":"<code>get_conf_stanzas(conf_name, app_name=None)</code>","text":"<p>Get stanzas of <code>conf_name</code></p> <p>Parameters:</p> Name Type Description Default <code>conf_name</code> <code>str</code> <p>Config file.</p> required <code>app_name</code> <code>Optional[str]</code> <p>Application name. Optional.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Config stanzas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stanzas = get_conf_stanzas('server')\n&gt;&gt;&gt; return: {'serverName': 'testServer', 'sessionTimeout': '1h', ...}\n</code></pre> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_conf_stanzas(conf_name: str, app_name: Optional[str] = None) -&gt; dict:\n\"\"\"Get stanzas of `conf_name`\n\n    Arguments:\n        conf_name: Config file.\n        app_name: Application name. Optional.\n\n    Returns:\n        Config stanzas.\n\n    Examples:\n       &gt;&gt;&gt; stanzas = get_conf_stanzas('server')\n       &gt;&gt;&gt; return: {'serverName': 'testServer', 'sessionTimeout': '1h', ...}\n    \"\"\"\n\n    if conf_name.endswith(\".conf\"):\n        conf_name = conf_name[:-5]\n\n    # TODO: dynamically calculate SPLUNK_HOME\n    btool_cli = [\n        op.join(os.environ[\"SPLUNK_HOME\"], \"bin\", \"splunk\"),\n        \"cmd\",\n        \"btool\",\n        conf_name,\n        \"list\",\n    ]\n\n    if app_name:\n        btool_cli.append(f\"--app={app_name}\")\n\n    p = subprocess.Popen(  # nosemgrep: python.lang.security.audit.dangerous-subprocess-use.dangerous-subprocess-use\n        btool_cli, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n    )\n    out, _ = p.communicate()\n\n    if isinstance(out, bytes):\n        out = out.decode()\n\n    parser = ConfigParser(**{\"strict\": False})\n    parser.optionxform = str\n    parser.read_file(StringIO(out))\n\n    out = {}\n    for section in parser.sections():\n        out[section] = {item[0]: item[1] for item in parser.items(section, raw=True)}\n    return out\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_scheme_from_hec_settings","title":"<code>get_scheme_from_hec_settings(session_key=None)</code>","text":"<p>Get scheme from HEC global settings.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>Optional[str]</code> <p>Needed to make a call to config endpoint. If \u2018None\u2019, solnlib will try to get it from splunk.getSessionKey() and/or main module and if it won\u2019t get it, SessionKeyNotFound will be raised.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>scheme (str)</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_scheme_from_hec_settings(session_key: Optional[str] = None) -&gt; str:\n\"\"\"Get scheme from HEC global settings.\n\n    Arguments:\n        session_key: Needed to make a call to config endpoint. If 'None', solnlib will try to get it from\n            splunk.getSessionKey() and/or __main__ module and if it won't get it, SessionKeyNotFound will be raised.\n    Returns:\n        scheme (str)\n    \"\"\"\n    try:\n        ssl_enabled = get_conf_key_value(\n            \"inputs\",\n            \"http\",\n            \"enableSSL\",\n            APP_HEC,\n            session_key=session_key,\n        )\n    except KeyError:\n        raise KeyError(\n            \"Cannot get enableSSL setting form conf: 'inputs' and stanza: '[http]'. \"\n            \"Verify that your Splunk instance has the inputs.conf file with the correct [http] stanza. \"\n            \"For more information see: \"\n            \"https://docs.splunk.com/Documentation/Splunk/9.2.0/Data/UseHECusingconffiles\"\n        )\n\n    if is_true(ssl_enabled):\n        scheme = \"https\"\n    else:\n        scheme = \"http\"\n\n    return scheme\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_splunk_bin","title":"<code>get_splunk_bin()</code>","text":"<p>Get absolute path of splunk CLI.</p> <p>Returns:</p> Type Description <code>str</code> <p>Absolute path of splunk CLI.</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_splunk_bin() -&gt; str:\n\"\"\"Get absolute path of splunk CLI.\n\n    Returns:\n        Absolute path of splunk CLI.\n    \"\"\"\n\n    if os.name == \"nt\":\n        splunk_bin = \"splunk.exe\"\n    else:\n        splunk_bin = \"splunk\"\n    return make_splunkhome_path((\"bin\", splunk_bin))\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_splunk_host_info","title":"<code>get_splunk_host_info(session_key=None)</code>","text":"<p>Get splunk host info.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>Optional[str]</code> <p>Needed to make a call to config endpoint. If \u2018None\u2019, solnlib will try to get it from splunk.getSessionKey() and/or main module and if it won\u2019t get it, SessionKeyNotFound will be raised.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple</code> <p>Tuple of (server_name, host_name).</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_splunk_host_info(session_key: Optional[str] = None) -&gt; Tuple:\n\"\"\"Get splunk host info.\n\n    Arguments:\n        session_key: Needed to make a call to config endpoint. If 'None', solnlib will try to get it from\n            splunk.getSessionKey() and/or __main__ module and if it won't get it, SessionKeyNotFound will be raised.\n    Returns:\n        Tuple of (server_name, host_name).\n    \"\"\"\n\n    server_name = get_conf_key_value(\n        \"server\",\n        \"general\",\n        \"serverName\",\n        APP_SYSTEM,\n        session_key=session_key,\n    )\n    host_name = socket.gethostname()\n\n    return server_name, host_name\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_splunkd_access_info","title":"<code>get_splunkd_access_info(session_key=None)</code>","text":"<p>Get splunkd server access info.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>Optional[str]</code> <p>Needed to make a call to config endpoint. If \u2018None\u2019, solnlib will try to get it from splunk.getSessionKey() and/or main module and if it won\u2019t get it, SessionKeyNotFound will be raised.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[str, str, int]</code> <p>Tuple of (scheme, host, port).</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_splunkd_access_info(session_key: Optional[str] = None) -&gt; Tuple[str, str, int]:\n\"\"\"Get splunkd server access info.\n\n    Arguments:\n        session_key: Needed to make a call to config endpoint. If 'None', solnlib will try to get it from\n            splunk.getSessionKey() and/or __main__ module and if it won't get it, SessionKeyNotFound will be raised.\n    Returns:\n        Tuple of (scheme, host, port).\n    \"\"\"\n    enable_splunkd_ssl = get_conf_key_value(\n        \"server\",\n        \"sslConfig\",\n        \"enableSplunkdSSL\",\n        APP_SYSTEM,\n        session_key=session_key,\n    )\n\n    if is_true(enable_splunkd_ssl):\n        scheme = \"https\"\n    else:\n        scheme = \"http\"\n\n    host_port = get_conf_key_value(\n        \"web\",\n        \"settings\",\n        \"mgmtHostPort\",\n        APP_SYSTEM,\n        session_key=session_key,\n    )\n    host_port = host_port.strip()\n    host_port_split_parts = host_port.split(\":\")\n    host = \":\".join(host_port_split_parts[:-1])\n    port = int(host_port_split_parts[-1])\n\n    if \"SPLUNK_BINDIP\" in os.environ:\n        bindip = os.environ[\"SPLUNK_BINDIP\"]\n        port_idx = bindip.rfind(\":\")\n        host = bindip[:port_idx] if port_idx &gt; 0 else bindip\n\n    return scheme, host, port\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.get_splunkd_uri","title":"<code>get_splunkd_uri(session_key=None)</code>","text":"<p>Get splunkd uri.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>Optional[str]</code> <p>Needed to make a call to config endpoint. If \u2018None\u2019, solnlib will try to get it from splunk.getSessionKey() and/or main module and if it won\u2019t get it, SessionKeyNotFound will be raised.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Splunkd uri.</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def get_splunkd_uri(session_key: Optional[str] = None) -&gt; str:\n\"\"\"Get splunkd uri.\n\n    Arguments:\n        session_key: Needed to make a call to config endpoint. If 'None', solnlib will try to get it from\n            splunk.getSessionKey() and/or __main__ module and if it won't get it, SessionKeyNotFound will be raised.\n    Returns:\n        Splunkd uri.\n    \"\"\"\n\n    if os.environ.get(\"SPLUNKD_URI\"):\n        return os.environ[\"SPLUNKD_URI\"]\n\n    scheme, host, port = get_splunkd_access_info(session_key)\n    return f\"{scheme}://{host}:{port}\"\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.make_splunkhome_path","title":"<code>make_splunkhome_path(parts)</code>","text":"<p>Construct absolute path by $SPLUNK_HOME and <code>parts</code>.</p> <p>Concatenate $SPLUNK_HOME and <code>parts</code> to an absolute path. For example, <code>parts</code> is [\u2018etc\u2019, \u2018apps\u2019, \u2018Splunk_TA_test\u2019], the return path will be $SPLUNK_HOME/etc/apps/Splunk_TA_test. Note: this function assumed SPLUNK_HOME is in environment varialbes.</p> <p>Parameters:</p> Name Type Description Default <code>parts</code> <code>Union[List, Tuple]</code> <p>Path parts.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Absolute path.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Escape from intended parent directories.</p> Source code in <code>solnlib/splunkenv.py</code> <pre><code>def make_splunkhome_path(parts: Union[List, Tuple]) -&gt; str:\n\"\"\"Construct absolute path by $SPLUNK_HOME and `parts`.\n\n    Concatenate $SPLUNK_HOME and `parts` to an absolute path.\n    For example, `parts` is ['etc', 'apps', 'Splunk_TA_test'],\n    the return path will be $SPLUNK_HOME/etc/apps/Splunk_TA_test.\n    Note: this function assumed SPLUNK_HOME is in environment varialbes.\n\n    Arguments:\n        parts: Path parts.\n\n    Returns:\n        Absolute path.\n\n    Raises:\n        ValueError: Escape from intended parent directories.\n    \"\"\"\n    return msp(parts)\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.msp","title":"<code>msp(*args, **kwargs)</code>","text":"Source code in <code>solnlib/splunkenv.py</code> <pre><code>def msp(*args, **kwargs):\n    raise ImportError(\"This module requires Splunk to be installed.\")\n</code></pre>"},{"location":"splunkenv/#solnlib.splunkenv.simpleRequest","title":"<code>simpleRequest(*args, **kwargs)</code>","text":"Source code in <code>solnlib/splunkenv.py</code> <pre><code>def simpleRequest(*args, **kwargs):\n    raise ImportError(\"This module requires Splunk to be installed.\")\n</code></pre>"},{"location":"time_parser/","title":"time_parser.py","text":"<p>This module provides interfaces to parse and convert timestamp.</p>"},{"location":"time_parser/#solnlib.time_parser.__all__","title":"<code>__all__ = ['TimeParser']</code>  <code>module-attribute</code>","text":""},{"location":"time_parser/#solnlib.time_parser.InvalidTimeFormatException","title":"<code>InvalidTimeFormatException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for invalid time format.</p> Source code in <code>solnlib/time_parser.py</code> <pre><code>class InvalidTimeFormatException(Exception):\n\"\"\"Exception for invalid time format.\"\"\"\n\n    pass\n</code></pre>"},{"location":"time_parser/#solnlib.time_parser.TimeParser","title":"<code>TimeParser</code>","text":"<p>Datetime parser.</p> <p>Use splunkd rest to parse datetime.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import time_parser\n&gt;&gt;&gt; tp = time_parser.TimeParser(session_key)\n&gt;&gt;&gt; tp.to_seconds('2011-07-06T21:54:23.000-07:00')\n&gt;&gt;&gt; tp.to_utc('2011-07-06T21:54:23.000-07:00')\n&gt;&gt;&gt; tp.to_local('2011-07-06T21:54:23.000-07:00')\n</code></pre> Source code in <code>solnlib/time_parser.py</code> <pre><code>class TimeParser:\n\"\"\"Datetime parser.\n\n    Use splunkd rest to parse datetime.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import time_parser\n       &gt;&gt;&gt; tp = time_parser.TimeParser(session_key)\n       &gt;&gt;&gt; tp.to_seconds('2011-07-06T21:54:23.000-07:00')\n       &gt;&gt;&gt; tp.to_utc('2011-07-06T21:54:23.000-07:00')\n       &gt;&gt;&gt; tp.to_local('2011-07-06T21:54:23.000-07:00')\n    \"\"\"\n\n    URL = \"/services/search/timeparser\"\n\n    def __init__(\n        self,\n        session_key: str,\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        **context: Any,\n    ):\n\"\"\"Initializes TimeParser.\n\n        Arguments:\n            session_key: Splunk access token.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n\n        Raises:\n            ValueError: if scheme, host or port are invalid.\n        \"\"\"\n        self._rest_client = rest_client.SplunkRestClient(\n            session_key, \"-\", scheme=scheme, host=host, port=port, **context\n        )\n\n    @retry(exceptions=[binding.HTTPError])\n    def to_seconds(self, time_str: str) -&gt; float:\n\"\"\"Parse `time_str` and convert to seconds since epoch.\n\n        Arguments:\n            time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.\n\n        Raises:\n            binding.HTTPError: rest client returns an exception (everything\n                else than 400 code).\n            InvalidTimeFormatException: when time format is invalid (rest\n                client returns 400 code).\n\n        Returns:\n            Seconds since epoch.\n        \"\"\"\n\n        try:\n            response = self._rest_client.get(\n                self.URL, output_mode=\"json\", time=time_str, output_time_format=\"%s\"\n            ).body.read()\n        except binding.HTTPError as e:\n            if e.status != 400:\n                raise\n\n            raise InvalidTimeFormatException(f\"Invalid time format: {time_str}.\")\n\n        seconds = json.loads(response)[time_str]\n        return float(seconds)\n\n    def to_utc(self, time_str: str) -&gt; datetime.datetime:\n\"\"\"Parse `time_str` and convert to UTC timestamp.\n\n        Arguments:\n            time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.\n\n        Raises:\n            binding.HTTPError: rest client returns an exception (everything\n                else than 400 code).\n            InvalidTimeFormatException: when time format is invalid (rest\n                client returns 400 code).\n\n        Returns:\n            UTC timestamp.\n        \"\"\"\n\n        return datetime.datetime.utcfromtimestamp(self.to_seconds(time_str))\n\n    @retry(exceptions=[binding.HTTPError])\n    def to_local(self, time_str: str) -&gt; str:\n\"\"\"Parse `time_str` and convert to local timestamp.\n\n        Arguments:\n            time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.\n\n        Raises:\n            binding.HTTPError: rest client returns an exception (everything\n                else than 400 code).\n            InvalidTimeFormatException: when time format is invalid (rest\n                client returns 400 code).\n\n        Returns:\n            Local timestamp in ISO8601 format.\n        \"\"\"\n\n        try:\n            response = self._rest_client.get(\n                self.URL, output_mode=\"json\", time=time_str\n            ).body.read()\n        except binding.HTTPError as e:\n            if e.status != 400:\n                raise\n\n            raise InvalidTimeFormatException(f\"Invalid time format: {time_str}.\")\n\n        return json.loads(response)[time_str]\n</code></pre>"},{"location":"time_parser/#solnlib.time_parser.TimeParser.URL","title":"<code>URL = '/services/search/timeparser'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"time_parser/#solnlib.time_parser.TimeParser.__init__","title":"<code>__init__(session_key, scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes TimeParser.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>Any</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if scheme, host or port are invalid.</p> Source code in <code>solnlib/time_parser.py</code> <pre><code>def __init__(\n    self,\n    session_key: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: Any,\n):\n\"\"\"Initializes TimeParser.\n\n    Arguments:\n        session_key: Splunk access token.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Raises:\n        ValueError: if scheme, host or port are invalid.\n    \"\"\"\n    self._rest_client = rest_client.SplunkRestClient(\n        session_key, \"-\", scheme=scheme, host=host, port=port, **context\n    )\n</code></pre>"},{"location":"time_parser/#solnlib.time_parser.TimeParser.to_local","title":"<code>to_local(time_str)</code>","text":"<p>Parse <code>time_str</code> and convert to local timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>time_str</code> <code>str</code> <p>ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>rest client returns an exception (everything else than 400 code).</p> <code>InvalidTimeFormatException</code> <p>when time format is invalid (rest client returns 400 code).</p> <p>Returns:</p> Type Description <code>str</code> <p>Local timestamp in ISO8601 format.</p> Source code in <code>solnlib/time_parser.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef to_local(self, time_str: str) -&gt; str:\n\"\"\"Parse `time_str` and convert to local timestamp.\n\n    Arguments:\n        time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.\n\n    Raises:\n        binding.HTTPError: rest client returns an exception (everything\n            else than 400 code).\n        InvalidTimeFormatException: when time format is invalid (rest\n            client returns 400 code).\n\n    Returns:\n        Local timestamp in ISO8601 format.\n    \"\"\"\n\n    try:\n        response = self._rest_client.get(\n            self.URL, output_mode=\"json\", time=time_str\n        ).body.read()\n    except binding.HTTPError as e:\n        if e.status != 400:\n            raise\n\n        raise InvalidTimeFormatException(f\"Invalid time format: {time_str}.\")\n\n    return json.loads(response)[time_str]\n</code></pre>"},{"location":"time_parser/#solnlib.time_parser.TimeParser.to_seconds","title":"<code>to_seconds(time_str)</code>","text":"<p>Parse <code>time_str</code> and convert to seconds since epoch.</p> <p>Parameters:</p> Name Type Description Default <code>time_str</code> <code>str</code> <p>ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>rest client returns an exception (everything else than 400 code).</p> <code>InvalidTimeFormatException</code> <p>when time format is invalid (rest client returns 400 code).</p> <p>Returns:</p> Type Description <code>float</code> <p>Seconds since epoch.</p> Source code in <code>solnlib/time_parser.py</code> <pre><code>@retry(exceptions=[binding.HTTPError])\ndef to_seconds(self, time_str: str) -&gt; float:\n\"\"\"Parse `time_str` and convert to seconds since epoch.\n\n    Arguments:\n        time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.\n\n    Raises:\n        binding.HTTPError: rest client returns an exception (everything\n            else than 400 code).\n        InvalidTimeFormatException: when time format is invalid (rest\n            client returns 400 code).\n\n    Returns:\n        Seconds since epoch.\n    \"\"\"\n\n    try:\n        response = self._rest_client.get(\n            self.URL, output_mode=\"json\", time=time_str, output_time_format=\"%s\"\n        ).body.read()\n    except binding.HTTPError as e:\n        if e.status != 400:\n            raise\n\n        raise InvalidTimeFormatException(f\"Invalid time format: {time_str}.\")\n\n    seconds = json.loads(response)[time_str]\n    return float(seconds)\n</code></pre>"},{"location":"time_parser/#solnlib.time_parser.TimeParser.to_utc","title":"<code>to_utc(time_str)</code>","text":"<p>Parse <code>time_str</code> and convert to UTC timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>time_str</code> <code>str</code> <p>ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>rest client returns an exception (everything else than 400 code).</p> <code>InvalidTimeFormatException</code> <p>when time format is invalid (rest client returns 400 code).</p> <p>Returns:</p> Type Description <code>datetime.datetime</code> <p>UTC timestamp.</p> Source code in <code>solnlib/time_parser.py</code> <pre><code>def to_utc(self, time_str: str) -&gt; datetime.datetime:\n\"\"\"Parse `time_str` and convert to UTC timestamp.\n\n    Arguments:\n        time_str: ISO8601 format timestamp, example: 2011-07-06T21:54:23.000-07:00.\n\n    Raises:\n        binding.HTTPError: rest client returns an exception (everything\n            else than 400 code).\n        InvalidTimeFormatException: when time format is invalid (rest\n            client returns 400 code).\n\n    Returns:\n        UTC timestamp.\n    \"\"\"\n\n    return datetime.datetime.utcfromtimestamp(self.to_seconds(time_str))\n</code></pre>"},{"location":"timer_queue/","title":"timer_queue.py","text":"<p>A simple thread safe timer queue implementation which has O(logn) time complexity.</p>"},{"location":"timer_queue/#solnlib.timer_queue.TEARDOWN_SENTINEL","title":"<code>TEARDOWN_SENTINEL = None</code>  <code>module-attribute</code>","text":""},{"location":"timer_queue/#solnlib.timer_queue.__all__","title":"<code>__all__ = ['Timer', 'TimerQueueStruct', 'TimerQueue']</code>  <code>module-attribute</code>","text":""},{"location":"timer_queue/#solnlib.timer_queue.Timer","title":"<code>Timer</code>","text":"<p>Timer wraps the callback and timestamp related attributes.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>class Timer:\n\"\"\"Timer wraps the callback and timestamp related attributes.\"\"\"\n\n    _ident = 0\n    _lock = threading.Lock()\n\n    def __init__(self, callback: Callable, when: int, interval: int, ident: int = None):\n\"\"\"Initializes Timer.\n\n        Arguments:\n            callback: Arbitrary callable object.\n            when: The first expiration time, seconds since epoch.\n            interval: Timer interval, if equals 0, one time timer, otherwise\n                the timer will be periodically executed.\n            ident: (optional) Timer identity.\n        \"\"\"\n        self._callback = callback\n        self.when = when\n        self.interval = interval\n\n        if ident is not None:\n            self.ident = ident\n        else:\n            with Timer._lock:\n                self.ident = Timer._ident + 1\n                Timer._ident = Timer._ident + 1\n\n    def update_expiration(self):\n        self.when += self.interval\n\n    def __hash__(self):\n        return hash(self.ident)\n\n    def __eq__(self, other):\n        return isinstance(other, Timer) and (self.ident == other.ident)\n\n    def __lt__(self, other):\n        return (self.when, self.ident) &lt; (other.when, other.ident)\n\n    def __le__(self, other):\n        return (self.when, self.ident) &lt;= (other.when, other.ident)\n\n    def __gt__(self, other):\n        return (self.when, self.ident) &gt; (other.when, other.ident)\n\n    def __ge__(self, other):\n        return (self.when, self.ident) &gt;= (other.when, other.ident)\n\n    def __call__(self):\n        self._callback()\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.ident","title":"<code>ident = Timer._ident + 1</code>  <code>instance-attribute</code>","text":""},{"location":"timer_queue/#solnlib.timer_queue.Timer.interval","title":"<code>interval = interval</code>  <code>instance-attribute</code>","text":""},{"location":"timer_queue/#solnlib.timer_queue.Timer.when","title":"<code>when = when</code>  <code>instance-attribute</code>","text":""},{"location":"timer_queue/#solnlib.timer_queue.Timer.__call__","title":"<code>__call__()</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __call__(self):\n    self._callback()\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __eq__(self, other):\n    return isinstance(other, Timer) and (self.ident == other.ident)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__ge__","title":"<code>__ge__(other)</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __ge__(self, other):\n    return (self.when, self.ident) &gt;= (other.when, other.ident)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__gt__","title":"<code>__gt__(other)</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __gt__(self, other):\n    return (self.when, self.ident) &gt; (other.when, other.ident)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __hash__(self):\n    return hash(self.ident)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__init__","title":"<code>__init__(callback, when, interval, ident=None)</code>","text":"<p>Initializes Timer.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Arbitrary callable object.</p> required <code>when</code> <code>int</code> <p>The first expiration time, seconds since epoch.</p> required <code>interval</code> <code>int</code> <p>Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed.</p> required <code>ident</code> <code>int</code> <p>(optional) Timer identity.</p> <code>None</code> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __init__(self, callback: Callable, when: int, interval: int, ident: int = None):\n\"\"\"Initializes Timer.\n\n    Arguments:\n        callback: Arbitrary callable object.\n        when: The first expiration time, seconds since epoch.\n        interval: Timer interval, if equals 0, one time timer, otherwise\n            the timer will be periodically executed.\n        ident: (optional) Timer identity.\n    \"\"\"\n    self._callback = callback\n    self.when = when\n    self.interval = interval\n\n    if ident is not None:\n        self.ident = ident\n    else:\n        with Timer._lock:\n            self.ident = Timer._ident + 1\n            Timer._ident = Timer._ident + 1\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__le__","title":"<code>__le__(other)</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __le__(self, other):\n    return (self.when, self.ident) &lt;= (other.when, other.ident)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.__lt__","title":"<code>__lt__(other)</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __lt__(self, other):\n    return (self.when, self.ident) &lt; (other.when, other.ident)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.Timer.update_expiration","title":"<code>update_expiration()</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def update_expiration(self):\n    self.when += self.interval\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue","title":"<code>TimerQueue</code>","text":"<p>A simple timer queue implementation.</p> <p>It runs a separate thread to handle timers Note: to effectively use this timer queue, the timer callback should be short, otherwise it will cause other timers\u2019s delay execution. A typical use scenario in production is that the timers are just a simple functions which inject themselvies to a task queue and then they are picked up by a threading/process pool to execute, as shows below:</p> <pre><code>Timers --enqueue---&gt; TimerQueue --------expiration-----------\n|\n|\n\\|/\nThreading/Process Pool &lt;---- TaskQueue &lt;--enqueue-- Timers' callback (nonblocking)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import timer_queue\n&gt;&gt;&gt; tq = timer_queue.TimerQueue()\n&gt;&gt;&gt; tq.start()\n&gt;&gt;&gt; t = tq.add_timer(my_func, time.time(), 10)\n&gt;&gt;&gt; # do other stuff\n&gt;&gt;&gt; tq.stop()\n</code></pre> Source code in <code>solnlib/timer_queue.py</code> <pre><code>class TimerQueue:\nr\"\"\"A simple timer queue implementation.\n\n    It runs a separate thread to handle timers Note: to effectively use this\n    timer queue, the timer callback should be short, otherwise it will cause\n    other timers's delay execution. A typical use scenario in production is\n    that the timers are just a simple functions which inject themselvies to\n    a task queue and then they are picked up by a threading/process pool to\n    execute, as shows below:\n\n        Timers --enqueue---&gt; TimerQueue --------expiration-----------\n                                                                    |\n                                                                    |\n                                                                   \\|/\n        Threading/Process Pool &lt;---- TaskQueue &lt;--enqueue-- Timers' callback (nonblocking)\n\n    Examples:\n           &gt;&gt;&gt; from solnlib import timer_queue\n           &gt;&gt;&gt; tq = timer_queue.TimerQueue()\n           &gt;&gt;&gt; tq.start()\n           &gt;&gt;&gt; t = tq.add_timer(my_func, time.time(), 10)\n           &gt;&gt;&gt; # do other stuff\n           &gt;&gt;&gt; tq.stop()\n    \"\"\"\n\n    def __init__(self):\n        self._timers = TimerQueueStruct()\n        self._lock = threading.Lock()\n        self._wakeup_queue = Queue.Queue()\n        self._thr = threading.Thread(target=self._check_and_execute)\n        self._thr.daemon = True\n        self._started = False\n\n    def start(self):\n\"\"\"Start the timer queue.\"\"\"\n\n        if self._started:\n            return\n        self._started = True\n\n        self._thr.start()\n        logging.info(\"TimerQueue started.\")\n\n    def stop(self):\n\"\"\"Stop the timer queue.\"\"\"\n\n        if not self._started:\n            return\n        self._started = True\n\n        self._wakeup(TEARDOWN_SENTINEL)\n        self._thr.join()\n\n    def add_timer(\n        self, callback: Callable, when: int, interval: int, ident: int = None\n    ) -&gt; Timer:\n\"\"\"Add timer to the queue.\n\n        Arguments:\n            callback: Arbitrary callable object.\n            when: The first expiration time, seconds since epoch.\n            interval: Timer interval, if equals 0, one time timer, otherwise\n                the timer will be periodically executed\n            ident: (optional) Timer identity.\n\n        Returns:\n            A timer object which should not be manipulated directly by\n                clients. Used to delete/update the timer.\n        \"\"\"\n\n        with self._lock:\n            timer = self._timers.add_timer(callback, when, interval, ident)\n        self._wakeup()\n        return timer\n\n    def remove_timer(self, timer: Timer):\n\"\"\"Remove timer from the queue.\n\n        Arguments:\n            timer: Timer object to remove.\n        \"\"\"\n\n        with self._lock:\n            self._timers.remove_timer(timer)\n\n    def _check_and_execute(self):\n        wakeup_queue = self._wakeup_queue\n        while 1:\n            (next_expired_time, expired_timers) = self._get_expired_timers()\n            for timer in expired_timers:\n                try:\n                    # Note, please make timer callback effective/short\n                    timer()\n                except Exception:\n                    logging.error(traceback.format_exc())\n\n            self._reset_timers(expired_timers)\n\n            sleep_time = _calc_sleep_time(next_expired_time)\n            try:\n                wakeup = wakeup_queue.get(timeout=sleep_time)\n                if wakeup is TEARDOWN_SENTINEL:\n                    break\n            except Queue.Empty:\n                pass\n        logging.info(\"TimerQueue stopped.\")\n\n    def _get_expired_timers(self):\n        with self._lock:\n            return self._timers.get_expired_timers()\n\n    def _reset_timers(self, expired_timers):\n        with self._lock:\n            has_new_timer = self._timers.reset_timers(expired_timers)\n\n        if has_new_timer:\n            self._wakeup()\n\n    def _wakeup(self, something=\"not_None\"):\n        self._wakeup_queue.put(something)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.__init__","title":"<code>__init__()</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __init__(self):\n    self._timers = TimerQueueStruct()\n    self._lock = threading.Lock()\n    self._wakeup_queue = Queue.Queue()\n    self._thr = threading.Thread(target=self._check_and_execute)\n    self._thr.daemon = True\n    self._started = False\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.add_timer","title":"<code>add_timer(callback, when, interval, ident=None)</code>","text":"<p>Add timer to the queue.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Arbitrary callable object.</p> required <code>when</code> <code>int</code> <p>The first expiration time, seconds since epoch.</p> required <code>interval</code> <code>int</code> <p>Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed</p> required <code>ident</code> <code>int</code> <p>(optional) Timer identity.</p> <code>None</code> <p>Returns:</p> Type Description <code>Timer</code> <p>A timer object which should not be manipulated directly by clients. Used to delete/update the timer.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def add_timer(\n    self, callback: Callable, when: int, interval: int, ident: int = None\n) -&gt; Timer:\n\"\"\"Add timer to the queue.\n\n    Arguments:\n        callback: Arbitrary callable object.\n        when: The first expiration time, seconds since epoch.\n        interval: Timer interval, if equals 0, one time timer, otherwise\n            the timer will be periodically executed\n        ident: (optional) Timer identity.\n\n    Returns:\n        A timer object which should not be manipulated directly by\n            clients. Used to delete/update the timer.\n    \"\"\"\n\n    with self._lock:\n        timer = self._timers.add_timer(callback, when, interval, ident)\n    self._wakeup()\n    return timer\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.remove_timer","title":"<code>remove_timer(timer)</code>","text":"<p>Remove timer from the queue.</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>Timer</code> <p>Timer object to remove.</p> required Source code in <code>solnlib/timer_queue.py</code> <pre><code>def remove_timer(self, timer: Timer):\n\"\"\"Remove timer from the queue.\n\n    Arguments:\n        timer: Timer object to remove.\n    \"\"\"\n\n    with self._lock:\n        self._timers.remove_timer(timer)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.start","title":"<code>start()</code>","text":"<p>Start the timer queue.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def start(self):\n\"\"\"Start the timer queue.\"\"\"\n\n    if self._started:\n        return\n    self._started = True\n\n    self._thr.start()\n    logging.info(\"TimerQueue started.\")\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueue.stop","title":"<code>stop()</code>","text":"<p>Stop the timer queue.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def stop(self):\n\"\"\"Stop the timer queue.\"\"\"\n\n    if not self._started:\n        return\n    self._started = True\n\n    self._wakeup(TEARDOWN_SENTINEL)\n    self._thr.join()\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct","title":"<code>TimerQueueStruct</code>","text":"<p>The underlying data structure for TimerQueue.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>class TimerQueueStruct:\n\"\"\"The underlying data structure for TimerQueue.\"\"\"\n\n    def __init__(self):\n        self._timers = sc.SortedSet()\n        self._cancelling_timers = {}\n\n    def add_timer(\n        self, callback: Callable, when: int, interval: int, ident: int\n    ) -&gt; Timer:\n\"\"\"Add timer to the data structure.\n\n        Arguments:\n            callback: Arbitrary callable object.\n            when: The first expiration time, seconds since epoch.\n            interval: Timer interval, if equals 0, one time timer, otherwise\n                the timer will be periodically executed\n            ident: (optional) Timer identity.\n\n        Returns:\n            A timer object which should not be manipulated directly by\n                clients. Used to delete/update the timer.\n        \"\"\"\n\n        timer = Timer(callback, when, interval, ident)\n        self._timers.add(timer)\n        return timer\n\n    def remove_timer(self, timer: Timer):\n\"\"\"Remove timer from data structure.\n\n        Arguments:\n            timer: Timer object which is returned by ``TimerQueueStruct.add_timer``.\n        \"\"\"\n\n        try:\n            self._timers.remove(timer)\n        except ValueError:\n            logging.info(\n                \"Timer=%s is not in queue, move it to cancelling \" \"list\", timer.ident\n            )\n        else:\n            self._cancelling_timers[timer.ident] = timer\n\n    def get_expired_timers(self) -&gt; Tuple:\n\"\"\"Get a list of expired timers.\n\n        Returns:\n            A tuple of ``Timer``, empty list if there is no expired timers.\n        \"\"\"\n\n        next_expired_time = 0\n        now = time()\n        expired_timers = []\n        for timer in self._timers:\n            if timer.when &lt;= now:\n                expired_timers.append(timer)\n\n        if expired_timers:\n            del self._timers[: len(expired_timers)]\n\n        if self._timers:\n            next_expired_time = self._timers[0].when\n        return next_expired_time, expired_timers\n\n    def reset_timers(self, expired_timers: List[Timer]) -&gt; bool:\n\"\"\"Re-add the expired periodical timers to data structure for next\n        round scheduling.\n\n        Arguments:\n            expired_timers: List of expired timers.\n\n        Returns:\n            True if there are timers added, False otherwise.\n        \"\"\"\n\n        has_new_timer = False\n        cancelling_timers = self._cancelling_timers\n        for timer in expired_timers:\n            if timer.ident in cancelling_timers:\n                continue\n            elif timer.interval:\n                # Repeated timer\n                timer.update_expiration()\n                self._timers.add(timer)\n                has_new_timer = True\n        cancelling_timers.clear()\n        return has_new_timer\n\n    def check_and_execute(self) -&gt; float:\n\"\"\"Get expired timers and execute callbacks for the timers.\n\n        Returns:\n            Duration of next expired timer.\n        \"\"\"\n\n        (next_expired_time, expired_timers) = self.get_expired_timers()\n        for timer in expired_timers:\n            try:\n                timer()\n            except Exception:\n                logging.error(traceback.format_exc())\n\n        self.reset_timers(expired_timers)\n        return _calc_sleep_time(next_expired_time)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.__init__","title":"<code>__init__()</code>","text":"Source code in <code>solnlib/timer_queue.py</code> <pre><code>def __init__(self):\n    self._timers = sc.SortedSet()\n    self._cancelling_timers = {}\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.add_timer","title":"<code>add_timer(callback, when, interval, ident)</code>","text":"<p>Add timer to the data structure.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Arbitrary callable object.</p> required <code>when</code> <code>int</code> <p>The first expiration time, seconds since epoch.</p> required <code>interval</code> <code>int</code> <p>Timer interval, if equals 0, one time timer, otherwise the timer will be periodically executed</p> required <code>ident</code> <code>int</code> <p>(optional) Timer identity.</p> required <p>Returns:</p> Type Description <code>Timer</code> <p>A timer object which should not be manipulated directly by clients. Used to delete/update the timer.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def add_timer(\n    self, callback: Callable, when: int, interval: int, ident: int\n) -&gt; Timer:\n\"\"\"Add timer to the data structure.\n\n    Arguments:\n        callback: Arbitrary callable object.\n        when: The first expiration time, seconds since epoch.\n        interval: Timer interval, if equals 0, one time timer, otherwise\n            the timer will be periodically executed\n        ident: (optional) Timer identity.\n\n    Returns:\n        A timer object which should not be manipulated directly by\n            clients. Used to delete/update the timer.\n    \"\"\"\n\n    timer = Timer(callback, when, interval, ident)\n    self._timers.add(timer)\n    return timer\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.check_and_execute","title":"<code>check_and_execute()</code>","text":"<p>Get expired timers and execute callbacks for the timers.</p> <p>Returns:</p> Type Description <code>float</code> <p>Duration of next expired timer.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def check_and_execute(self) -&gt; float:\n\"\"\"Get expired timers and execute callbacks for the timers.\n\n    Returns:\n        Duration of next expired timer.\n    \"\"\"\n\n    (next_expired_time, expired_timers) = self.get_expired_timers()\n    for timer in expired_timers:\n        try:\n            timer()\n        except Exception:\n            logging.error(traceback.format_exc())\n\n    self.reset_timers(expired_timers)\n    return _calc_sleep_time(next_expired_time)\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.get_expired_timers","title":"<code>get_expired_timers()</code>","text":"<p>Get a list of expired timers.</p> <p>Returns:</p> Type Description <code>Tuple</code> <p>A tuple of <code>Timer</code>, empty list if there is no expired timers.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def get_expired_timers(self) -&gt; Tuple:\n\"\"\"Get a list of expired timers.\n\n    Returns:\n        A tuple of ``Timer``, empty list if there is no expired timers.\n    \"\"\"\n\n    next_expired_time = 0\n    now = time()\n    expired_timers = []\n    for timer in self._timers:\n        if timer.when &lt;= now:\n            expired_timers.append(timer)\n\n    if expired_timers:\n        del self._timers[: len(expired_timers)]\n\n    if self._timers:\n        next_expired_time = self._timers[0].when\n    return next_expired_time, expired_timers\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.remove_timer","title":"<code>remove_timer(timer)</code>","text":"<p>Remove timer from data structure.</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>Timer</code> <p>Timer object which is returned by <code>TimerQueueStruct.add_timer</code>.</p> required Source code in <code>solnlib/timer_queue.py</code> <pre><code>def remove_timer(self, timer: Timer):\n\"\"\"Remove timer from data structure.\n\n    Arguments:\n        timer: Timer object which is returned by ``TimerQueueStruct.add_timer``.\n    \"\"\"\n\n    try:\n        self._timers.remove(timer)\n    except ValueError:\n        logging.info(\n            \"Timer=%s is not in queue, move it to cancelling \" \"list\", timer.ident\n        )\n    else:\n        self._cancelling_timers[timer.ident] = timer\n</code></pre>"},{"location":"timer_queue/#solnlib.timer_queue.TimerQueueStruct.reset_timers","title":"<code>reset_timers(expired_timers)</code>","text":"<p>Re-add the expired periodical timers to data structure for next round scheduling.</p> <p>Parameters:</p> Name Type Description Default <code>expired_timers</code> <code>List[Timer]</code> <p>List of expired timers.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if there are timers added, False otherwise.</p> Source code in <code>solnlib/timer_queue.py</code> <pre><code>def reset_timers(self, expired_timers: List[Timer]) -&gt; bool:\n\"\"\"Re-add the expired periodical timers to data structure for next\n    round scheduling.\n\n    Arguments:\n        expired_timers: List of expired timers.\n\n    Returns:\n        True if there are timers added, False otherwise.\n    \"\"\"\n\n    has_new_timer = False\n    cancelling_timers = self._cancelling_timers\n    for timer in expired_timers:\n        if timer.ident in cancelling_timers:\n            continue\n        elif timer.interval:\n            # Repeated timer\n            timer.update_expiration()\n            self._timers.add(timer)\n            has_new_timer = True\n    cancelling_timers.clear()\n    return has_new_timer\n</code></pre>"},{"location":"user_access/","title":"user_access.py","text":"<p>Splunk user access control related utilities.</p>"},{"location":"user_access/#solnlib.user_access.__all__","title":"<code>__all__ = ['ObjectACLException', 'ObjectACL', 'ObjectACLManagerException', 'ObjectACLManager', 'AppCapabilityManagerException', 'AppCapabilityManager', 'UserAccessException', 'check_user_access', 'InvalidSessionKeyException', 'get_current_username', 'UserNotExistException', 'get_user_capabilities', 'user_is_capable', 'get_user_roles']</code>  <code>module-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.AppCapabilityManager","title":"<code>AppCapabilityManager</code>","text":"<p>App capability manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; acm = user_access.AppCapabilityManager('test_collection',\n                                           session_key,\n                                           'Splunk_TA_test')\n&gt;&gt;&gt; acm.register_capabilities(...)\n&gt;&gt;&gt; acm.unregister_capabilities(...)\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>class AppCapabilityManager:\n\"\"\"App capability manager.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; acm = user_access.AppCapabilityManager('test_collection',\n                                                  session_key,\n                                                  'Splunk_TA_test')\n       &gt;&gt;&gt; acm.register_capabilities(...)\n       &gt;&gt;&gt; acm.unregister_capabilities(...)\n    \"\"\"\n\n    def __init__(\n        self,\n        collection_name: str,\n        session_key: str,\n        app: str,\n        owner: str = \"nobody\",\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        **context: dict,\n    ):\n\"\"\"Initializes AppCapabilityManager.\n\n        Arguments:\n            collection_name: Collection name to store capabilities.\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n\n        Raises:\n            AppCapabilityManagerException: If init AppCapabilityManager failed.\n        \"\"\"\n        self._app = app\n\n        collection_name = f\"{app}_{collection_name}\"\n        try:\n            self._collection_data = _utils.get_collection_data(\n                collection_name,\n                session_key,\n                app,\n                owner,\n                scheme,\n                host,\n                port,\n                None,\n                **context,\n            )\n        except KeyError:\n            raise AppCapabilityManagerException(\n                f\"Get app capabilities collection: {collection_name} failed.\"\n            )\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def register_capabilities(self, capabilities: dict):\n\"\"\"Register app capabilities.\n\n        Arguments:\n            capabilities: App capabilities, example:\n\n                {\n                    'object_type1': {\n                        'read': 'read_app_object_type1',\n                        'write': 'write_app_object_type1',\n                        'delete': 'delete_app_object_type1'},\n                        'object_type2': {\n                        'read': 'read_app_object_type2',\n                        'write': 'write_app_object_type2',\n                        'delete': 'delete_app_object_type2'\n                    },\n                    ...\n                }\n        \"\"\"\n\n        record = {\"_key\": self._app, \"capabilities\": capabilities}\n        self._collection_data.batch_save(record)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def unregister_capabilities(self):\n\"\"\"Unregister app capabilities.\n\n        Raises:\n            AppCapabilityNotExistException: If app capabilities are not registered.\n        \"\"\"\n\n        try:\n            self._collection_data.delete_by_id(self._app)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise AppCapabilityNotExistException(\n                \"App capabilities for %s have not been registered.\" % self._app\n            )\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def capabilities_are_registered(self) -&gt; bool:\n\"\"\"Check if app capabilities are registered.\n\n        Returns:\n            True if app capabilities are registered else False.\n        \"\"\"\n\n        try:\n            self._collection_data.query_by_id(self._app)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            return False\n\n        return True\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def get_capabilities(self) -&gt; dict:\n\"\"\"Get app capabilities.\n\n        Returns:\n            App capabilities.\n\n        Raises:\n             AppCapabilityNotExistException: If app capabilities are not registered.\n        \"\"\"\n\n        try:\n            record = self._collection_data.query_by_id(self._app)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise AppCapabilityNotExistException(\n                \"App capabilities for %s have not been registered.\" % self._app\n            )\n\n        return record[\"capabilities\"]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.__init__","title":"<code>__init__(collection_name, session_key, app, owner='nobody', scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes AppCapabilityManager.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Collection name to store capabilities.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>str</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Raises:</p> Type Description <code>AppCapabilityManagerException</code> <p>If init AppCapabilityManager failed.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>def __init__(\n    self,\n    collection_name: str,\n    session_key: str,\n    app: str,\n    owner: str = \"nobody\",\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n):\n\"\"\"Initializes AppCapabilityManager.\n\n    Arguments:\n        collection_name: Collection name to store capabilities.\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Raises:\n        AppCapabilityManagerException: If init AppCapabilityManager failed.\n    \"\"\"\n    self._app = app\n\n    collection_name = f\"{app}_{collection_name}\"\n    try:\n        self._collection_data = _utils.get_collection_data(\n            collection_name,\n            session_key,\n            app,\n            owner,\n            scheme,\n            host,\n            port,\n            None,\n            **context,\n        )\n    except KeyError:\n        raise AppCapabilityManagerException(\n            f\"Get app capabilities collection: {collection_name} failed.\"\n        )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.capabilities_are_registered","title":"<code>capabilities_are_registered()</code>","text":"<p>Check if app capabilities are registered.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if app capabilities are registered else False.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef capabilities_are_registered(self) -&gt; bool:\n\"\"\"Check if app capabilities are registered.\n\n    Returns:\n        True if app capabilities are registered else False.\n    \"\"\"\n\n    try:\n        self._collection_data.query_by_id(self._app)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        return False\n\n    return True\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.get_capabilities","title":"<code>get_capabilities()</code>","text":"<p>Get app capabilities.</p> <p>Returns:</p> Type Description <code>dict</code> <p>App capabilities.</p> <p>Raises:</p> Type Description <code>AppCapabilityNotExistException</code> <p>If app capabilities are not registered.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_capabilities(self) -&gt; dict:\n\"\"\"Get app capabilities.\n\n    Returns:\n        App capabilities.\n\n    Raises:\n         AppCapabilityNotExistException: If app capabilities are not registered.\n    \"\"\"\n\n    try:\n        record = self._collection_data.query_by_id(self._app)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise AppCapabilityNotExistException(\n            \"App capabilities for %s have not been registered.\" % self._app\n        )\n\n    return record[\"capabilities\"]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.register_capabilities","title":"<code>register_capabilities(capabilities)</code>","text":"<p>Register app capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>capabilities</code> <code>dict</code> <p>App capabilities, example:</p> <p>{     \u2018object_type1\u2019: {         \u2018read\u2019: \u2018read_app_object_type1\u2019,         \u2018write\u2019: \u2018write_app_object_type1\u2019,         \u2018delete\u2019: \u2018delete_app_object_type1\u2019},         \u2018object_type2\u2019: {         \u2018read\u2019: \u2018read_app_object_type2\u2019,         \u2018write\u2019: \u2018write_app_object_type2\u2019,         \u2018delete\u2019: \u2018delete_app_object_type2\u2019     },     \u2026 }</p> required Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef register_capabilities(self, capabilities: dict):\n\"\"\"Register app capabilities.\n\n    Arguments:\n        capabilities: App capabilities, example:\n\n            {\n                'object_type1': {\n                    'read': 'read_app_object_type1',\n                    'write': 'write_app_object_type1',\n                    'delete': 'delete_app_object_type1'},\n                    'object_type2': {\n                    'read': 'read_app_object_type2',\n                    'write': 'write_app_object_type2',\n                    'delete': 'delete_app_object_type2'\n                },\n                ...\n            }\n    \"\"\"\n\n    record = {\"_key\": self._app, \"capabilities\": capabilities}\n    self._collection_data.batch_save(record)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityManager.unregister_capabilities","title":"<code>unregister_capabilities()</code>","text":"<p>Unregister app capabilities.</p> <p>Raises:</p> Type Description <code>AppCapabilityNotExistException</code> <p>If app capabilities are not registered.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef unregister_capabilities(self):\n\"\"\"Unregister app capabilities.\n\n    Raises:\n        AppCapabilityNotExistException: If app capabilities are not registered.\n    \"\"\"\n\n    try:\n        self._collection_data.delete_by_id(self._app)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise AppCapabilityNotExistException(\n            \"App capabilities for %s have not been registered.\" % self._app\n        )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityManagerException","title":"<code>AppCapabilityManagerException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for AppCapabilityManager.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class AppCapabilityManagerException(Exception):\n\"\"\"Exception for AppCapabilityManager.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.AppCapabilityNotExistException","title":"<code>AppCapabilityNotExistException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for the situation when AppCapability does not exist for a specific app.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class AppCapabilityNotExistException(Exception):\n\"\"\"Exception for the situation when AppCapability does not exist for a\n    specific app.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.InvalidSessionKeyException","title":"<code>InvalidSessionKeyException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception when Splunk session key is invalid.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class InvalidSessionKeyException(Exception):\n\"\"\"Exception when Splunk session key is invalid.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACL","title":"<code>ObjectACL</code>","text":"<p>Object ACL record.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; obj_acl = user_access.ObjectACL(\n&gt;&gt;&gt;    'test_collection',\n&gt;&gt;&gt;    '9defa6f510d711e6be16a45e60e34295',\n&gt;&gt;&gt;    'test_object',\n&gt;&gt;&gt;    'Splunk_TA_test',\n&gt;&gt;&gt;    'admin',\n&gt;&gt;&gt;    {'read': ['*'], 'write': ['admin'], 'delete': ['admin']},\n&gt;&gt;&gt;    False)\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>class ObjectACL:\n\"\"\"Object ACL record.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; obj_acl = user_access.ObjectACL(\n       &gt;&gt;&gt;    'test_collection',\n       &gt;&gt;&gt;    '9defa6f510d711e6be16a45e60e34295',\n       &gt;&gt;&gt;    'test_object',\n       &gt;&gt;&gt;    'Splunk_TA_test',\n       &gt;&gt;&gt;    'admin',\n       &gt;&gt;&gt;    {'read': ['*'], 'write': ['admin'], 'delete': ['admin']},\n       &gt;&gt;&gt;    False)\n    \"\"\"\n\n    OBJ_COLLECTION_KEY = \"obj_collection\"\n    OBJ_ID_KEY = \"obj_id\"\n    OBJ_TYPE_KEY = \"obj_type\"\n    OBJ_APP_KEY = \"obj_app\"\n    OBJ_OWNER_KEY = \"obj_owner\"\n    OBJ_PERMS_KEY = \"obj_perms\"\n    OBJ_PERMS_READ_KEY = \"read\"\n    OBJ_PERMS_WRITE_KEY = \"write\"\n    OBJ_PERMS_DELETE_KEY = \"delete\"\n    OBJ_PERMS_ALLOW_ALL = \"*\"\n    OBJ_SHARED_BY_INCLUSION_KEY = \"obj_shared_by_inclusion\"\n\n    def __init__(\n        self,\n        obj_collection: str,\n        obj_id: str,\n        obj_type: str,\n        obj_app: str,\n        obj_owner: str,\n        obj_perms: dict,\n        obj_shared_by_inclusion: bool,\n    ):\n\"\"\"Initializes ObjectACL.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_id: ID of this object.\n            obj_type: Type of this object.\n            obj_app: App of this object.\n            obj_owner: Owner of this object.\n            obj_perms: Object perms, like: {'read': ['*'], 'write': ['admin'], 'delete': ['admin']}.\n            obj_shared_by_inclusion: Flag of object is shared by inclusion.\n        \"\"\"\n        self.obj_collection = obj_collection\n        self.obj_id = obj_id\n        self.obj_type = obj_type\n        self.obj_app = obj_app\n        self.obj_owner = obj_owner\n        self._check_perms(obj_perms)\n        self._obj_perms = obj_perms\n        self.obj_shared_by_inclusion = obj_shared_by_inclusion\n\n    @classmethod\n    def _check_perms(cls, obj_perms):\n        if not isinstance(obj_perms, dict):\n            raise ObjectACLException(\n                \"Invalid object acl perms type: %s, should be a dict.\" % type(obj_perms)\n            )\n\n        if not (\n            cls.OBJ_PERMS_READ_KEY in obj_perms\n            and cls.OBJ_PERMS_WRITE_KEY in obj_perms\n            and cls.OBJ_PERMS_DELETE_KEY in obj_perms\n        ):\n            raise ObjectACLException(\n                \"Invalid object acl perms: %s, \"\n                \"should include read, write and delete perms.\" % obj_perms\n            )\n\n    @property\n    def obj_perms(self):\n        return self._obj_perms\n\n    @obj_perms.setter\n    def obj_perms(self, obj_perms):\n        self._check_perms(obj_perms)\n        self._obj_perms = obj_perms\n\n    @property\n    def record(self) -&gt; dict:\n\"\"\"Get object acl record.\n\n        Returns: Object acl record, like:\n\n            {\n                '_key': 'test_collection-1234',\n                'obj_collection': 'test_collection',\n                'obj_id': '1234',\n                'obj_type': 'test_object',\n                'obj_app': 'Splunk_TA_test',\n                'obj_owner': 'admin',\n                'obj_perms': {'read': ['*'], 'write': ['admin'], 'delete': ['admin']},\n                'obj_shared_by_inclusion': True\n            }\n        \"\"\"\n\n        return {\n            \"_key\": self.generate_key(self.obj_collection, self.obj_id),\n            self.OBJ_COLLECTION_KEY: self.obj_collection,\n            self.OBJ_ID_KEY: self.obj_id,\n            self.OBJ_TYPE_KEY: self.obj_type,\n            self.OBJ_APP_KEY: self.obj_app,\n            self.OBJ_OWNER_KEY: self.obj_owner,\n            self.OBJ_PERMS_KEY: self._obj_perms,\n            self.OBJ_SHARED_BY_INCLUSION_KEY: self.obj_shared_by_inclusion,\n        }\n\n    @staticmethod\n    def generate_key(obj_collection: str, obj_id: str) -&gt; str:\n\"\"\"Generate object acl record key.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_id: ID of this object.\n\n        Returns:\n            Object acl record key.\n        \"\"\"\n\n        return \"{obj_collection}_{obj_id}\".format(\n            obj_collection=obj_collection, obj_id=obj_id\n        )\n\n    @staticmethod\n    def parse(obj_acl_record: dict) -&gt; \"ObjectACL\":\n\"\"\"Parse object acl record and construct a new `ObjectACL` object from\n        it.\n\n        Arguments:\n            obj_acl_record: Object acl record.\n\n        Returns:\n            New `ObjectACL` object.\n        \"\"\"\n\n        return ObjectACL(\n            obj_acl_record[ObjectACL.OBJ_COLLECTION_KEY],\n            obj_acl_record[ObjectACL.OBJ_ID_KEY],\n            obj_acl_record[ObjectACL.OBJ_TYPE_KEY],\n            obj_acl_record[ObjectACL.OBJ_APP_KEY],\n            obj_acl_record[ObjectACL.OBJ_OWNER_KEY],\n            obj_acl_record[ObjectACL.OBJ_PERMS_KEY],\n            obj_acl_record[ObjectACL.OBJ_SHARED_BY_INCLUSION_KEY],\n        )\n\n    def merge(self, obj_acl: \"ObjectACL\"):\n\"\"\"Merge current object perms with perms of `obj_acl`.\n\n        Arguments:\n            obj_acl: Object acl to merge.\n        \"\"\"\n\n        for perm_key in self._obj_perms:\n            self._obj_perms[perm_key] = list(\n                set.union(\n                    set(self._obj_perms[perm_key]), set(obj_acl._obj_perms[perm_key])\n                )\n            )\n            if self.OBJ_PERMS_ALLOW_ALL in self._obj_perms[perm_key]:\n                self._obj_perms[perm_key] = [self.OBJ_PERMS_ALLOW_ALL]\n\n    def __str__(self):\n        return json.dumps(self.record)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_APP_KEY","title":"<code>OBJ_APP_KEY = 'obj_app'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_COLLECTION_KEY","title":"<code>OBJ_COLLECTION_KEY = 'obj_collection'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_ID_KEY","title":"<code>OBJ_ID_KEY = 'obj_id'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_OWNER_KEY","title":"<code>OBJ_OWNER_KEY = 'obj_owner'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_ALLOW_ALL","title":"<code>OBJ_PERMS_ALLOW_ALL = '*'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_DELETE_KEY","title":"<code>OBJ_PERMS_DELETE_KEY = 'delete'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_KEY","title":"<code>OBJ_PERMS_KEY = 'obj_perms'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_READ_KEY","title":"<code>OBJ_PERMS_READ_KEY = 'read'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_PERMS_WRITE_KEY","title":"<code>OBJ_PERMS_WRITE_KEY = 'write'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_SHARED_BY_INCLUSION_KEY","title":"<code>OBJ_SHARED_BY_INCLUSION_KEY = 'obj_shared_by_inclusion'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.OBJ_TYPE_KEY","title":"<code>OBJ_TYPE_KEY = 'obj_type'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_app","title":"<code>obj_app = obj_app</code>  <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_collection","title":"<code>obj_collection = obj_collection</code>  <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_id","title":"<code>obj_id = obj_id</code>  <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_owner","title":"<code>obj_owner = obj_owner</code>  <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_perms","title":"<code>obj_perms</code>  <code>writable</code> <code>property</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_shared_by_inclusion","title":"<code>obj_shared_by_inclusion = obj_shared_by_inclusion</code>  <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.obj_type","title":"<code>obj_type = obj_type</code>  <code>instance-attribute</code>","text":""},{"location":"user_access/#solnlib.user_access.ObjectACL.record","title":"<code>record: dict</code>  <code>property</code>","text":"<p>Get object acl record.</p> <p>Object acl record, like:</p> Type Description <code>dict</code> <p>{ \u2018_key\u2019: \u2018test_collection-1234\u2019, \u2018obj_collection\u2019: \u2018test_collection\u2019, \u2018obj_id\u2019: \u20181234\u2019, \u2018obj_type\u2019: \u2018test_object\u2019, \u2018obj_app\u2019: \u2018Splunk_TA_test\u2019, \u2018obj_owner\u2019: \u2018admin\u2019, \u2018obj_perms\u2019: {\u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019]}, \u2018obj_shared_by_inclusion\u2019: True</p> <code>dict</code> <p>}</p>"},{"location":"user_access/#solnlib.user_access.ObjectACL.__init__","title":"<code>__init__(obj_collection, obj_id, obj_type, obj_app, obj_owner, obj_perms, obj_shared_by_inclusion)</code>","text":"<p>Initializes ObjectACL.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_id</code> <code>str</code> <p>ID of this object.</p> required <code>obj_type</code> <code>str</code> <p>Type of this object.</p> required <code>obj_app</code> <code>str</code> <p>App of this object.</p> required <code>obj_owner</code> <code>str</code> <p>Owner of this object.</p> required <code>obj_perms</code> <code>dict</code> <p>Object perms, like: {\u2018read\u2019: [\u2018*\u2019], \u2018write\u2019: [\u2018admin\u2019], \u2018delete\u2019: [\u2018admin\u2019]}.</p> required <code>obj_shared_by_inclusion</code> <code>bool</code> <p>Flag of object is shared by inclusion.</p> required Source code in <code>solnlib/user_access.py</code> <pre><code>def __init__(\n    self,\n    obj_collection: str,\n    obj_id: str,\n    obj_type: str,\n    obj_app: str,\n    obj_owner: str,\n    obj_perms: dict,\n    obj_shared_by_inclusion: bool,\n):\n\"\"\"Initializes ObjectACL.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_id: ID of this object.\n        obj_type: Type of this object.\n        obj_app: App of this object.\n        obj_owner: Owner of this object.\n        obj_perms: Object perms, like: {'read': ['*'], 'write': ['admin'], 'delete': ['admin']}.\n        obj_shared_by_inclusion: Flag of object is shared by inclusion.\n    \"\"\"\n    self.obj_collection = obj_collection\n    self.obj_id = obj_id\n    self.obj_type = obj_type\n    self.obj_app = obj_app\n    self.obj_owner = obj_owner\n    self._check_perms(obj_perms)\n    self._obj_perms = obj_perms\n    self.obj_shared_by_inclusion = obj_shared_by_inclusion\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACL.__str__","title":"<code>__str__()</code>","text":"Source code in <code>solnlib/user_access.py</code> <pre><code>def __str__(self):\n    return json.dumps(self.record)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACL.generate_key","title":"<code>generate_key(obj_collection, obj_id)</code>  <code>staticmethod</code>","text":"<p>Generate object acl record key.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_id</code> <code>str</code> <p>ID of this object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Object acl record key.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@staticmethod\ndef generate_key(obj_collection: str, obj_id: str) -&gt; str:\n\"\"\"Generate object acl record key.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_id: ID of this object.\n\n    Returns:\n        Object acl record key.\n    \"\"\"\n\n    return \"{obj_collection}_{obj_id}\".format(\n        obj_collection=obj_collection, obj_id=obj_id\n    )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACL.merge","title":"<code>merge(obj_acl)</code>","text":"<p>Merge current object perms with perms of <code>obj_acl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj_acl</code> <code>ObjectACL</code> <p>Object acl to merge.</p> required Source code in <code>solnlib/user_access.py</code> <pre><code>def merge(self, obj_acl: \"ObjectACL\"):\n\"\"\"Merge current object perms with perms of `obj_acl`.\n\n    Arguments:\n        obj_acl: Object acl to merge.\n    \"\"\"\n\n    for perm_key in self._obj_perms:\n        self._obj_perms[perm_key] = list(\n            set.union(\n                set(self._obj_perms[perm_key]), set(obj_acl._obj_perms[perm_key])\n            )\n        )\n        if self.OBJ_PERMS_ALLOW_ALL in self._obj_perms[perm_key]:\n            self._obj_perms[perm_key] = [self.OBJ_PERMS_ALLOW_ALL]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACL.parse","title":"<code>parse(obj_acl_record)</code>  <code>staticmethod</code>","text":"<p>Parse object acl record and construct a new <code>ObjectACL</code> object from it.</p> <p>Parameters:</p> Name Type Description Default <code>obj_acl_record</code> <code>dict</code> <p>Object acl record.</p> required <p>Returns:</p> Type Description <code>ObjectACL</code> <p>New <code>ObjectACL</code> object.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@staticmethod\ndef parse(obj_acl_record: dict) -&gt; \"ObjectACL\":\n\"\"\"Parse object acl record and construct a new `ObjectACL` object from\n    it.\n\n    Arguments:\n        obj_acl_record: Object acl record.\n\n    Returns:\n        New `ObjectACL` object.\n    \"\"\"\n\n    return ObjectACL(\n        obj_acl_record[ObjectACL.OBJ_COLLECTION_KEY],\n        obj_acl_record[ObjectACL.OBJ_ID_KEY],\n        obj_acl_record[ObjectACL.OBJ_TYPE_KEY],\n        obj_acl_record[ObjectACL.OBJ_APP_KEY],\n        obj_acl_record[ObjectACL.OBJ_OWNER_KEY],\n        obj_acl_record[ObjectACL.OBJ_PERMS_KEY],\n        obj_acl_record[ObjectACL.OBJ_SHARED_BY_INCLUSION_KEY],\n    )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLException","title":"<code>ObjectACLException</code>","text":"<p>         Bases: <code>Exception</code></p> Source code in <code>solnlib/user_access.py</code> <pre><code>class ObjectACLException(Exception):\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager","title":"<code>ObjectACLManager</code>","text":"<p>Object ACL manager.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; oaclm = user_access.ObjectACLManager(session_key,\n                                         'Splunk_TA_test')\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>class ObjectACLManager:\n\"\"\"Object ACL manager.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; oaclm = user_access.ObjectACLManager(session_key,\n                                                'Splunk_TA_test')\n    \"\"\"\n\n    def __init__(\n        self,\n        collection_name: str,\n        session_key: str,\n        app: str,\n        owner: Optional[str] = \"nobody\",\n        scheme: Optional[str] = None,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        **context: dict,\n    ):\n\"\"\"Initializes ObjectACLManager.\n\n        Arguments:\n            collection_name: Collection name to store object ACL info.\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n\n        Raises:\n            ObjectACLManagerException: If init ObjectACLManager failed.\n        \"\"\"\n        collection_name = \"{app}_{collection_name}\".format(\n            app=app, collection_name=collection_name\n        )\n        try:\n            self._collection_data = _utils.get_collection_data(\n                collection_name,\n                session_key,\n                app,\n                owner,\n                scheme,\n                host,\n                port,\n                None,\n                **context,\n            )\n        except KeyError:\n            raise ObjectACLManagerException(\n                f\"Get object acl collection: {collection_name} fail.\"\n            )\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def update_acl(\n        self,\n        obj_collection: str,\n        obj_id: str,\n        obj_type: str,\n        obj_app: str,\n        obj_owner: str,\n        obj_perms: dict,\n        obj_shared_by_inclusion: bool = True,\n        replace_existing: bool = True,\n    ):\n\"\"\"Update acl info of object.\n\n        Construct a new object acl info first, if `replace_existing` is True\n        then replace existing acl info else merge new object acl info with the\n        old one and replace the old acl info with merged acl info.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_id: ID of this object.\n            obj_type: Type of this object.\n            obj_app: App of this object.\n            obj_owner: Owner of this object.\n            obj_perms: Object perms, like:\n\n                {\n                    'read': ['*'],\n                    'write': ['admin'],\n                    'delete': ['admin']\n                }.\n            obj_shared_by_inclusion: (optional) Flag of object is shared by\n                inclusion, default is True.\n            replace_existing: (optional) Replace existing acl info flag, True\n                indicates replace old acl info with new one else merge with old\n                acl info, default is True.\n        \"\"\"\n\n        obj_acl = ObjectACL(\n            obj_collection,\n            obj_id,\n            obj_type,\n            obj_app,\n            obj_owner,\n            obj_perms,\n            obj_shared_by_inclusion,\n        )\n\n        if not replace_existing:\n            try:\n                old_obj_acl = self.get_acl(obj_collection, obj_id)\n            except ObjectACLNotExistException:\n                old_obj_acl = None\n\n            if old_obj_acl:\n                obj_acl.merge(old_obj_acl)\n\n        self._collection_data.batch_save(obj_acl.record)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def update_acls(\n        self,\n        obj_collection: str,\n        obj_ids: List[str],\n        obj_type: str,\n        obj_app: str,\n        obj_owner: str,\n        obj_perms: dict,\n        obj_shared_by_inclusion: bool = True,\n        replace_existing: bool = True,\n    ):\n\"\"\"Batch update object acl info to all provided `obj_ids`.\n\n        Arguments:\n            obj_collection: Collection where objects currently stored.\n            obj_ids: IDs list of objects.\n            obj_type: Type of this object.\n            obj_app: App of this object.\n            obj_owner: Owner of this object.\n            obj_perms: Object perms, like:\n\n                {\n                    'read': ['*'],\n                    'write': ['admin'],\n                    'delete': ['admin']\n                }.\n            obj_shared_by_inclusion: (optional) Flag of object is shared by\n                inclusion, default is True.\n            replace_existing: (optional) Replace existing acl info flag, True\n                indicates replace old acl info with new one else merge with old acl\n                info, default is True.\n        \"\"\"\n\n        obj_acl_records = []\n        for obj_id in obj_ids:\n            obj_acl = ObjectACL(\n                obj_collection,\n                obj_id,\n                obj_type,\n                obj_app,\n                obj_owner,\n                obj_perms,\n                obj_shared_by_inclusion,\n            )\n\n            if not replace_existing:\n                try:\n                    old_obj_acl = self.get_acl(obj_collection, obj_id)\n                except ObjectACLNotExistException:\n                    old_obj_acl = None\n\n                if old_obj_acl:\n                    obj_acl.merge(old_obj_acl)\n\n            obj_acl_records.append(obj_acl.record)\n\n        self._collection_data.batch_save(*obj_acl_records)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def get_acl(self, obj_collection: str, obj_id: str) -&gt; \"ObjectACL\":\n\"\"\"Get acl info.\n\n        Query object acl info with parameter of the combination of\n        `obj_collection` and `obj_id` from `self.collection_name` and\n        return it.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_id: ID of this object.\n\n        Returns:\n            Object acl info if success else None.\n\n        Raises:\n            ObjectACLNotExistException: If object ACL info does not exist.\n        \"\"\"\n\n        key = ObjectACL.generate_key(obj_collection, obj_id)\n        try:\n            obj_acl = self._collection_data.query_by_id(key)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise ObjectACLNotExistException(\n                \"Object ACL info of {}_{} does not exist.\".format(\n                    obj_collection, obj_id\n                )\n            )\n\n        return ObjectACL.parse(obj_acl)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def get_acls(self, obj_collection: str, obj_ids: List[str]) -&gt; List[ObjectACL]:\n\"\"\"Batch get acl info.\n\n        Query objects acl info with parameter of the combination of\n        `obj_collection` and `obj_ids` from KVStore and return them.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_ids: IDs of objects.\n\n        Returns:\n            List of `ObjectACL` instances.\n        \"\"\"\n\n        query = json.dumps(\n            {\n                \"$or\": [\n                    {\"_key\": ObjectACL.generate_key(obj_collection, obj_id)}\n                    for obj_id in obj_ids\n                ]\n            }\n        )\n        obj_acls = self._collection_data.query(query=query)\n\n        return [ObjectACL.parse(obj_acl) for obj_acl in obj_acls]\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def delete_acl(self, obj_collection: str, obj_id: str):\n\"\"\"Delete acl info.\n\n        Query object acl info with parameter of the combination of\n        `obj_collection` and `obj_ids` from KVStore and delete it.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_id: ID of this object.\n\n        Raises:\n            ObjectACLNotExistException: If object ACL info does not exist.\n        \"\"\"\n\n        key = ObjectACL.generate_key(obj_collection, obj_id)\n        try:\n            self._collection_data.delete_by_id(key)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                raise\n\n            raise ObjectACLNotExistException(\n                \"Object ACL info of {}_{} does not exist.\".format(\n                    obj_collection, obj_id\n                )\n            )\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def delete_acls(self, obj_collection: str, obj_ids: List[str]):\n\"\"\"Batch delete acl info.\n\n        Query objects acl info with parameter of the combination of\n        `obj_collection` and `obj_ids` from KVStore and delete them.\n\n        Arguments:\n            obj_collection: Collection where object currently stored.\n            obj_ids: IDs of objects.\n        \"\"\"\n\n        query = json.dumps(\n            {\n                \"$or\": [\n                    {\"_key\": ObjectACL.generate_key(obj_collection, obj_id)}\n                    for obj_id in obj_ids\n                ]\n            }\n        )\n        self._collection_data.delete(query=query)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def get_accessible_object_ids(\n        self, user: str, operation: str, obj_collection: str, obj_ids: List[str]\n    ) -&gt; List[str]:\n\"\"\"Get accessible IDs of objects from `obj_acls`.\n\n        Arguments:\n            user: User name of current `operation`.\n            operation: User operation, possible option: (read/write/delete).\n            obj_collection: Collection where object currently stored.\n            obj_ids: IDs of objects.\n\n        Returns:\n            List of IDs of accessible objects.\n        \"\"\"\n\n        obj_acls = self.get_acls(obj_collection, obj_ids)\n        accessible_obj_ids = []\n        for obj_acl in obj_acls:\n            perms = obj_acl.obj_perms[operation]\n            if ObjectACL.OBJ_PERMS_ALLOW_ALL in perms or user in perms:\n                accessible_obj_ids.append(obj_acl.obj_id)\n\n        return accessible_obj_ids\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.__init__","title":"<code>__init__(collection_name, session_key, app, owner='nobody', scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes ObjectACLManager.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Collection name to store object ACL info.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>Optional[str]</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>Optional[str]</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>Optional[str]</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ObjectACLManagerException</code> <p>If init ObjectACLManager failed.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>def __init__(\n    self,\n    collection_name: str,\n    session_key: str,\n    app: str,\n    owner: Optional[str] = \"nobody\",\n    scheme: Optional[str] = None,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    **context: dict,\n):\n\"\"\"Initializes ObjectACLManager.\n\n    Arguments:\n        collection_name: Collection name to store object ACL info.\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Raises:\n        ObjectACLManagerException: If init ObjectACLManager failed.\n    \"\"\"\n    collection_name = \"{app}_{collection_name}\".format(\n        app=app, collection_name=collection_name\n    )\n    try:\n        self._collection_data = _utils.get_collection_data(\n            collection_name,\n            session_key,\n            app,\n            owner,\n            scheme,\n            host,\n            port,\n            None,\n            **context,\n        )\n    except KeyError:\n        raise ObjectACLManagerException(\n            f\"Get object acl collection: {collection_name} fail.\"\n        )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.delete_acl","title":"<code>delete_acl(obj_collection, obj_id)</code>","text":"<p>Delete acl info.</p> <p>Query object acl info with parameter of the combination of <code>obj_collection</code> and <code>obj_ids</code> from KVStore and delete it.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_id</code> <code>str</code> <p>ID of this object.</p> required <p>Raises:</p> Type Description <code>ObjectACLNotExistException</code> <p>If object ACL info does not exist.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef delete_acl(self, obj_collection: str, obj_id: str):\n\"\"\"Delete acl info.\n\n    Query object acl info with parameter of the combination of\n    `obj_collection` and `obj_ids` from KVStore and delete it.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_id: ID of this object.\n\n    Raises:\n        ObjectACLNotExistException: If object ACL info does not exist.\n    \"\"\"\n\n    key = ObjectACL.generate_key(obj_collection, obj_id)\n    try:\n        self._collection_data.delete_by_id(key)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise ObjectACLNotExistException(\n            \"Object ACL info of {}_{} does not exist.\".format(\n                obj_collection, obj_id\n            )\n        )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.delete_acls","title":"<code>delete_acls(obj_collection, obj_ids)</code>","text":"<p>Batch delete acl info.</p> <p>Query objects acl info with parameter of the combination of <code>obj_collection</code> and <code>obj_ids</code> from KVStore and delete them.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_ids</code> <code>List[str]</code> <p>IDs of objects.</p> required Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef delete_acls(self, obj_collection: str, obj_ids: List[str]):\n\"\"\"Batch delete acl info.\n\n    Query objects acl info with parameter of the combination of\n    `obj_collection` and `obj_ids` from KVStore and delete them.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_ids: IDs of objects.\n    \"\"\"\n\n    query = json.dumps(\n        {\n            \"$or\": [\n                {\"_key\": ObjectACL.generate_key(obj_collection, obj_id)}\n                for obj_id in obj_ids\n            ]\n        }\n    )\n    self._collection_data.delete(query=query)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.get_accessible_object_ids","title":"<code>get_accessible_object_ids(user, operation, obj_collection, obj_ids)</code>","text":"<p>Get accessible IDs of objects from <code>obj_acls</code>.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>User name of current <code>operation</code>.</p> required <code>operation</code> <code>str</code> <p>User operation, possible option: (read/write/delete).</p> required <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_ids</code> <code>List[str]</code> <p>IDs of objects.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of IDs of accessible objects.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_accessible_object_ids(\n    self, user: str, operation: str, obj_collection: str, obj_ids: List[str]\n) -&gt; List[str]:\n\"\"\"Get accessible IDs of objects from `obj_acls`.\n\n    Arguments:\n        user: User name of current `operation`.\n        operation: User operation, possible option: (read/write/delete).\n        obj_collection: Collection where object currently stored.\n        obj_ids: IDs of objects.\n\n    Returns:\n        List of IDs of accessible objects.\n    \"\"\"\n\n    obj_acls = self.get_acls(obj_collection, obj_ids)\n    accessible_obj_ids = []\n    for obj_acl in obj_acls:\n        perms = obj_acl.obj_perms[operation]\n        if ObjectACL.OBJ_PERMS_ALLOW_ALL in perms or user in perms:\n            accessible_obj_ids.append(obj_acl.obj_id)\n\n    return accessible_obj_ids\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.get_acl","title":"<code>get_acl(obj_collection, obj_id)</code>","text":"<p>Get acl info.</p> <p>Query object acl info with parameter of the combination of <code>obj_collection</code> and <code>obj_id</code> from <code>self.collection_name</code> and return it.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_id</code> <code>str</code> <p>ID of this object.</p> required <p>Returns:</p> Type Description <code>ObjectACL</code> <p>Object acl info if success else None.</p> <p>Raises:</p> Type Description <code>ObjectACLNotExistException</code> <p>If object ACL info does not exist.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_acl(self, obj_collection: str, obj_id: str) -&gt; \"ObjectACL\":\n\"\"\"Get acl info.\n\n    Query object acl info with parameter of the combination of\n    `obj_collection` and `obj_id` from `self.collection_name` and\n    return it.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_id: ID of this object.\n\n    Returns:\n        Object acl info if success else None.\n\n    Raises:\n        ObjectACLNotExistException: If object ACL info does not exist.\n    \"\"\"\n\n    key = ObjectACL.generate_key(obj_collection, obj_id)\n    try:\n        obj_acl = self._collection_data.query_by_id(key)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise ObjectACLNotExistException(\n            \"Object ACL info of {}_{} does not exist.\".format(\n                obj_collection, obj_id\n            )\n        )\n\n    return ObjectACL.parse(obj_acl)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.get_acls","title":"<code>get_acls(obj_collection, obj_ids)</code>","text":"<p>Batch get acl info.</p> <p>Query objects acl info with parameter of the combination of <code>obj_collection</code> and <code>obj_ids</code> from KVStore and return them.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_ids</code> <code>List[str]</code> <p>IDs of objects.</p> required <p>Returns:</p> Type Description <code>List[ObjectACL]</code> <p>List of <code>ObjectACL</code> instances.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_acls(self, obj_collection: str, obj_ids: List[str]) -&gt; List[ObjectACL]:\n\"\"\"Batch get acl info.\n\n    Query objects acl info with parameter of the combination of\n    `obj_collection` and `obj_ids` from KVStore and return them.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_ids: IDs of objects.\n\n    Returns:\n        List of `ObjectACL` instances.\n    \"\"\"\n\n    query = json.dumps(\n        {\n            \"$or\": [\n                {\"_key\": ObjectACL.generate_key(obj_collection, obj_id)}\n                for obj_id in obj_ids\n            ]\n        }\n    )\n    obj_acls = self._collection_data.query(query=query)\n\n    return [ObjectACL.parse(obj_acl) for obj_acl in obj_acls]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.update_acl","title":"<code>update_acl(obj_collection, obj_id, obj_type, obj_app, obj_owner, obj_perms, obj_shared_by_inclusion=True, replace_existing=True)</code>","text":"<p>Update acl info of object.</p> <p>Construct a new object acl info first, if <code>replace_existing</code> is True then replace existing acl info else merge new object acl info with the old one and replace the old acl info with merged acl info.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where object currently stored.</p> required <code>obj_id</code> <code>str</code> <p>ID of this object.</p> required <code>obj_type</code> <code>str</code> <p>Type of this object.</p> required <code>obj_app</code> <code>str</code> <p>App of this object.</p> required <code>obj_owner</code> <code>str</code> <p>Owner of this object.</p> required <code>obj_perms</code> <code>dict</code> <p>Object perms, like:</p> <p>{     \u2018read\u2019: [\u2018*\u2019],     \u2018write\u2019: [\u2018admin\u2019],     \u2018delete\u2019: [\u2018admin\u2019] }.</p> required <code>obj_shared_by_inclusion</code> <code>bool</code> <p>(optional) Flag of object is shared by inclusion, default is True.</p> <code>True</code> <code>replace_existing</code> <code>bool</code> <p>(optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True.</p> <code>True</code> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef update_acl(\n    self,\n    obj_collection: str,\n    obj_id: str,\n    obj_type: str,\n    obj_app: str,\n    obj_owner: str,\n    obj_perms: dict,\n    obj_shared_by_inclusion: bool = True,\n    replace_existing: bool = True,\n):\n\"\"\"Update acl info of object.\n\n    Construct a new object acl info first, if `replace_existing` is True\n    then replace existing acl info else merge new object acl info with the\n    old one and replace the old acl info with merged acl info.\n\n    Arguments:\n        obj_collection: Collection where object currently stored.\n        obj_id: ID of this object.\n        obj_type: Type of this object.\n        obj_app: App of this object.\n        obj_owner: Owner of this object.\n        obj_perms: Object perms, like:\n\n            {\n                'read': ['*'],\n                'write': ['admin'],\n                'delete': ['admin']\n            }.\n        obj_shared_by_inclusion: (optional) Flag of object is shared by\n            inclusion, default is True.\n        replace_existing: (optional) Replace existing acl info flag, True\n            indicates replace old acl info with new one else merge with old\n            acl info, default is True.\n    \"\"\"\n\n    obj_acl = ObjectACL(\n        obj_collection,\n        obj_id,\n        obj_type,\n        obj_app,\n        obj_owner,\n        obj_perms,\n        obj_shared_by_inclusion,\n    )\n\n    if not replace_existing:\n        try:\n            old_obj_acl = self.get_acl(obj_collection, obj_id)\n        except ObjectACLNotExistException:\n            old_obj_acl = None\n\n        if old_obj_acl:\n            obj_acl.merge(old_obj_acl)\n\n    self._collection_data.batch_save(obj_acl.record)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManager.update_acls","title":"<code>update_acls(obj_collection, obj_ids, obj_type, obj_app, obj_owner, obj_perms, obj_shared_by_inclusion=True, replace_existing=True)</code>","text":"<p>Batch update object acl info to all provided <code>obj_ids</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj_collection</code> <code>str</code> <p>Collection where objects currently stored.</p> required <code>obj_ids</code> <code>List[str]</code> <p>IDs list of objects.</p> required <code>obj_type</code> <code>str</code> <p>Type of this object.</p> required <code>obj_app</code> <code>str</code> <p>App of this object.</p> required <code>obj_owner</code> <code>str</code> <p>Owner of this object.</p> required <code>obj_perms</code> <code>dict</code> <p>Object perms, like:</p> <p>{     \u2018read\u2019: [\u2018*\u2019],     \u2018write\u2019: [\u2018admin\u2019],     \u2018delete\u2019: [\u2018admin\u2019] }.</p> required <code>obj_shared_by_inclusion</code> <code>bool</code> <p>(optional) Flag of object is shared by inclusion, default is True.</p> <code>True</code> <code>replace_existing</code> <code>bool</code> <p>(optional) Replace existing acl info flag, True indicates replace old acl info with new one else merge with old acl info, default is True.</p> <code>True</code> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef update_acls(\n    self,\n    obj_collection: str,\n    obj_ids: List[str],\n    obj_type: str,\n    obj_app: str,\n    obj_owner: str,\n    obj_perms: dict,\n    obj_shared_by_inclusion: bool = True,\n    replace_existing: bool = True,\n):\n\"\"\"Batch update object acl info to all provided `obj_ids`.\n\n    Arguments:\n        obj_collection: Collection where objects currently stored.\n        obj_ids: IDs list of objects.\n        obj_type: Type of this object.\n        obj_app: App of this object.\n        obj_owner: Owner of this object.\n        obj_perms: Object perms, like:\n\n            {\n                'read': ['*'],\n                'write': ['admin'],\n                'delete': ['admin']\n            }.\n        obj_shared_by_inclusion: (optional) Flag of object is shared by\n            inclusion, default is True.\n        replace_existing: (optional) Replace existing acl info flag, True\n            indicates replace old acl info with new one else merge with old acl\n            info, default is True.\n    \"\"\"\n\n    obj_acl_records = []\n    for obj_id in obj_ids:\n        obj_acl = ObjectACL(\n            obj_collection,\n            obj_id,\n            obj_type,\n            obj_app,\n            obj_owner,\n            obj_perms,\n            obj_shared_by_inclusion,\n        )\n\n        if not replace_existing:\n            try:\n                old_obj_acl = self.get_acl(obj_collection, obj_id)\n            except ObjectACLNotExistException:\n                old_obj_acl = None\n\n            if old_obj_acl:\n                obj_acl.merge(old_obj_acl)\n\n        obj_acl_records.append(obj_acl.record)\n\n    self._collection_data.batch_save(*obj_acl_records)\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLManagerException","title":"<code>ObjectACLManagerException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for ObjectACLManager.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class ObjectACLManagerException(Exception):\n\"\"\"Exception for ObjectACLManager.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.ObjectACLNotExistException","title":"<code>ObjectACLNotExistException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for the situation when ACL does not exist.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class ObjectACLNotExistException(Exception):\n\"\"\"Exception for the situation when ACL does not exist.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.UserAccessException","title":"<code>UserAccessException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for the situation when there is user access exception.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class UserAccessException(Exception):\n\"\"\"Exception for the situation when there is user access exception.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.UserNotExistException","title":"<code>UserNotExistException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception when user does not exist.</p> Source code in <code>solnlib/user_access.py</code> <pre><code>class UserNotExistException(Exception):\n\"\"\"Exception when user does not exist.\"\"\"\n\n    pass\n</code></pre>"},{"location":"user_access/#solnlib.user_access.check_user_access","title":"<code>check_user_access(session_key, capabilities, obj_type, operation, scheme=None, host=None, port=None, **context)</code>","text":"<p>User access checker.</p> <p>It will fetch user capabilities from given <code>session_key</code> and check if the capability extracted from <code>capabilities</code>, <code>obj_type</code> and <code>operation</code> is contained, if user capabilities include the extracted capability user access is ok else fail.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>capabilities</code> <code>dict</code> <p>App capabilities, example:</p> <p>{     \u2018object_type1\u2019: {         \u2018read\u2019: \u2018read_app_object_type1\u2019,         \u2018write\u2019: \u2018write_app_object_type1\u2019,         \u2018delete\u2019: \u2018delete_app_object_type1\u2019},         \u2018object_type2\u2019: {         \u2018read\u2019: \u2018read_app_object_type2\u2019,         \u2018write\u2019: \u2018write_app_object_type2\u2019,         \u2018delete\u2019: \u2018delete_app_object_type2\u2019     },     \u2026 }</p> required <code>obj_type</code> <code>str</code> <p>Object type.</p> required <code>operation</code> <code>str</code> <p>User operation, possible option: (read/write/delete).</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Raises:</p> Type Description <code>UserAccessException</code> <p>If user access permission is denied.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.user_access import check_user_access\n&gt;&gt;&gt; def fun():\n&gt;&gt;&gt;     check_user_access(\n&gt;&gt;&gt;         session_key, capabilities, 'test_object', 'read')\n&gt;&gt;&gt;     ...\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>def check_user_access(\n    session_key: str,\n    capabilities: dict,\n    obj_type: str,\n    operation: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n):\n\"\"\"User access checker.\n\n    It will fetch user capabilities from given `session_key` and check if\n    the capability extracted from `capabilities`, `obj_type` and `operation`\n    is contained, if user capabilities include the extracted capability user\n    access is ok else fail.\n\n    Arguments:\n        session_key: Splunk access token.\n        capabilities: App capabilities, example:\n\n            {\n                'object_type1': {\n                    'read': 'read_app_object_type1',\n                    'write': 'write_app_object_type1',\n                    'delete': 'delete_app_object_type1'},\n                    'object_type2': {\n                    'read': 'read_app_object_type2',\n                    'write': 'write_app_object_type2',\n                    'delete': 'delete_app_object_type2'\n                },\n                ...\n            }\n        obj_type: Object type.\n        operation: User operation, possible option: (read/write/delete).\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Raises:\n        UserAccessException: If user access permission is denied.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib.user_access import check_user_access\n       &gt;&gt;&gt; def fun():\n       &gt;&gt;&gt;     check_user_access(\n       &gt;&gt;&gt;         session_key, capabilities, 'test_object', 'read')\n       &gt;&gt;&gt;     ...\n    \"\"\"\n\n    username = get_current_username(\n        session_key, scheme=scheme, host=host, port=port, **context\n    )\n    capability = capabilities[obj_type][operation]\n    if not user_is_capable(\n        session_key,\n        username,\n        capability,\n        scheme=scheme,\n        host=host,\n        port=port,\n        **context,\n    ):\n        raise UserAccessException(\n            \"Permission denied, %s does not have the capability: %s.\"\n            % (username, capability)\n        )\n</code></pre>"},{"location":"user_access/#solnlib.user_access.get_current_username","title":"<code>get_current_username(session_key, scheme=None, host=None, port=None, **context)</code>","text":"<p>Get current user name from <code>session_key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>Current user name.</p> <p>Raises:</p> Type Description <code>InvalidSessionKeyException</code> <p>If <code>session_key</code> is invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; user_name = user_access.get_current_username(session_key)\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_current_username(\n    session_key: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n) -&gt; str:\n\"\"\"Get current user name from `session_key`.\n\n    Arguments:\n        session_key: Splunk access token.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Returns:\n        Current user name.\n\n    Raises:\n        InvalidSessionKeyException: If `session_key` is invalid.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; user_name = user_access.get_current_username(session_key)\n    \"\"\"\n\n    _rest_client = rest_client.SplunkRestClient(\n        session_key, \"-\", scheme=scheme, host=host, port=port, **context\n    )\n    try:\n        response = _rest_client.get(\n            \"/services/authentication/current-context\", output_mode=\"json\"\n        ).body.read()\n    except binding.HTTPError as e:\n        if e.status != 401:\n            raise\n\n        raise InvalidSessionKeyException(\"Invalid session key.\")\n\n    return json.loads(response)[\"entry\"][0][\"content\"][\"username\"]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.get_user_capabilities","title":"<code>get_user_capabilities(session_key, username, scheme=None, host=None, port=None, **context)</code>","text":"<p>Get user capabilities.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[dict]</code> <p>User capabilities.</p> <p>Raises:</p> Type Description <code>UserNotExistException</code> <p>If <code>username</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; user_capabilities = user_access.get_user_capabilities(\n&gt;&gt;&gt;     session_key, 'test_user')\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_user_capabilities(\n    session_key: str,\n    username: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n) -&gt; List[dict]:\n\"\"\"Get user capabilities.\n\n    Arguments:\n        session_key: Splunk access token.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Returns:\n        User capabilities.\n\n    Raises:\n        UserNotExistException: If `username` does not exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; user_capabilities = user_access.get_user_capabilities(\n       &gt;&gt;&gt;     session_key, 'test_user')\n    \"\"\"\n\n    _rest_client = rest_client.SplunkRestClient(\n        session_key, \"-\", scheme=scheme, host=host, port=port, **context\n    )\n    url = f\"/services/authentication/users/{username}\"\n    try:\n        response = _rest_client.get(url, output_mode=\"json\").body.read()\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise UserNotExistException(\"User: %s does not exist.\" % username)\n\n    return json.loads(response)[\"entry\"][0][\"content\"][\"capabilities\"]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.get_user_roles","title":"<code>get_user_roles(session_key, username, scheme=None, host=None, port=None, **context)</code>","text":"<p>Get user roles.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>username</code> <code>str</code> <p>(optional) User name of roles to get.</p> required <code>scheme</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List</code> <p>User roles.</p> <p>Raises:</p> Type Description <code>UserNotExistException</code> <p>If <code>username</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; user_roles = user_access.get_user_roles(session_key, 'test_user')\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get_user_roles(\n    session_key: str, username: str, scheme=None, host=None, port=None, **context\n) -&gt; List:\n\"\"\"Get user roles.\n\n    Arguments:\n        session_key: Splunk access token.\n        username: (optional) User name of roles to get.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Returns:\n        User roles.\n\n    Raises:\n        UserNotExistException: If `username` does not exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; user_roles = user_access.get_user_roles(session_key, 'test_user')\n    \"\"\"\n\n    _rest_client = rest_client.SplunkRestClient(\n        session_key, \"-\", scheme=scheme, host=host, port=port, **context\n    )\n    url = f\"/services/authentication/users/{username}\"\n    try:\n        response = _rest_client.get(url, output_mode=\"json\").body.read()\n    except binding.HTTPError as e:\n        if e.status != 404:\n            raise\n\n        raise UserNotExistException(\"User: %s does not exist.\" % username)\n\n    return json.loads(response)[\"entry\"][0][\"content\"][\"roles\"]\n</code></pre>"},{"location":"user_access/#solnlib.user_access.user_is_capable","title":"<code>user_is_capable(session_key, username, capability, scheme=None, host=None, port=None, **context)</code>","text":"<p>Check if user is capable for given <code>capability</code>.</p> <p>Parameters:</p> Name Type Description Default <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>username</code> <code>str</code> <p>(optional) User name of roles to get.</p> required <code>capability</code> <code>str</code> <p>The capability we wish to check for.</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if user is capable else False.</p> <p>Raises:</p> Type Description <code>UserNotExistException</code> <p>If <code>username</code> does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib import user_access\n&gt;&gt;&gt; is_capable = user_access.user_is_capable(\n&gt;&gt;&gt;     session_key, 'test_user', 'object_read_capability')\n</code></pre> Source code in <code>solnlib/user_access.py</code> <pre><code>def user_is_capable(\n    session_key: str,\n    username: str,\n    capability: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    **context: dict,\n) -&gt; bool:\n\"\"\"Check if user is capable for given `capability`.\n\n    Arguments:\n        session_key: Splunk access token.\n        username: (optional) User name of roles to get.\n        capability: The capability we wish to check for.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Returns:\n        True if user is capable else False.\n\n    Raises:\n        UserNotExistException: If `username` does not exist.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib import user_access\n       &gt;&gt;&gt; is_capable = user_access.user_is_capable(\n       &gt;&gt;&gt;     session_key, 'test_user', 'object_read_capability')\n    \"\"\"\n\n    capabilities = get_user_capabilities(\n        session_key, username, scheme=scheme, host=host, port=port, **context\n    )\n    return capability in capabilities\n</code></pre>"},{"location":"utils/","title":"utils.py","text":"<p>Common utilities.</p>"},{"location":"utils/#solnlib.utils.__all__","title":"<code>__all__ = ['handle_teardown_signals', 'datetime_to_seconds', 'is_true', 'is_false', 'retry', 'extract_http_scheme_host_port', 'remove_http_proxy_env_vars']</code>  <code>module-attribute</code>","text":""},{"location":"utils/#solnlib.utils.datetime_to_seconds","title":"<code>datetime_to_seconds(dt)</code>","text":"<p>Convert UTC datetime to seconds since epoch.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>datetime.datetime</code> <p>Date time.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Seconds since epoch.</p> Source code in <code>solnlib/utils.py</code> <pre><code>def datetime_to_seconds(dt: datetime.datetime) -&gt; float:\n\"\"\"Convert UTC datetime to seconds since epoch.\n\n    Arguments:\n        dt: Date time.\n\n    Returns:\n        Seconds since epoch.\n    \"\"\"\n\n    epoch_time = datetime.datetime.utcfromtimestamp(0)\n    return (dt - epoch_time).total_seconds()\n</code></pre>"},{"location":"utils/#solnlib.utils.extract_http_scheme_host_port","title":"<code>extract_http_scheme_host_port(http_url)</code>","text":"<p>Extract scheme, host and port from a HTTP URL.</p> <p>Parameters:</p> Name Type Description Default <code>http_url</code> <code>str</code> <p>HTTP URL to extract.</p> required <p>Returns:</p> Type Description <code>Tuple</code> <p>A tuple of scheme, host and port</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>http_url</code> is not in http(s)://hostname:port format.</p> Source code in <code>solnlib/utils.py</code> <pre><code>def extract_http_scheme_host_port(http_url: str) -&gt; Tuple:\n\"\"\"Extract scheme, host and port from a HTTP URL.\n\n    Arguments:\n        http_url: HTTP URL to extract.\n\n    Returns:\n        A tuple of scheme, host and port\n\n    Raises:\n        ValueError: If `http_url` is not in http(s)://hostname:port format.\n    \"\"\"\n\n    http_info = urlparse.urlparse(http_url)\n    if not http_info.scheme or not http_info.hostname or not http_info.port:\n        raise ValueError(http_url + \" is not in http(s)://hostname:port format\")\n    return http_info.scheme, http_info.hostname, http_info.port\n</code></pre>"},{"location":"utils/#solnlib.utils.get_appname_from_path","title":"<code>get_appname_from_path(absolute_path)</code>","text":"<p>Gets name of the app from its path.</p> <p>Parameters:</p> Name Type Description Default <code>absolute_path</code> <p>path of app</p> required Source code in <code>solnlib/utils.py</code> <pre><code>def get_appname_from_path(absolute_path):\n\"\"\"Gets name of the app from its path.\n\n    Arguments:\n        absolute_path: path of app\n\n    Returns:\n    \"\"\"\n    absolute_path = os.path.normpath(absolute_path)\n    parts = absolute_path.split(os.path.sep)\n    parts.reverse()\n    for key in (\"apps\", \"peer-apps\", \"manager-apps\"):\n        try:\n            idx = parts.index(key)\n        except ValueError:\n            continue\n        else:\n            try:\n                if parts[idx + 1] == \"etc\":\n                    return parts[idx - 1]\n            except IndexError:\n                pass\n            continue\n    return \"-\"\n</code></pre>"},{"location":"utils/#solnlib.utils.handle_teardown_signals","title":"<code>handle_teardown_signals(callback)</code>","text":"<p>Register handler for SIGTERM/SIGINT/SIGBREAK signal.</p> <p>Catch SIGTERM/SIGINT/SIGBREAK signals, and invoke callback Note: this should be called in main thread since Python only catches signals in main thread.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Callback for tear down signals.</p> required Source code in <code>solnlib/utils.py</code> <pre><code>def handle_teardown_signals(callback: Callable):\n\"\"\"Register handler for SIGTERM/SIGINT/SIGBREAK signal.\n\n    Catch SIGTERM/SIGINT/SIGBREAK signals, and invoke callback\n    Note: this should be called in main thread since Python only catches\n    signals in main thread.\n\n    Arguments:\n        callback: Callback for tear down signals.\n    \"\"\"\n\n    signal.signal(signal.SIGTERM, callback)\n    signal.signal(signal.SIGINT, callback)\n\n    if os.name == \"nt\":\n        signal.signal(signal.SIGBREAK, callback)\n</code></pre>"},{"location":"utils/#solnlib.utils.is_false","title":"<code>is_false(val)</code>","text":"<p>Decide if <code>val</code> is false.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Union[str, int]</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True or False.</p> Source code in <code>solnlib/utils.py</code> <pre><code>def is_false(val: Union[str, int]) -&gt; bool:\n\"\"\"Decide if `val` is false.\n\n    Arguments:\n        val: Value to check.\n\n    Returns:\n        True or False.\n    \"\"\"\n\n    value = str(val).strip().upper()\n    if value in (\"0\", \"FALSE\", \"F\", \"N\", \"NO\", \"NONE\", \"\"):\n        return True\n    return False\n</code></pre>"},{"location":"utils/#solnlib.utils.is_true","title":"<code>is_true(val)</code>","text":"<p>Decide if <code>val</code> is true.</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>Union[str, int]</code> <p>Value to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True or False.</p> Source code in <code>solnlib/utils.py</code> <pre><code>def is_true(val: Union[str, int]) -&gt; bool:\n\"\"\"Decide if `val` is true.\n\n    Arguments:\n        val: Value to check.\n\n    Returns:\n        True or False.\n    \"\"\"\n\n    value = str(val).strip().upper()\n    if value in (\"1\", \"TRUE\", \"T\", \"Y\", \"YES\"):\n        return True\n    return False\n</code></pre>"},{"location":"utils/#solnlib.utils.remove_http_proxy_env_vars","title":"<code>remove_http_proxy_env_vars()</code>","text":"<p>Removes HTTP(s) proxies from environment variables.</p> Removes the following environment variables <ul> <li>http_proxy</li> <li>https_proxy</li> <li>HTTP_PROXY</li> <li>HTTPS_PROXY</li> </ul> <p>This function can be used in Splunk modular inputs code before starting the ingestion to ensure that no proxy is going to be used when doing requests. In case of proxy is needed, it can be defined in the modular inputs code.</p> Source code in <code>solnlib/utils.py</code> <pre><code>def remove_http_proxy_env_vars() -&gt; None:\n\"\"\"Removes HTTP(s) proxies from environment variables.\n\n    Removes the following environment variables:\n        * http_proxy\n        * https_proxy\n        * HTTP_PROXY\n        * HTTPS_PROXY\n\n    This function can be used in Splunk modular inputs code before starting the\n    ingestion to ensure that no proxy is going to be used when doing requests.\n    In case of proxy is needed, it can be defined in the modular inputs code.\n    \"\"\"\n    env_vars_to_remove = (\n        \"http_proxy\",\n        \"https_proxy\",\n        \"HTTP_PROXY\",\n        \"HTTPS_PROXY\",\n    )\n    for env_var in env_vars_to_remove:\n        if env_var in os.environ:\n            del os.environ[env_var]\n</code></pre>"},{"location":"utils/#solnlib.utils.retry","title":"<code>retry(retries=3, reraise=True, default_return=None, exceptions=None)</code>","text":"<p>A decorator to run function with max <code>retries</code> times if there is exception.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>(optional) Max retries times, default is 3.</p> <code>3</code> <code>reraise</code> <code>bool</code> <p>Whether exception should be reraised, default is True.</p> <code>True</code> <code>default_return</code> <code>Any</code> <p>(optional) Default return value for function run after max retries and reraise is False.</p> <code>None</code> <code>exceptions</code> <code>List</code> <p>(optional) List of exceptions that should retry.</p> <code>None</code> Source code in <code>solnlib/utils.py</code> <pre><code>def retry(\n    retries: int = 3,\n    reraise: bool = True,\n    default_return: Any = None,\n    exceptions: List = None,\n):\n\"\"\"A decorator to run function with max `retries` times if there is\n    exception.\n\n    Arguments:\n        retries: (optional) Max retries times, default is 3.\n        reraise: Whether exception should be reraised, default is True.\n        default_return: (optional) Default return value for function\n            run after max retries and reraise is False.\n        exceptions: (optional) List of exceptions that should retry.\n    \"\"\"\n\n    max_tries = max(retries, 0) + 1\n\n    def do_retry(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_ex = None\n            for i in range(max_tries):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    logging.warning(\n                        \"Run function: %s failed: %s.\",\n                        func.__name__,\n                        traceback.format_exc(),\n                    )\n                    if not exceptions or any(\n                        isinstance(e, exception) for exception in exceptions\n                    ):\n                        last_ex = e\n                        if i &lt; max_tries - 1:\n                            time.sleep(2**i)\n                    else:\n                        raise\n\n            if reraise:\n                raise last_ex\n            else:\n                return default_return\n\n        return wrapper\n\n    return do_retry\n</code></pre>"},{"location":"modular_input/checkpointer/","title":"checkpointer.py","text":"<p>This module provides two kinds of checkpointer: KVStoreCheckpointer, FileCheckpointer for modular input to save checkpoint.</p>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.__all__","title":"<code>__all__ = ['CheckpointerException', 'KVStoreCheckpointer', 'FileCheckpointer']</code>  <code>module-attribute</code>","text":""},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer","title":"<code>Checkpointer</code>","text":"<p>Base class of checkpointer.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>class Checkpointer(metaclass=ABCMeta):\n\"\"\"Base class of checkpointer.\"\"\"\n\n    @abstractmethod\n    def update(self, key: str, state: Any):\n\"\"\"Updates document with an id that equals to `key` and `state` as\n        document data.\"\"\"\n\n    @abstractmethod\n    def batch_update(self, states: Iterable[Dict[str, Any]]):\n\"\"\"Updates multiple documents.\"\"\"\n\n    @abstractmethod\n    def get(self, key: str) -&gt; dict:\n\"\"\"Gets document with an id that equals to `key`.\"\"\"\n\n    @abstractmethod\n    def delete(self, key: str):\n\"\"\"Deletes document with an id that equals to `key`.\"\"\"\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.batch_update","title":"<code>batch_update(states)</code>  <code>abstractmethod</code>","text":"<p>Updates multiple documents.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@abstractmethod\ndef batch_update(self, states: Iterable[Dict[str, Any]]):\n\"\"\"Updates multiple documents.\"\"\"\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.delete","title":"<code>delete(key)</code>  <code>abstractmethod</code>","text":"<p>Deletes document with an id that equals to <code>key</code>.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@abstractmethod\ndef delete(self, key: str):\n\"\"\"Deletes document with an id that equals to `key`.\"\"\"\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.get","title":"<code>get(key)</code>  <code>abstractmethod</code>","text":"<p>Gets document with an id that equals to <code>key</code>.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@abstractmethod\ndef get(self, key: str) -&gt; dict:\n\"\"\"Gets document with an id that equals to `key`.\"\"\"\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.Checkpointer.update","title":"<code>update(key, state)</code>  <code>abstractmethod</code>","text":"<p>Updates document with an id that equals to <code>key</code> and <code>state</code> as document data.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@abstractmethod\ndef update(self, key: str, state: Any):\n\"\"\"Updates document with an id that equals to `key` and `state` as\n    document data.\"\"\"\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.CheckpointerException","title":"<code>CheckpointerException</code>","text":"<p>         Bases: <code>Exception</code></p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>class CheckpointerException(Exception):\n    pass\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer","title":"<code>FileCheckpointer</code>","text":"<p>         Bases: <code>Checkpointer</code></p> <p>File checkpointer.</p> <p>Use file to save modular input checkpoint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.modular_input import checkpointer\n&gt;&gt;&gt; ck = checkpointer.FileCheckpointer('/opt/splunk/var/...')\n&gt;&gt;&gt; ck.update(...)\n&gt;&gt;&gt; ck.get(...)\n</code></pre> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>class FileCheckpointer(Checkpointer):\n\"\"\"File checkpointer.\n\n    Use file to save modular input checkpoint.\n\n    Examples:\n        &gt;&gt;&gt; from solnlib.modular_input import checkpointer\n        &gt;&gt;&gt; ck = checkpointer.FileCheckpointer('/opt/splunk/var/...')\n        &gt;&gt;&gt; ck.update(...)\n        &gt;&gt;&gt; ck.get(...)\n    \"\"\"\n\n    def __init__(self, checkpoint_dir: str):\n\"\"\"Initializes FileCheckpointer.\n\n        Arguments:\n            checkpoint_dir: Checkpoint directory.\n        \"\"\"\n        warnings.warn(\n            \"FileCheckpointer is deprecated, please use KVStoreCheckpointer\",\n            stacklevel=2,\n        )\n        self._checkpoint_dir = checkpoint_dir\n\n    def encode_key(self, key):\n        return base64.b64encode(key.encode()).decode()\n\n    def update(self, key, state):\n        file_name = op.join(self._checkpoint_dir, self.encode_key(key))\n        with open(file_name + \"_new\", \"w\") as fp:\n            json.dump(state, fp)\n\n        if op.exists(file_name):\n            try:\n                os.remove(file_name)\n            except OSError:\n                pass\n\n        os.rename(file_name + \"_new\", file_name)\n\n    def batch_update(self, states):\n        for state in states:\n            self.update(state[\"_key\"], state[\"state\"])\n\n    def get(self, key):\n        file_name = op.join(self._checkpoint_dir, self.encode_key(key))\n        try:\n            with open(file_name) as fp:\n                return json.load(fp)\n        except (OSError, ValueError):\n            return None\n\n    def delete(self, key):\n        file_name = op.join(self._checkpoint_dir, self.encode_key(key))\n        try:\n            os.remove(file_name)\n        except OSError:\n            pass\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.__init__","title":"<code>__init__(checkpoint_dir)</code>","text":"<p>Initializes FileCheckpointer.</p> <p>Parameters:</p> Name Type Description Default <code>checkpoint_dir</code> <code>str</code> <p>Checkpoint directory.</p> required Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def __init__(self, checkpoint_dir: str):\n\"\"\"Initializes FileCheckpointer.\n\n    Arguments:\n        checkpoint_dir: Checkpoint directory.\n    \"\"\"\n    warnings.warn(\n        \"FileCheckpointer is deprecated, please use KVStoreCheckpointer\",\n        stacklevel=2,\n    )\n    self._checkpoint_dir = checkpoint_dir\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.batch_update","title":"<code>batch_update(states)</code>","text":"Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def batch_update(self, states):\n    for state in states:\n        self.update(state[\"_key\"], state[\"state\"])\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.delete","title":"<code>delete(key)</code>","text":"Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def delete(self, key):\n    file_name = op.join(self._checkpoint_dir, self.encode_key(key))\n    try:\n        os.remove(file_name)\n    except OSError:\n        pass\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.encode_key","title":"<code>encode_key(key)</code>","text":"Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def encode_key(self, key):\n    return base64.b64encode(key.encode()).decode()\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.get","title":"<code>get(key)</code>","text":"Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def get(self, key):\n    file_name = op.join(self._checkpoint_dir, self.encode_key(key))\n    try:\n        with open(file_name) as fp:\n            return json.load(fp)\n    except (OSError, ValueError):\n        return None\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.FileCheckpointer.update","title":"<code>update(key, state)</code>","text":"Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def update(self, key, state):\n    file_name = op.join(self._checkpoint_dir, self.encode_key(key))\n    with open(file_name + \"_new\", \"w\") as fp:\n        json.dump(state, fp)\n\n    if op.exists(file_name):\n        try:\n            os.remove(file_name)\n        except OSError:\n            pass\n\n    os.rename(file_name + \"_new\", file_name)\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer","title":"<code>KVStoreCheckpointer</code>","text":"<p>         Bases: <code>Checkpointer</code></p> <p>KVStore checkpointer.</p> <p>Use KVStore to save modular input checkpoint.</p> <p>More information about KV Store in Splunk is here.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.modular_input import checkpointer\n&gt;&gt;&gt; checkpoint = checkpointer.KVStoreCheckpointer(\n        \"unique_addon_checkpoints\",\n        \"session_key\",\n        \"unique_addon\"\n    )\n&gt;&gt;&gt; checkpoint.update(\"input_1\", {\"timestamp\": 1638043093})\n&gt;&gt;&gt; checkpoint.get(\"input_1\")\n&gt;&gt;&gt; # returns {\"timestamp\": 1638043093}\n</code></pre> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>class KVStoreCheckpointer(Checkpointer):\n\"\"\"KVStore checkpointer.\n\n    Use KVStore to save modular input checkpoint.\n\n    More information about KV Store in Splunk is\n    [here](https://dev.splunk.com/enterprise/docs/developapps/manageknowledge/kvstore/aboutkvstorecollections).\n\n    Examples:\n        &gt;&gt;&gt; from solnlib.modular_input import checkpointer\n        &gt;&gt;&gt; checkpoint = checkpointer.KVStoreCheckpointer(\n                \"unique_addon_checkpoints\",\n                \"session_key\",\n                \"unique_addon\"\n            )\n        &gt;&gt;&gt; checkpoint.update(\"input_1\", {\"timestamp\": 1638043093})\n        &gt;&gt;&gt; checkpoint.get(\"input_1\")\n        &gt;&gt;&gt; # returns {\"timestamp\": 1638043093}\n    \"\"\"\n\n    def __init__(\n        self,\n        collection_name: str,\n        session_key: str,\n        app: str,\n        owner: Optional[str] = \"nobody\",\n        scheme: Optional[str] = None,\n        host: Optional[str] = None,\n        port: Optional[int] = None,\n        **context: Any,\n    ):\n\"\"\"Initializes KVStoreCheckpointer.\n\n        Arguments:\n            collection_name: Collection name of kvstore checkpointer.\n            session_key: Splunk access token.\n            app: App name of namespace.\n            owner: (optional) Owner of namespace, default is `nobody`.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            context: Other configurations for Splunk rest client.\n\n        Raises:\n            binding.HTTPError: HTTP error different from 404, for example 503\n                when KV Store is initializing and not ready to serve requests.\n            CheckpointerException: If init KV Store checkpointer failed.\n        \"\"\"\n        try:\n            if not context.get(\"pool_connections\"):\n                context[\"pool_connections\"] = 5\n            if not context.get(\"pool_maxsize\"):\n                context[\"pool_maxsize\"] = 5\n            self._collection_data = _utils.get_collection_data(\n                collection_name,\n                session_key,\n                app,\n                owner,\n                scheme,\n                host,\n                port,\n                {\"state\": \"string\"},\n                **context,\n            )\n        except KeyError:\n            raise CheckpointerException(\"Get KV Store checkpointer failed.\")\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def update(self, key: str, state: Any) -&gt; None:\n\"\"\"Updates document with an id that equals to `key` and `state` as\n        document data.\n\n        Arguments:\n            key: `id` of the document to update.\n            state: Document data to update. It can be integer, string,\n                or a dict, or anything that can be an argument to `json.dumps`.\n\n        Raises:\n            binding.HTTPError: when an error occurred in Splunk, for example,\n                when Splunk is restarting and KV Store is not yet initialized.\n        \"\"\"\n        record = {\"_key\": key, \"state\": json.dumps(state)}\n        self._collection_data.batch_save(record)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def batch_update(self, states: Iterable[Dict[str, Any]]) -&gt; None:\n\"\"\"Updates multiple documents.\n\n        Arguments:\n            states: Iterable that contains documents to update. Document should\n                be a dict with at least \"state\" key.\n\n        Raises:\n            binding.HTTPError: when an error occurred in Splunk, for example,\n                when Splunk is restarting and KV Store is not yet initialized.\n        \"\"\"\n        for state in states:\n            state[\"state\"] = json.dumps(state[\"state\"])\n        self._collection_data.batch_save(*states)\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def get(self, key: str) -&gt; Optional[Any]:\n\"\"\"Gets document with an id that equals to `key`.\n\n        Arguments:\n            key: `id` of the document to get.\n\n        Raises:\n            binding.HTTPError: When an error occurred in Splunk (not 404 code),\n                can be 503 code, when Splunk is restarting and KV Store is not\n                yet initialized.\n\n        Returns:\n            Document data under `key` or `None` in case of no data.\n        \"\"\"\n        try:\n            record = self._collection_data.query_by_id(key)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                logging.error(f\"Get checkpoint failed: {traceback.format_exc()}.\")\n                raise\n            return None\n        return json.loads(record[\"state\"])\n\n    @utils.retry(exceptions=[binding.HTTPError])\n    def delete(self, key: str) -&gt; None:\n\"\"\"Deletes document with an id that equals to `key`.\n\n        Arguments:\n            key: `id` of the document to delete.\n\n        Raises:\n            binding.HTTPError: When an error occurred in Splunk (not 404 code),\n                can be 503 code, when Splunk is restarting and KV Store is not\n                yet initialized.\n        \"\"\"\n        try:\n            self._collection_data.delete_by_id(key)\n        except binding.HTTPError as e:\n            if e.status != 404:\n                logging.error(f\"Delete checkpoint failed: {traceback.format_exc()}.\")\n                raise\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.__init__","title":"<code>__init__(collection_name, session_key, app, owner='nobody', scheme=None, host=None, port=None, **context)</code>","text":"<p>Initializes KVStoreCheckpointer.</p> <p>Parameters:</p> Name Type Description Default <code>collection_name</code> <code>str</code> <p>Collection name of kvstore checkpointer.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>app</code> <code>str</code> <p>App name of namespace.</p> required <code>owner</code> <code>Optional[str]</code> <p>(optional) Owner of namespace, default is <code>nobody</code>.</p> <code>'nobody'</code> <code>scheme</code> <code>Optional[str]</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>Optional[str]</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>Optional[int]</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>context</code> <code>Any</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>HTTP error different from 404, for example 503 when KV Store is initializing and not ready to serve requests.</p> <code>CheckpointerException</code> <p>If init KV Store checkpointer failed.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>def __init__(\n    self,\n    collection_name: str,\n    session_key: str,\n    app: str,\n    owner: Optional[str] = \"nobody\",\n    scheme: Optional[str] = None,\n    host: Optional[str] = None,\n    port: Optional[int] = None,\n    **context: Any,\n):\n\"\"\"Initializes KVStoreCheckpointer.\n\n    Arguments:\n        collection_name: Collection name of kvstore checkpointer.\n        session_key: Splunk access token.\n        app: App name of namespace.\n        owner: (optional) Owner of namespace, default is `nobody`.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        context: Other configurations for Splunk rest client.\n\n    Raises:\n        binding.HTTPError: HTTP error different from 404, for example 503\n            when KV Store is initializing and not ready to serve requests.\n        CheckpointerException: If init KV Store checkpointer failed.\n    \"\"\"\n    try:\n        if not context.get(\"pool_connections\"):\n            context[\"pool_connections\"] = 5\n        if not context.get(\"pool_maxsize\"):\n            context[\"pool_maxsize\"] = 5\n        self._collection_data = _utils.get_collection_data(\n            collection_name,\n            session_key,\n            app,\n            owner,\n            scheme,\n            host,\n            port,\n            {\"state\": \"string\"},\n            **context,\n        )\n    except KeyError:\n        raise CheckpointerException(\"Get KV Store checkpointer failed.\")\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.batch_update","title":"<code>batch_update(states)</code>","text":"<p>Updates multiple documents.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>Iterable[Dict[str, Any]]</code> <p>Iterable that contains documents to update. Document should be a dict with at least \u201cstate\u201d key.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>when an error occurred in Splunk, for example, when Splunk is restarting and KV Store is not yet initialized.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef batch_update(self, states: Iterable[Dict[str, Any]]) -&gt; None:\n\"\"\"Updates multiple documents.\n\n    Arguments:\n        states: Iterable that contains documents to update. Document should\n            be a dict with at least \"state\" key.\n\n    Raises:\n        binding.HTTPError: when an error occurred in Splunk, for example,\n            when Splunk is restarting and KV Store is not yet initialized.\n    \"\"\"\n    for state in states:\n        state[\"state\"] = json.dumps(state[\"state\"])\n    self._collection_data.batch_save(*states)\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.delete","title":"<code>delete(key)</code>","text":"<p>Deletes document with an id that equals to <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p><code>id</code> of the document to delete.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>When an error occurred in Splunk (not 404 code), can be 503 code, when Splunk is restarting and KV Store is not yet initialized.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef delete(self, key: str) -&gt; None:\n\"\"\"Deletes document with an id that equals to `key`.\n\n    Arguments:\n        key: `id` of the document to delete.\n\n    Raises:\n        binding.HTTPError: When an error occurred in Splunk (not 404 code),\n            can be 503 code, when Splunk is restarting and KV Store is not\n            yet initialized.\n    \"\"\"\n    try:\n        self._collection_data.delete_by_id(key)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            logging.error(f\"Delete checkpoint failed: {traceback.format_exc()}.\")\n            raise\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.get","title":"<code>get(key)</code>","text":"<p>Gets document with an id that equals to <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p><code>id</code> of the document to get.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>When an error occurred in Splunk (not 404 code), can be 503 code, when Splunk is restarting and KV Store is not yet initialized.</p> <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Document data under <code>key</code> or <code>None</code> in case of no data.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef get(self, key: str) -&gt; Optional[Any]:\n\"\"\"Gets document with an id that equals to `key`.\n\n    Arguments:\n        key: `id` of the document to get.\n\n    Raises:\n        binding.HTTPError: When an error occurred in Splunk (not 404 code),\n            can be 503 code, when Splunk is restarting and KV Store is not\n            yet initialized.\n\n    Returns:\n        Document data under `key` or `None` in case of no data.\n    \"\"\"\n    try:\n        record = self._collection_data.query_by_id(key)\n    except binding.HTTPError as e:\n        if e.status != 404:\n            logging.error(f\"Get checkpoint failed: {traceback.format_exc()}.\")\n            raise\n        return None\n    return json.loads(record[\"state\"])\n</code></pre>"},{"location":"modular_input/checkpointer/#solnlib.modular_input.checkpointer.KVStoreCheckpointer.update","title":"<code>update(key, state)</code>","text":"<p>Updates document with an id that equals to <code>key</code> and <code>state</code> as document data.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p><code>id</code> of the document to update.</p> required <code>state</code> <code>Any</code> <p>Document data to update. It can be integer, string, or a dict, or anything that can be an argument to <code>json.dumps</code>.</p> required <p>Raises:</p> Type Description <code>binding.HTTPError</code> <p>when an error occurred in Splunk, for example, when Splunk is restarting and KV Store is not yet initialized.</p> Source code in <code>solnlib/modular_input/checkpointer.py</code> <pre><code>@utils.retry(exceptions=[binding.HTTPError])\ndef update(self, key: str, state: Any) -&gt; None:\n\"\"\"Updates document with an id that equals to `key` and `state` as\n    document data.\n\n    Arguments:\n        key: `id` of the document to update.\n        state: Document data to update. It can be integer, string,\n            or a dict, or anything that can be an argument to `json.dumps`.\n\n    Raises:\n        binding.HTTPError: when an error occurred in Splunk, for example,\n            when Splunk is restarting and KV Store is not yet initialized.\n    \"\"\"\n    record = {\"_key\": key, \"state\": json.dumps(state)}\n    self._collection_data.batch_save(record)\n</code></pre>"},{"location":"modular_input/event/","title":"event.py","text":"<p>This module provides Splunk modular input event encapsulation.</p>"},{"location":"modular_input/event/#solnlib.modular_input.event.__all__","title":"<code>__all__ = ['EventException', 'XMLEvent', 'HECEvent']</code>  <code>module-attribute</code>","text":""},{"location":"modular_input/event/#solnlib.modular_input.event.Event","title":"<code>Event</code>","text":"<p>Base class of modular input event.</p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>class Event:\n\"\"\"Base class of modular input event.\"\"\"\n\n    def __init__(\n        self,\n        data: dict,\n        time: float = None,\n        index: str = None,\n        host: str = None,\n        source: str = None,\n        sourcetype: str = None,\n        fields: dict = None,\n        stanza: str = None,\n        unbroken: bool = False,\n        done: bool = False,\n    ):\n\"\"\"Modular input event.\n\n        Arguments:\n            data: Event data.\n            time: (optional) Event timestamp, default is None.\n            index: (optional) The index event will be written to, default is None.\n            host: (optional) Event host, default is None.\n            source: (optional) Event source, default is None.\n            sourcetype: (optional) Event sourcetype, default is None.\n            fields: (optional) Event fields, default is None.\n            stanza: (optional) Event stanza name, default is None.\n            unbroken: (optional) Event unbroken flag, default is False.\n            done: (optional) The last unbroken event, default is False.\n\n        Examples:\n           &gt;&gt;&gt; event = Event(\n           &gt;&gt;&gt;     data='This is a test data.',\n           &gt;&gt;&gt;     time=1372274622.493,\n           &gt;&gt;&gt;     index='main',\n           &gt;&gt;&gt;     host='localhost',\n           &gt;&gt;&gt;     source='Splunk',\n           &gt;&gt;&gt;     sourcetype='misc',\n           &gt;&gt;&gt;     fields= {'Cloud':'AWS','region': 'us-west-1'},\n           &gt;&gt;&gt;     stanza='test_scheme://test',\n           &gt;&gt;&gt;     unbroken=True,\n           &gt;&gt;&gt;     done=True)\n        \"\"\"\n\n        self._data = data\n        self._time = \"%.3f\" % time if time else None\n        self._index = index\n        self._host = host\n        self._source = source\n        self._sourcetype = sourcetype\n        if fields:\n            self._fields = fields\n        self._stanza = stanza\n        if not unbroken and done:\n            raise EventException('Invalid combination of \"unbroken\" and \"done\".')\n        self._unbroken = unbroken\n        self._done = done\n\n    def __str__(self):\n        event = {\n            \"data\": self._data,\n            \"time\": float(self._time) if self._time else self._time,\n            \"index\": self._index,\n            \"host\": self._host,\n            \"source\": self._source,\n            \"sourcetype\": self._sourcetype,\n            \"stanza\": self._stanza,\n            \"unbroken\": self._unbroken,\n            \"done\": self._done,\n        }\n\n        if hasattr(self, \"_fields\"):\n            event[\"fields\"] = self._fields\n\n        return json.dumps(event)\n\n    @classmethod\n    def format_events(cls, events: List) -&gt; List:\n\"\"\"Format events to list of string.\n\n        Arguments:\n            events: List of events to format.\n\n        Returns:\n            List of formatted events string.\n        \"\"\"\n\n        raise EventException('Unimplemented \"format_events\".')\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.Event.__init__","title":"<code>__init__(data, time=None, index=None, host=None, source=None, sourcetype=None, fields=None, stanza=None, unbroken=False, done=False)</code>","text":"<p>Modular input event.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Event data.</p> required <code>time</code> <code>float</code> <p>(optional) Event timestamp, default is None.</p> <code>None</code> <code>index</code> <code>str</code> <p>(optional) The index event will be written to, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) Event host, default is None.</p> <code>None</code> <code>source</code> <code>str</code> <p>(optional) Event source, default is None.</p> <code>None</code> <code>sourcetype</code> <code>str</code> <p>(optional) Event sourcetype, default is None.</p> <code>None</code> <code>fields</code> <code>dict</code> <p>(optional) Event fields, default is None.</p> <code>None</code> <code>stanza</code> <code>str</code> <p>(optional) Event stanza name, default is None.</p> <code>None</code> <code>unbroken</code> <code>bool</code> <p>(optional) Event unbroken flag, default is False.</p> <code>False</code> <code>done</code> <code>bool</code> <p>(optional) The last unbroken event, default is False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; event = Event(\n&gt;&gt;&gt;     data='This is a test data.',\n&gt;&gt;&gt;     time=1372274622.493,\n&gt;&gt;&gt;     index='main',\n&gt;&gt;&gt;     host='localhost',\n&gt;&gt;&gt;     source='Splunk',\n&gt;&gt;&gt;     sourcetype='misc',\n&gt;&gt;&gt;     fields= {'Cloud':'AWS','region': 'us-west-1'},\n&gt;&gt;&gt;     stanza='test_scheme://test',\n&gt;&gt;&gt;     unbroken=True,\n&gt;&gt;&gt;     done=True)\n</code></pre> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>def __init__(\n    self,\n    data: dict,\n    time: float = None,\n    index: str = None,\n    host: str = None,\n    source: str = None,\n    sourcetype: str = None,\n    fields: dict = None,\n    stanza: str = None,\n    unbroken: bool = False,\n    done: bool = False,\n):\n\"\"\"Modular input event.\n\n    Arguments:\n        data: Event data.\n        time: (optional) Event timestamp, default is None.\n        index: (optional) The index event will be written to, default is None.\n        host: (optional) Event host, default is None.\n        source: (optional) Event source, default is None.\n        sourcetype: (optional) Event sourcetype, default is None.\n        fields: (optional) Event fields, default is None.\n        stanza: (optional) Event stanza name, default is None.\n        unbroken: (optional) Event unbroken flag, default is False.\n        done: (optional) The last unbroken event, default is False.\n\n    Examples:\n       &gt;&gt;&gt; event = Event(\n       &gt;&gt;&gt;     data='This is a test data.',\n       &gt;&gt;&gt;     time=1372274622.493,\n       &gt;&gt;&gt;     index='main',\n       &gt;&gt;&gt;     host='localhost',\n       &gt;&gt;&gt;     source='Splunk',\n       &gt;&gt;&gt;     sourcetype='misc',\n       &gt;&gt;&gt;     fields= {'Cloud':'AWS','region': 'us-west-1'},\n       &gt;&gt;&gt;     stanza='test_scheme://test',\n       &gt;&gt;&gt;     unbroken=True,\n       &gt;&gt;&gt;     done=True)\n    \"\"\"\n\n    self._data = data\n    self._time = \"%.3f\" % time if time else None\n    self._index = index\n    self._host = host\n    self._source = source\n    self._sourcetype = sourcetype\n    if fields:\n        self._fields = fields\n    self._stanza = stanza\n    if not unbroken and done:\n        raise EventException('Invalid combination of \"unbroken\" and \"done\".')\n    self._unbroken = unbroken\n    self._done = done\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.Event.__str__","title":"<code>__str__()</code>","text":"Source code in <code>solnlib/modular_input/event.py</code> <pre><code>def __str__(self):\n    event = {\n        \"data\": self._data,\n        \"time\": float(self._time) if self._time else self._time,\n        \"index\": self._index,\n        \"host\": self._host,\n        \"source\": self._source,\n        \"sourcetype\": self._sourcetype,\n        \"stanza\": self._stanza,\n        \"unbroken\": self._unbroken,\n        \"done\": self._done,\n    }\n\n    if hasattr(self, \"_fields\"):\n        event[\"fields\"] = self._fields\n\n    return json.dumps(event)\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.Event.format_events","title":"<code>format_events(events)</code>  <code>classmethod</code>","text":"<p>Format events to list of string.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>List</code> <p>List of events to format.</p> required <p>Returns:</p> Type Description <code>List</code> <p>List of formatted events string.</p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>@classmethod\ndef format_events(cls, events: List) -&gt; List:\n\"\"\"Format events to list of string.\n\n    Arguments:\n        events: List of events to format.\n\n    Returns:\n        List of formatted events string.\n    \"\"\"\n\n    raise EventException('Unimplemented \"format_events\".')\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.EventException","title":"<code>EventException</code>","text":"<p>         Bases: <code>Exception</code></p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>class EventException(Exception):\n    pass\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.HECEvent","title":"<code>HECEvent</code>","text":"<p>         Bases: <code>Event</code></p> <p>HEC event.</p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>class HECEvent(Event):\n\"\"\"HEC event.\"\"\"\n\n    max_hec_event_length = 1000000\n\n    def _to_hec(self, event_field):\n        event = {}\n        event[event_field] = self._data\n        if self._time:\n            event[\"time\"] = float(self._time)\n        if self._index:\n            event[\"index\"] = self._index\n        if self._host:\n            event[\"host\"] = self._host\n        if self._source:\n            event[\"source\"] = self._source\n        if self._sourcetype:\n            event[\"sourcetype\"] = self._sourcetype\n        if hasattr(self, \"_fields\"):\n            event[\"fields\"] = self._fields\n\n        return json.dumps(event, ensure_ascii=False)\n\n    @classmethod\n    def format_events(cls, events: List, event_field: str = \"event\") -&gt; List:\n\"\"\"Format events to list of string.\n\n        Arguments:\n            events: List of events to format.\n            event_field: Event field.\n\n        Returns:\n            List of formatted events string, example::\n\n                [\n                    '{\"index\": \"main\", ... \"event\": {\"kk\": [1, 2, 3]}}\\\\n\n                    {\"index\": \"main\", ... \"event\": {\"kk\": [3, 2, 3]}}',\n                '...'\n                ]\n        \"\"\"\n\n        size = 0\n        new_events, batched_events = [], []\n        events = [event._to_hec(event_field) for event in events]\n        for event in events:\n            new_length = size + len(event) + len(batched_events) - 1\n            if new_length &gt;= cls.max_hec_event_length:\n                if batched_events:\n                    new_events.append(\"\\n\".join(batched_events))\n                del batched_events[:]\n                size = 0\n\n            batched_events.append(event)\n            size = size + len(event)\n        if batched_events:\n            new_events.append(\"\\n\".join(batched_events))\n\n        return new_events\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.HECEvent.max_hec_event_length","title":"<code>max_hec_event_length = 1000000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event/#solnlib.modular_input.event.HECEvent.format_events","title":"<code>format_events(events, event_field='event')</code>  <code>classmethod</code>","text":"<p>Format events to list of string.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>List</code> <p>List of events to format.</p> required <code>event_field</code> <code>str</code> <p>Event field.</p> <code>'event'</code> <p>Returns:</p> Type Description <code>List</code> <p>List of formatted events string, example::</p> <p>[     \u2018{\u201cindex\u201d: \u201cmain\u201d, \u2026 \u201cevent\u201d: {\u201ckk\u201d: [1, 2, 3]}}\\n     {\u201cindex\u201d: \u201cmain\u201d, \u2026 \u201cevent\u201d: {\u201ckk\u201d: [3, 2, 3]}}\u2019, \u2018\u2026\u2019 ]</p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>@classmethod\ndef format_events(cls, events: List, event_field: str = \"event\") -&gt; List:\n\"\"\"Format events to list of string.\n\n    Arguments:\n        events: List of events to format.\n        event_field: Event field.\n\n    Returns:\n        List of formatted events string, example::\n\n            [\n                '{\"index\": \"main\", ... \"event\": {\"kk\": [1, 2, 3]}}\\\\n\n                {\"index\": \"main\", ... \"event\": {\"kk\": [3, 2, 3]}}',\n            '...'\n            ]\n    \"\"\"\n\n    size = 0\n    new_events, batched_events = [], []\n    events = [event._to_hec(event_field) for event in events]\n    for event in events:\n        new_length = size + len(event) + len(batched_events) - 1\n        if new_length &gt;= cls.max_hec_event_length:\n            if batched_events:\n                new_events.append(\"\\n\".join(batched_events))\n            del batched_events[:]\n            size = 0\n\n        batched_events.append(event)\n        size = size + len(event)\n    if batched_events:\n        new_events.append(\"\\n\".join(batched_events))\n\n    return new_events\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.XMLEvent","title":"<code>XMLEvent</code>","text":"<p>         Bases: <code>Event</code></p> <p>XML event.</p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>class XMLEvent(Event):\n\"\"\"XML event.\"\"\"\n\n    def _to_xml(self):\n        _event = ET.Element(\"event\")\n        if self._stanza:\n            _event.set(\"stanza\", self._stanza)\n        if self._unbroken:\n            _event.set(\"unbroken\", str(int(self._unbroken)))\n\n        if self._time:\n            ET.SubElement(_event, \"time\").text = self._time\n\n        sub_elements = [\n            (\"index\", self._index),\n            (\"host\", self._host),\n            (\"source\", self._source),\n            (\"sourcetype\", self._sourcetype),\n        ]\n        for node, value in sub_elements:\n            if value:\n                ET.SubElement(_event, node).text = value\n\n        if isinstance(self._data, str):\n            ET.SubElement(_event, \"data\").text = self._data\n        else:\n            ET.SubElement(_event, \"data\").text = json.dumps(self._data)\n\n        if self._done:\n            ET.SubElement(_event, \"done\")\n\n        return _event\n\n    @classmethod\n    def format_events(cls, events: List) -&gt; List:\n\"\"\"Format events to list of string.\n\n        Arguments:\n            events: List of events to format.\n\n        Returns:\n            List of formatted events string, example::\n\n                [\n                    '&lt;stream&gt;\n                    &lt;event stanza=\"test_scheme://test\" unbroken=\"1\"&gt;\n                    &lt;time&gt;1459919070.994&lt;/time&gt;\n                    &lt;index&gt;main&lt;/index&gt;\n                    &lt;host&gt;localhost&lt;/host&gt;\n                    &lt;source&gt;test&lt;/source&gt;\n                    &lt;sourcetype&gt;test&lt;/sourcetype&gt;\n                    &lt;data&gt;{\"kk\": [1, 2, 3]}&lt;/data&gt;\n                    &lt;done /&gt;\n                    &lt;/event&gt;\n                    &lt;event stanza=\"test_scheme://test\" unbroken=\"1\"&gt;\n                    &lt;time&gt;1459919082.961&lt;/time&gt;\n                    &lt;index&gt;main&lt;/index&gt;\n                    &lt;host&gt;localhost&lt;/host&gt;\n                    &lt;source&gt;test&lt;/source&gt;\n                    &lt;sourcetype&gt;test&lt;/sourcetype&gt;\n                    &lt;data&gt;{\"kk\": [3, 2, 3]}&lt;/data&gt;\n                    &lt;done /&gt;\n                    &lt;/event&gt;\n                    &lt;/stream&gt;'\n                ]\n        \"\"\"\n\n        stream = ET.Element(\"stream\")\n        for event in events:\n            stream.append(event._to_xml())\n\n        return [\n            defused_et.tostring(stream, encoding=\"utf-8\", method=\"xml\").decode(\"utf-8\")\n        ]\n</code></pre>"},{"location":"modular_input/event/#solnlib.modular_input.event.XMLEvent.format_events","title":"<code>format_events(events)</code>  <code>classmethod</code>","text":"<p>Format events to list of string.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>List</code> <p>List of events to format.</p> required <p>Returns:</p> Type Description <code>List</code> <p>List of formatted events string, example::</p> <p>[     \u2018 1459919070.994 main localhost test test {\u201ckk\u201d: [1, 2, 3]} 1459919082.961 main localhost test test {\u201ckk\u201d: [3, 2, 3]} \u2019 ]</p> Source code in <code>solnlib/modular_input/event.py</code> <pre><code>@classmethod\ndef format_events(cls, events: List) -&gt; List:\n\"\"\"Format events to list of string.\n\n    Arguments:\n        events: List of events to format.\n\n    Returns:\n        List of formatted events string, example::\n\n            [\n                '&lt;stream&gt;\n                &lt;event stanza=\"test_scheme://test\" unbroken=\"1\"&gt;\n                &lt;time&gt;1459919070.994&lt;/time&gt;\n                &lt;index&gt;main&lt;/index&gt;\n                &lt;host&gt;localhost&lt;/host&gt;\n                &lt;source&gt;test&lt;/source&gt;\n                &lt;sourcetype&gt;test&lt;/sourcetype&gt;\n                &lt;data&gt;{\"kk\": [1, 2, 3]}&lt;/data&gt;\n                &lt;done /&gt;\n                &lt;/event&gt;\n                &lt;event stanza=\"test_scheme://test\" unbroken=\"1\"&gt;\n                &lt;time&gt;1459919082.961&lt;/time&gt;\n                &lt;index&gt;main&lt;/index&gt;\n                &lt;host&gt;localhost&lt;/host&gt;\n                &lt;source&gt;test&lt;/source&gt;\n                &lt;sourcetype&gt;test&lt;/sourcetype&gt;\n                &lt;data&gt;{\"kk\": [3, 2, 3]}&lt;/data&gt;\n                &lt;done /&gt;\n                &lt;/event&gt;\n                &lt;/stream&gt;'\n            ]\n    \"\"\"\n\n    stream = ET.Element(\"stream\")\n    for event in events:\n        stream.append(event._to_xml())\n\n    return [\n        defused_et.tostring(stream, encoding=\"utf-8\", method=\"xml\").decode(\"utf-8\")\n    ]\n</code></pre>"},{"location":"modular_input/event_writer/","title":"event_writer.py","text":"<p>This module provides two kinds of event writers (ClassicEventWriter, HECEventWriter) to write Splunk modular input events.</p>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.__all__","title":"<code>__all__ = ['ClassicEventWriter', 'HECEventWriter']</code>  <code>module-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.deprecation_msg","title":"<code>deprecation_msg = \"Function 'create_from_token' is deprecated and incompatible with 'global_settings_schema=True'. Use 'create_from_token_with_session_key' instead.\"</code>  <code>module-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter","title":"<code>ClassicEventWriter</code>","text":"<p>         Bases: <code>EventWriter</code></p> <p>Classic event writer.</p> <p>Use sys.stdout as the output.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.modular_input import event_writer\n&gt;&gt;&gt; ew = event_writer.ClassicEventWriter()\n&gt;&gt;&gt; ew.write_events([event1, event2])\n</code></pre> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>class ClassicEventWriter(EventWriter):\n\"\"\"Classic event writer.\n\n    Use sys.stdout as the output.\n\n    Examples:\n        &gt;&gt;&gt; from solnlib.modular_input import event_writer\n        &gt;&gt;&gt; ew = event_writer.ClassicEventWriter()\n        &gt;&gt;&gt; ew.write_events([event1, event2])\n    \"\"\"\n\n    description = \"ClassicEventWriter\"\n\n    def __init__(self, lock: Union[threading.Lock, multiprocessing.Lock] = None):\n\"\"\"Initializes ClassicEventWriter.\n\n        Arguments:\n            lock: (optional) lock to exclusively access stdout.\n                by default, it is None and it will use threading safe lock.\n                if user would like to make the lock multiple-process safe, user should\n                pass in multiprocessing.Lock() instead\n        \"\"\"\n        if lock is None:\n            self._lock = threading.Lock()\n        else:\n            self._lock = lock\n\n    def create_event(\n        self,\n        data: dict,\n        time: float = None,\n        index: str = None,\n        host: str = None,\n        source: str = None,\n        sourcetype: str = None,\n        fields: dict = None,\n        stanza: str = None,\n        unbroken: bool = False,\n        done: bool = False,\n    ):\n\"\"\"Create a new XMLEvent object.\"\"\"\n\n        return XMLEvent(\n            data,\n            time=time,\n            index=index,\n            host=host,\n            source=source,\n            sourcetype=sourcetype,\n            stanza=stanza,\n            unbroken=unbroken,\n            done=done,\n        )\n\n    def write_events(self, events):\n        if not events:\n            return\n\n        stdout = sys.stdout\n\n        data = \"\".join([event for event in XMLEvent.format_events(events)])\n        with self._lock:\n            stdout.write(data)\n            stdout.flush()\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.description","title":"<code>description = 'ClassicEventWriter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.__init__","title":"<code>__init__(lock=None)</code>","text":"<p>Initializes ClassicEventWriter.</p> <p>Parameters:</p> Name Type Description Default <code>lock</code> <code>Union[threading.Lock, multiprocessing.Lock]</code> <p>(optional) lock to exclusively access stdout. by default, it is None and it will use threading safe lock. if user would like to make the lock multiple-process safe, user should pass in multiprocessing.Lock() instead</p> <code>None</code> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>def __init__(self, lock: Union[threading.Lock, multiprocessing.Lock] = None):\n\"\"\"Initializes ClassicEventWriter.\n\n    Arguments:\n        lock: (optional) lock to exclusively access stdout.\n            by default, it is None and it will use threading safe lock.\n            if user would like to make the lock multiple-process safe, user should\n            pass in multiprocessing.Lock() instead\n    \"\"\"\n    if lock is None:\n        self._lock = threading.Lock()\n    else:\n        self._lock = lock\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.create_event","title":"<code>create_event(data, time=None, index=None, host=None, source=None, sourcetype=None, fields=None, stanza=None, unbroken=False, done=False)</code>","text":"<p>Create a new XMLEvent object.</p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>def create_event(\n    self,\n    data: dict,\n    time: float = None,\n    index: str = None,\n    host: str = None,\n    source: str = None,\n    sourcetype: str = None,\n    fields: dict = None,\n    stanza: str = None,\n    unbroken: bool = False,\n    done: bool = False,\n):\n\"\"\"Create a new XMLEvent object.\"\"\"\n\n    return XMLEvent(\n        data,\n        time=time,\n        index=index,\n        host=host,\n        source=source,\n        sourcetype=sourcetype,\n        stanza=stanza,\n        unbroken=unbroken,\n        done=done,\n    )\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.ClassicEventWriter.write_events","title":"<code>write_events(events)</code>","text":"Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>def write_events(self, events):\n    if not events:\n        return\n\n    stdout = sys.stdout\n\n    data = \"\".join([event for event in XMLEvent.format_events(events)])\n    with self._lock:\n        stdout.write(data)\n        stdout.flush()\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter","title":"<code>EventWriter</code>","text":"<p>Base class of event writer.</p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>class EventWriter(metaclass=ABCMeta):\n\"\"\"Base class of event writer.\"\"\"\n\n    description = \"EventWriter\"\n\n    @abstractmethod\n    def create_event(\n        self,\n        data: dict,\n        time: float = None,\n        index: str = None,\n        host: str = None,\n        source: str = None,\n        sourcetype: str = None,\n        fields: dict = None,\n        stanza: str = None,\n        unbroken: bool = False,\n        done: bool = False,\n    ) -&gt; Union[XMLEvent, HECEvent]:\n\"\"\"Create a new event.\n\n        Arguments:\n            data: Event data.\n            time: (optional) Event timestamp, default is None.\n            index: (optional) The index event will be written to, default is None.\n            host: (optional) Event host, default is None.\n            source: (optional) Event source, default is None.\n            sourcetype: (optional) Event sourcetype, default is None.\n            fields: (optional) Event fields, default is None.\n            stanza: (optional) Event stanza name, default is None.\n            unbroken: (optional) Event unbroken flag, default is False.\n                It is only meaningful when for XMLEvent when using ClassicEventWriter.\n            done: (optional) The last unbroken event, default is False.\n                It is only meaningful when for XMLEvent when using ClassicEventWriter.\n\n        Examples:\n           &gt;&gt;&gt; ew = event_writer.HECEventWriter(...)\n           &gt;&gt;&gt; event = ew.create_event(\n           &gt;&gt;&gt;     data='This is a test data.',\n           &gt;&gt;&gt;     time='%.3f' % 1372274622.493,\n           &gt;&gt;&gt;     index='main',\n           &gt;&gt;&gt;     host='localhost',\n           &gt;&gt;&gt;     source='Splunk',\n           &gt;&gt;&gt;     sourcetype='misc',\n           &gt;&gt;&gt;     fields={'accountid': '603514901691', 'Cloud': u'AWS'},\n           &gt;&gt;&gt;     stanza='test_scheme://test',\n           &gt;&gt;&gt;     unbroken=True,\n           &gt;&gt;&gt;     done=True)\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def write_events(self, events: List):\n\"\"\"Write events.\n\n        Arguments:\n            events: List of events to write.\n\n        Examples:\n           &gt;&gt;&gt; from solnlib.modular_input import event_writer\n           &gt;&gt;&gt; ew = event_writer.EventWriter(...)\n           &gt;&gt;&gt; ew.write_events([event1, event2])\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter.description","title":"<code>description = 'EventWriter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter.create_event","title":"<code>create_event(data, time=None, index=None, host=None, source=None, sourcetype=None, fields=None, stanza=None, unbroken=False, done=False)</code>  <code>abstractmethod</code>","text":"<p>Create a new event.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Event data.</p> required <code>time</code> <code>float</code> <p>(optional) Event timestamp, default is None.</p> <code>None</code> <code>index</code> <code>str</code> <p>(optional) The index event will be written to, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) Event host, default is None.</p> <code>None</code> <code>source</code> <code>str</code> <p>(optional) Event source, default is None.</p> <code>None</code> <code>sourcetype</code> <code>str</code> <p>(optional) Event sourcetype, default is None.</p> <code>None</code> <code>fields</code> <code>dict</code> <p>(optional) Event fields, default is None.</p> <code>None</code> <code>stanza</code> <code>str</code> <p>(optional) Event stanza name, default is None.</p> <code>None</code> <code>unbroken</code> <code>bool</code> <p>(optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter.</p> <code>False</code> <code>done</code> <code>bool</code> <p>(optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ew = event_writer.HECEventWriter(...)\n&gt;&gt;&gt; event = ew.create_event(\n&gt;&gt;&gt;     data='This is a test data.',\n&gt;&gt;&gt;     time='%.3f' % 1372274622.493,\n&gt;&gt;&gt;     index='main',\n&gt;&gt;&gt;     host='localhost',\n&gt;&gt;&gt;     source='Splunk',\n&gt;&gt;&gt;     sourcetype='misc',\n&gt;&gt;&gt;     fields={'accountid': '603514901691', 'Cloud': u'AWS'},\n&gt;&gt;&gt;     stanza='test_scheme://test',\n&gt;&gt;&gt;     unbroken=True,\n&gt;&gt;&gt;     done=True)\n</code></pre> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>@abstractmethod\ndef create_event(\n    self,\n    data: dict,\n    time: float = None,\n    index: str = None,\n    host: str = None,\n    source: str = None,\n    sourcetype: str = None,\n    fields: dict = None,\n    stanza: str = None,\n    unbroken: bool = False,\n    done: bool = False,\n) -&gt; Union[XMLEvent, HECEvent]:\n\"\"\"Create a new event.\n\n    Arguments:\n        data: Event data.\n        time: (optional) Event timestamp, default is None.\n        index: (optional) The index event will be written to, default is None.\n        host: (optional) Event host, default is None.\n        source: (optional) Event source, default is None.\n        sourcetype: (optional) Event sourcetype, default is None.\n        fields: (optional) Event fields, default is None.\n        stanza: (optional) Event stanza name, default is None.\n        unbroken: (optional) Event unbroken flag, default is False.\n            It is only meaningful when for XMLEvent when using ClassicEventWriter.\n        done: (optional) The last unbroken event, default is False.\n            It is only meaningful when for XMLEvent when using ClassicEventWriter.\n\n    Examples:\n       &gt;&gt;&gt; ew = event_writer.HECEventWriter(...)\n       &gt;&gt;&gt; event = ew.create_event(\n       &gt;&gt;&gt;     data='This is a test data.',\n       &gt;&gt;&gt;     time='%.3f' % 1372274622.493,\n       &gt;&gt;&gt;     index='main',\n       &gt;&gt;&gt;     host='localhost',\n       &gt;&gt;&gt;     source='Splunk',\n       &gt;&gt;&gt;     sourcetype='misc',\n       &gt;&gt;&gt;     fields={'accountid': '603514901691', 'Cloud': u'AWS'},\n       &gt;&gt;&gt;     stanza='test_scheme://test',\n       &gt;&gt;&gt;     unbroken=True,\n       &gt;&gt;&gt;     done=True)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.EventWriter.write_events","title":"<code>write_events(events)</code>  <code>abstractmethod</code>","text":"<p>Write events.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>List</code> <p>List of events to write.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.modular_input import event_writer\n&gt;&gt;&gt; ew = event_writer.EventWriter(...)\n&gt;&gt;&gt; ew.write_events([event1, event2])\n</code></pre> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>@abstractmethod\ndef write_events(self, events: List):\n\"\"\"Write events.\n\n    Arguments:\n        events: List of events to write.\n\n    Examples:\n       &gt;&gt;&gt; from solnlib.modular_input import event_writer\n       &gt;&gt;&gt; ew = event_writer.EventWriter(...)\n       &gt;&gt;&gt; ew.write_events([event1, event2])\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.FunctionDeprecated","title":"<code>FunctionDeprecated</code>","text":"<p>         Bases: <code>Exception</code></p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>class FunctionDeprecated(Exception):\n    pass\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter","title":"<code>HECEventWriter</code>","text":"<p>         Bases: <code>EventWriter</code></p> <p>HEC event writer.</p> <p>Use Splunk HEC as the output.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from solnlib.modular_input import event_writer\n&gt;&gt;&gt; ew = event_writer.HECEventWriter(hec_input_name, session_key)\n&gt;&gt;&gt; ew.write_events([event1, event2])\n</code></pre> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>class HECEventWriter(EventWriter):\n\"\"\"HEC event writer.\n\n    Use Splunk HEC as the output.\n\n    Examples:\n        &gt;&gt;&gt; from solnlib.modular_input import event_writer\n        &gt;&gt;&gt; ew = event_writer.HECEventWriter(hec_input_name, session_key)\n        &gt;&gt;&gt; ew.write_events([event1, event2])\n    \"\"\"\n\n    WRITE_EVENT_RETRIES = 5\n    HTTP_INPUT_CONFIG_ENDPOINT = \"/servicesNS/nobody/splunk_httpinput/data/inputs/http\"\n    HTTP_EVENT_COLLECTOR_ENDPOINT = \"/services/collector\"\n    TOO_MANY_REQUESTS = 429  # we exceeded rate limit\n    SERVICE_UNAVAILABLE = 503  # remote service is temporary unavailable\n\n    description = \"HECEventWriter\"\n\n    headers = [(\"Content-Type\", \"application/json\")]\n\n    def __init__(\n        self,\n        hec_input_name: str,\n        session_key: str,\n        scheme: str = None,\n        host: str = None,\n        port: int = None,\n        hec_uri: str = None,\n        hec_token: str = None,\n        global_settings_schema: bool = True,\n        logger: logging.Logger = None,\n        **context: dict\n    ):\n\"\"\"Initializes HECEventWriter.\n\n        Arguments:\n            hec_input_name: Splunk HEC input name.\n            session_key: Splunk access token.\n            scheme: (optional) The access scheme, default is None.\n            host: (optional) The host name, default is None.\n            port: (optional) The port number, default is None.\n            hec_uri: (optional) If hec_uri and hec_token are provided, they will\n                higher precedence than hec_input_name.\n            hec_token: (optional) HEC token.\n            global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n            logger: Logger object.\n            context: Other configurations for Splunk rest client.\n        \"\"\"\n        super().__init__()\n        self._session_key = session_key\n        if logger:\n            self.logger = logger\n        else:\n            self.logger = logging\n\n        if hec_uri and hec_token:\n            scheme, host, hec_port = utils.extract_http_scheme_host_port(hec_uri)\n        else:\n            if not all([scheme, host, port]):\n                scheme, host, port = get_splunkd_access_info(self._session_key)\n            hec_port, hec_token = self._get_hec_config(\n                hec_input_name, session_key, scheme, host, port, **context\n            )\n\n        if global_settings_schema:\n            scheme = get_scheme_from_hec_settings(self._session_key)\n\n        if not context.get(\"pool_connections\"):\n            context[\"pool_connections\"] = 10\n\n        if not context.get(\"pool_maxsize\"):\n            context[\"pool_maxsize\"] = 10\n\n        self._rest_client = rest_client.SplunkRestClient(\n            hec_token, app=\"-\", scheme=scheme, host=host, port=hec_port, **context\n        )\n\n    @staticmethod\n    def create_from_token(\n        hec_uri: str,\n        hec_token: str,\n        global_settings_schema: bool = False,\n        **context: dict\n    ) -&gt; \"HECEventWriter\":\n\"\"\"Given HEC URI and HEC token, create HECEventWriter object. This\n        function simplifies the standalone mode HECEventWriter usage (not in a\n        modinput).\n\n        Arguments:\n            hec_uri: HTTP Event Collector URI, like https://localhost:8088.\n            hec_token: HTTP Event Collector token.\n            global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n            context: Other configurations.\n\n        Returns:\n            Created HECEventWriter.\n        \"\"\"\n\n        warnings.warn(deprecation_msg, DeprecationWarning, stacklevel=2)\n\n        if global_settings_schema:\n            raise FunctionDeprecated(deprecation_msg)\n\n        return HECEventWriter(\n            None,\n            None,\n            None,\n            None,\n            None,\n            hec_uri=hec_uri,\n            hec_token=hec_token,\n            global_settings_schema=global_settings_schema,\n            **context\n        )\n\n    @staticmethod\n    def create_from_input(\n        hec_input_name: str,\n        splunkd_uri: str,\n        session_key: str,\n        global_settings_schema: bool = False,\n        **context: dict\n    ) -&gt; \"HECEventWriter\":\n\"\"\"Given HEC input stanza name, splunkd URI and splunkd session key,\n        create HECEventWriter object. HEC URI and token etc will be discovered\n        from HEC input stanza. When hitting HEC event limit, the underlying\n        code will increase the HEC event limit automatically by calling\n        corresponding REST API against splunkd_uri by using session_key.\n\n        Arguments:\n            hec_input_name: Splunk HEC input name.\n            splunkd_uri: Splunkd URI, like https://localhost:8089\n            session_key: Splunkd access token.\n            global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n            context: Other configurations.\n\n        Returns:\n            Created HECEventWriter.\n        \"\"\"\n\n        scheme, host, port = utils.extract_http_scheme_host_port(splunkd_uri)\n        return HECEventWriter(\n            hec_input_name,\n            session_key,\n            scheme,\n            host,\n            port,\n            global_settings_schema=global_settings_schema,\n            **context\n        )\n\n    @staticmethod\n    def create_from_token_with_session_key(\n        splunkd_uri: str,\n        session_key: str,\n        hec_uri: str,\n        hec_token: str,\n        global_settings_schema: bool = False,\n        **context: dict\n    ) -&gt; \"HECEventWriter\":\n\"\"\"Given Splunkd URI, Splunkd session key, HEC URI and HEC token,\n        create HECEventWriter object. When hitting HEC event limit, the event\n        writer will increase the HEC event limit automatically by calling\n        corresponding REST API against splunkd_uri by using session_key.\n\n        Arguments:\n            splunkd_uri: Splunkd URI, like https://localhost:8089.\n            session_key: Splunkd access token.\n            hec_uri: Http Event Collector URI, like https://localhost:8088.\n            hec_token: Http Event Collector token.\n            global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n            context: Other configurations.\n\n        Returns:\n            Created HECEventWriter.\n        \"\"\"\n\n        scheme, host, port = utils.extract_http_scheme_host_port(splunkd_uri)\n        return HECEventWriter(\n            None,\n            session_key,\n            scheme,\n            host,\n            port,\n            hec_uri=hec_uri,\n            hec_token=hec_token,\n            global_settings_schema=global_settings_schema,\n            **context\n        )\n\n    @retry(exceptions=[binding.HTTPError])\n    def _get_hec_config(\n        self, hec_input_name, session_key, scheme, host, port, **context\n    ):\n        hc = HECConfig(session_key, scheme=scheme, host=host, port=port, **context)\n        settings = hc.get_settings()\n        if utils.is_true(settings.get(\"disabled\")):\n            # Enable HEC input\n            self.logger.info(\"Enabling HEC\")\n            settings[\"disabled\"] = \"0\"\n            settings[\"enableSSL\"] = context.get(\"hec_enablessl\", \"1\")\n            settings[\"port\"] = context.get(\"hec_port\", \"8088\")\n            hc.update_settings(settings)\n\n        hec_input = hc.get_input(hec_input_name)\n        if not hec_input:\n            # Create HEC input\n            self.logger.info(\"Create HEC datainput, name=%s\", hec_input_name)\n            hinput = {\n                \"index\": context.get(\"index\", \"main\"),\n            }\n\n            if context.get(\"sourcetype\"):\n                hinput[\"sourcetype\"] = context[\"sourcetype\"]\n\n            if context.get(\"token\"):\n                hinput[\"token\"] = context[\"token\"]\n\n            if context.get(\"source\"):\n                hinput[\"source\"] = context[\"source\"]\n\n            if context.get(\"host\"):\n                hinput[\"host\"] = context[\"host\"]\n\n            hec_input = hc.create_input(hec_input_name, hinput)\n\n        limits = hc.get_limits()\n        HECEvent.max_hec_event_length = int(limits.get(\"max_content_length\", 1000000))\n\n        return settings[\"port\"], hec_input[\"token\"]\n\n    def create_event(\n        self,\n        data: dict,\n        time: float = None,\n        index: str = None,\n        host: str = None,\n        source: str = None,\n        sourcetype: str = None,\n        fields: dict = None,\n        stanza: str = None,\n        unbroken: bool = False,\n        done: bool = False,\n    ) -&gt; HECEvent:\n\"\"\"Create a new HECEvent object.\n\n        Arguments:\n            data: Event data.\n            time: (optional) Event timestamp, default is None.\n            index: (optional) The index event will be written to, default is None.\n            host: (optional) Event host, default is None.\n            source: (optional) Event source, default is None.\n            sourcetype: (optional) Event sourcetype, default is None.\n            fields: (optional) Event fields, default is None.\n            stanza: (optional) Event stanza name, default is None.\n            unbroken: (optional) Event unbroken flag, default is False.\n                It is only meaningful when for XMLEvent when using ClassicEventWriter.\n            done: (optional) The last unbroken event, default is False.\n                It is only meaningful when for XMLEvent when using ClassicEventWriter.\n\n        Returns:\n            Created HECEvent.\n        \"\"\"\n\n        return HECEvent(\n            data,\n            time=time,\n            index=index,\n            host=host,\n            source=source,\n            sourcetype=sourcetype,\n            fields=fields,\n        )\n\n    def write_events(\n        self,\n        events: List,\n        retries: int = WRITE_EVENT_RETRIES,\n        event_field: str = \"event\",\n    ):\n\"\"\"Write events to index in bulk.\n\n        Arguments:\n            events: List of events.\n            retries: Number of retries for writing events to index.\n            event_field: Event field.\n        \"\"\"\n        if not events:\n            return\n\n        last_ex = None\n        for event in HECEvent.format_events(events, event_field):\n            for i in range(retries):\n                try:\n                    self._rest_client.post(\n                        self.HTTP_EVENT_COLLECTOR_ENDPOINT,\n                        body=event.encode(\"utf-8\"),\n                        headers=self.headers,\n                    )\n                except binding.HTTPError as e:\n                    self.logger.warn(\n                        \"Write events through HEC failed. Status=%s\", e.status\n                    )\n                    last_ex = e\n                    if e.status in [self.TOO_MANY_REQUESTS, self.SERVICE_UNAVAILABLE]:\n                        # wait time for n retries: 10, 20, 40, 80, 80, 80, 80, ....\n                        sleep_time = min(((2 ** (i + 1)) * 5), 80)\n                        if i &lt; retries - 1:\n                            random_millisecond = randint(0, 1000) / 1000.0\n                            time.sleep(sleep_time + random_millisecond)\n                    else:\n                        raise last_ex\n                else:\n                    break\n            else:\n                # When failed after retry, we reraise the exception\n                # to exit the function to let client handle this situation\n                self.logger.error(\n                    \"Write events through HEC failed: %s. status=%s\",\n                    traceback.format_exc(),\n                    last_ex.status,\n                )\n                raise last_ex\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.HTTP_EVENT_COLLECTOR_ENDPOINT","title":"<code>HTTP_EVENT_COLLECTOR_ENDPOINT = '/services/collector'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.HTTP_INPUT_CONFIG_ENDPOINT","title":"<code>HTTP_INPUT_CONFIG_ENDPOINT = '/servicesNS/nobody/splunk_httpinput/data/inputs/http'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.SERVICE_UNAVAILABLE","title":"<code>SERVICE_UNAVAILABLE = 503</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.TOO_MANY_REQUESTS","title":"<code>TOO_MANY_REQUESTS = 429</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.WRITE_EVENT_RETRIES","title":"<code>WRITE_EVENT_RETRIES = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.description","title":"<code>description = 'HECEventWriter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.headers","title":"<code>headers = [('Content-Type', 'application/json')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.logger","title":"<code>logger = logger</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.__init__","title":"<code>__init__(hec_input_name, session_key, scheme=None, host=None, port=None, hec_uri=None, hec_token=None, global_settings_schema=True, logger=None, **context)</code>","text":"<p>Initializes HECEventWriter.</p> <p>Parameters:</p> Name Type Description Default <code>hec_input_name</code> <code>str</code> <p>Splunk HEC input name.</p> required <code>session_key</code> <code>str</code> <p>Splunk access token.</p> required <code>scheme</code> <code>str</code> <p>(optional) The access scheme, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) The host name, default is None.</p> <code>None</code> <code>port</code> <code>int</code> <p>(optional) The port number, default is None.</p> <code>None</code> <code>hec_uri</code> <code>str</code> <p>(optional) If hec_uri and hec_token are provided, they will higher precedence than hec_input_name.</p> <code>None</code> <code>hec_token</code> <code>str</code> <p>(optional) HEC token.</p> <code>None</code> <code>global_settings_schema</code> <code>bool</code> <p>(optional) if True, scheme will be set based on HEC global settings, default False.</p> <code>True</code> <code>logger</code> <code>logging.Logger</code> <p>Logger object.</p> <code>None</code> <code>context</code> <code>dict</code> <p>Other configurations for Splunk rest client.</p> <code>{}</code> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>def __init__(\n    self,\n    hec_input_name: str,\n    session_key: str,\n    scheme: str = None,\n    host: str = None,\n    port: int = None,\n    hec_uri: str = None,\n    hec_token: str = None,\n    global_settings_schema: bool = True,\n    logger: logging.Logger = None,\n    **context: dict\n):\n\"\"\"Initializes HECEventWriter.\n\n    Arguments:\n        hec_input_name: Splunk HEC input name.\n        session_key: Splunk access token.\n        scheme: (optional) The access scheme, default is None.\n        host: (optional) The host name, default is None.\n        port: (optional) The port number, default is None.\n        hec_uri: (optional) If hec_uri and hec_token are provided, they will\n            higher precedence than hec_input_name.\n        hec_token: (optional) HEC token.\n        global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n        logger: Logger object.\n        context: Other configurations for Splunk rest client.\n    \"\"\"\n    super().__init__()\n    self._session_key = session_key\n    if logger:\n        self.logger = logger\n    else:\n        self.logger = logging\n\n    if hec_uri and hec_token:\n        scheme, host, hec_port = utils.extract_http_scheme_host_port(hec_uri)\n    else:\n        if not all([scheme, host, port]):\n            scheme, host, port = get_splunkd_access_info(self._session_key)\n        hec_port, hec_token = self._get_hec_config(\n            hec_input_name, session_key, scheme, host, port, **context\n        )\n\n    if global_settings_schema:\n        scheme = get_scheme_from_hec_settings(self._session_key)\n\n    if not context.get(\"pool_connections\"):\n        context[\"pool_connections\"] = 10\n\n    if not context.get(\"pool_maxsize\"):\n        context[\"pool_maxsize\"] = 10\n\n    self._rest_client = rest_client.SplunkRestClient(\n        hec_token, app=\"-\", scheme=scheme, host=host, port=hec_port, **context\n    )\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_event","title":"<code>create_event(data, time=None, index=None, host=None, source=None, sourcetype=None, fields=None, stanza=None, unbroken=False, done=False)</code>","text":"<p>Create a new HECEvent object.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Event data.</p> required <code>time</code> <code>float</code> <p>(optional) Event timestamp, default is None.</p> <code>None</code> <code>index</code> <code>str</code> <p>(optional) The index event will be written to, default is None.</p> <code>None</code> <code>host</code> <code>str</code> <p>(optional) Event host, default is None.</p> <code>None</code> <code>source</code> <code>str</code> <p>(optional) Event source, default is None.</p> <code>None</code> <code>sourcetype</code> <code>str</code> <p>(optional) Event sourcetype, default is None.</p> <code>None</code> <code>fields</code> <code>dict</code> <p>(optional) Event fields, default is None.</p> <code>None</code> <code>stanza</code> <code>str</code> <p>(optional) Event stanza name, default is None.</p> <code>None</code> <code>unbroken</code> <code>bool</code> <p>(optional) Event unbroken flag, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter.</p> <code>False</code> <code>done</code> <code>bool</code> <p>(optional) The last unbroken event, default is False. It is only meaningful when for XMLEvent when using ClassicEventWriter.</p> <code>False</code> <p>Returns:</p> Type Description <code>HECEvent</code> <p>Created HECEvent.</p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>def create_event(\n    self,\n    data: dict,\n    time: float = None,\n    index: str = None,\n    host: str = None,\n    source: str = None,\n    sourcetype: str = None,\n    fields: dict = None,\n    stanza: str = None,\n    unbroken: bool = False,\n    done: bool = False,\n) -&gt; HECEvent:\n\"\"\"Create a new HECEvent object.\n\n    Arguments:\n        data: Event data.\n        time: (optional) Event timestamp, default is None.\n        index: (optional) The index event will be written to, default is None.\n        host: (optional) Event host, default is None.\n        source: (optional) Event source, default is None.\n        sourcetype: (optional) Event sourcetype, default is None.\n        fields: (optional) Event fields, default is None.\n        stanza: (optional) Event stanza name, default is None.\n        unbroken: (optional) Event unbroken flag, default is False.\n            It is only meaningful when for XMLEvent when using ClassicEventWriter.\n        done: (optional) The last unbroken event, default is False.\n            It is only meaningful when for XMLEvent when using ClassicEventWriter.\n\n    Returns:\n        Created HECEvent.\n    \"\"\"\n\n    return HECEvent(\n        data,\n        time=time,\n        index=index,\n        host=host,\n        source=source,\n        sourcetype=sourcetype,\n        fields=fields,\n    )\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_from_input","title":"<code>create_from_input(hec_input_name, splunkd_uri, session_key, global_settings_schema=False, **context)</code>  <code>staticmethod</code>","text":"<p>Given HEC input stanza name, splunkd URI and splunkd session key, create HECEventWriter object. HEC URI and token etc will be discovered from HEC input stanza. When hitting HEC event limit, the underlying code will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key.</p> <p>Parameters:</p> Name Type Description Default <code>hec_input_name</code> <code>str</code> <p>Splunk HEC input name.</p> required <code>splunkd_uri</code> <code>str</code> <p>Splunkd URI, like https://localhost:8089</p> required <code>session_key</code> <code>str</code> <p>Splunkd access token.</p> required <code>global_settings_schema</code> <code>bool</code> <p>(optional) if True, scheme will be set based on HEC global settings, default False.</p> <code>False</code> <code>context</code> <code>dict</code> <p>Other configurations.</p> <code>{}</code> <p>Returns:</p> Type Description <code>HECEventWriter</code> <p>Created HECEventWriter.</p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>@staticmethod\ndef create_from_input(\n    hec_input_name: str,\n    splunkd_uri: str,\n    session_key: str,\n    global_settings_schema: bool = False,\n    **context: dict\n) -&gt; \"HECEventWriter\":\n\"\"\"Given HEC input stanza name, splunkd URI and splunkd session key,\n    create HECEventWriter object. HEC URI and token etc will be discovered\n    from HEC input stanza. When hitting HEC event limit, the underlying\n    code will increase the HEC event limit automatically by calling\n    corresponding REST API against splunkd_uri by using session_key.\n\n    Arguments:\n        hec_input_name: Splunk HEC input name.\n        splunkd_uri: Splunkd URI, like https://localhost:8089\n        session_key: Splunkd access token.\n        global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n        context: Other configurations.\n\n    Returns:\n        Created HECEventWriter.\n    \"\"\"\n\n    scheme, host, port = utils.extract_http_scheme_host_port(splunkd_uri)\n    return HECEventWriter(\n        hec_input_name,\n        session_key,\n        scheme,\n        host,\n        port,\n        global_settings_schema=global_settings_schema,\n        **context\n    )\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_from_token","title":"<code>create_from_token(hec_uri, hec_token, global_settings_schema=False, **context)</code>  <code>staticmethod</code>","text":"<p>Given HEC URI and HEC token, create HECEventWriter object. This function simplifies the standalone mode HECEventWriter usage (not in a modinput).</p> <p>Parameters:</p> Name Type Description Default <code>hec_uri</code> <code>str</code> <p>HTTP Event Collector URI, like https://localhost:8088.</p> required <code>hec_token</code> <code>str</code> <p>HTTP Event Collector token.</p> required <code>global_settings_schema</code> <code>bool</code> <p>(optional) if True, scheme will be set based on HEC global settings, default False.</p> <code>False</code> <code>context</code> <code>dict</code> <p>Other configurations.</p> <code>{}</code> <p>Returns:</p> Type Description <code>HECEventWriter</code> <p>Created HECEventWriter.</p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>@staticmethod\ndef create_from_token(\n    hec_uri: str,\n    hec_token: str,\n    global_settings_schema: bool = False,\n    **context: dict\n) -&gt; \"HECEventWriter\":\n\"\"\"Given HEC URI and HEC token, create HECEventWriter object. This\n    function simplifies the standalone mode HECEventWriter usage (not in a\n    modinput).\n\n    Arguments:\n        hec_uri: HTTP Event Collector URI, like https://localhost:8088.\n        hec_token: HTTP Event Collector token.\n        global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n        context: Other configurations.\n\n    Returns:\n        Created HECEventWriter.\n    \"\"\"\n\n    warnings.warn(deprecation_msg, DeprecationWarning, stacklevel=2)\n\n    if global_settings_schema:\n        raise FunctionDeprecated(deprecation_msg)\n\n    return HECEventWriter(\n        None,\n        None,\n        None,\n        None,\n        None,\n        hec_uri=hec_uri,\n        hec_token=hec_token,\n        global_settings_schema=global_settings_schema,\n        **context\n    )\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.create_from_token_with_session_key","title":"<code>create_from_token_with_session_key(splunkd_uri, session_key, hec_uri, hec_token, global_settings_schema=False, **context)</code>  <code>staticmethod</code>","text":"<p>Given Splunkd URI, Splunkd session key, HEC URI and HEC token, create HECEventWriter object. When hitting HEC event limit, the event writer will increase the HEC event limit automatically by calling corresponding REST API against splunkd_uri by using session_key.</p> <p>Parameters:</p> Name Type Description Default <code>splunkd_uri</code> <code>str</code> <p>Splunkd URI, like https://localhost:8089.</p> required <code>session_key</code> <code>str</code> <p>Splunkd access token.</p> required <code>hec_uri</code> <code>str</code> <p>Http Event Collector URI, like https://localhost:8088.</p> required <code>hec_token</code> <code>str</code> <p>Http Event Collector token.</p> required <code>global_settings_schema</code> <code>bool</code> <p>(optional) if True, scheme will be set based on HEC global settings, default False.</p> <code>False</code> <code>context</code> <code>dict</code> <p>Other configurations.</p> <code>{}</code> <p>Returns:</p> Type Description <code>HECEventWriter</code> <p>Created HECEventWriter.</p> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>@staticmethod\ndef create_from_token_with_session_key(\n    splunkd_uri: str,\n    session_key: str,\n    hec_uri: str,\n    hec_token: str,\n    global_settings_schema: bool = False,\n    **context: dict\n) -&gt; \"HECEventWriter\":\n\"\"\"Given Splunkd URI, Splunkd session key, HEC URI and HEC token,\n    create HECEventWriter object. When hitting HEC event limit, the event\n    writer will increase the HEC event limit automatically by calling\n    corresponding REST API against splunkd_uri by using session_key.\n\n    Arguments:\n        splunkd_uri: Splunkd URI, like https://localhost:8089.\n        session_key: Splunkd access token.\n        hec_uri: Http Event Collector URI, like https://localhost:8088.\n        hec_token: Http Event Collector token.\n        global_settings_schema: (optional) if True, scheme will be set based on HEC global settings, default False.\n        context: Other configurations.\n\n    Returns:\n        Created HECEventWriter.\n    \"\"\"\n\n    scheme, host, port = utils.extract_http_scheme_host_port(splunkd_uri)\n    return HECEventWriter(\n        None,\n        session_key,\n        scheme,\n        host,\n        port,\n        hec_uri=hec_uri,\n        hec_token=hec_token,\n        global_settings_schema=global_settings_schema,\n        **context\n    )\n</code></pre>"},{"location":"modular_input/event_writer/#solnlib.modular_input.event_writer.HECEventWriter.write_events","title":"<code>write_events(events, retries=WRITE_EVENT_RETRIES, event_field='event')</code>","text":"<p>Write events to index in bulk.</p> <p>Parameters:</p> Name Type Description Default <code>events</code> <code>List</code> <p>List of events.</p> required <code>retries</code> <code>int</code> <p>Number of retries for writing events to index.</p> <code>WRITE_EVENT_RETRIES</code> <code>event_field</code> <code>str</code> <p>Event field.</p> <code>'event'</code> Source code in <code>solnlib/modular_input/event_writer.py</code> <pre><code>def write_events(\n    self,\n    events: List,\n    retries: int = WRITE_EVENT_RETRIES,\n    event_field: str = \"event\",\n):\n\"\"\"Write events to index in bulk.\n\n    Arguments:\n        events: List of events.\n        retries: Number of retries for writing events to index.\n        event_field: Event field.\n    \"\"\"\n    if not events:\n        return\n\n    last_ex = None\n    for event in HECEvent.format_events(events, event_field):\n        for i in range(retries):\n            try:\n                self._rest_client.post(\n                    self.HTTP_EVENT_COLLECTOR_ENDPOINT,\n                    body=event.encode(\"utf-8\"),\n                    headers=self.headers,\n                )\n            except binding.HTTPError as e:\n                self.logger.warn(\n                    \"Write events through HEC failed. Status=%s\", e.status\n                )\n                last_ex = e\n                if e.status in [self.TOO_MANY_REQUESTS, self.SERVICE_UNAVAILABLE]:\n                    # wait time for n retries: 10, 20, 40, 80, 80, 80, 80, ....\n                    sleep_time = min(((2 ** (i + 1)) * 5), 80)\n                    if i &lt; retries - 1:\n                        random_millisecond = randint(0, 1000) / 1000.0\n                        time.sleep(sleep_time + random_millisecond)\n                else:\n                    raise last_ex\n            else:\n                break\n        else:\n            # When failed after retry, we reraise the exception\n            # to exit the function to let client handle this situation\n            self.logger.error(\n                \"Write events through HEC failed: %s. status=%s\",\n                traceback.format_exc(),\n                last_ex.status,\n            )\n            raise last_ex\n</code></pre>"},{"location":"modular_input/modular_input/","title":"modular_input.py","text":"<p>This module provides a base class of Splunk modular input.</p>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.__all__","title":"<code>__all__ = ['ModularInputException', 'ModularInput']</code>  <code>module-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput","title":"<code>ModularInput</code>","text":"<p>Base class of Splunk modular input.</p> <p>It\u2019s a base modular input, it should be inherited by sub modular input. For sub modular input, properties: \u2018app\u2019, \u2018name\u2019, \u2018title\u2019 and \u2018description\u2019 must be overriden, also there are some other optional properties can be overriden like: \u2018use_external_validation\u2019, \u2018use_single_instance\u2019, \u2018use_kvstore_checkpointer\u2019 and \u2018use_hec_event_writer\u2019.</p> <p>Notes: If you set \u2018KVStoreCheckpointer\u2019 or \u2018use_hec_event_writer\u2019 to True, you must override the corresponding \u2018kvstore_checkpointer_collection_name\u2019 and \u2018hec_input_name\u2019.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TestModularInput(ModularInput):\n&gt;&gt;&gt;     app = 'TestApp'\n&gt;&gt;&gt;     name = 'test_modular_input'\n&gt;&gt;&gt;     title = 'Test modular input'\n&gt;&gt;&gt;     description = 'This is a test modular input'\n&gt;&gt;&gt;     use_external_validation = True\n&gt;&gt;&gt;     use_single_instance = False\n&gt;&gt;&gt;     use_kvstore_checkpointer = True\n&gt;&gt;&gt;     kvstore_checkpointer_collection_name = 'TestCheckpoint'\n&gt;&gt;&gt;     use_hec_event_writer = True\n&gt;&gt;&gt;     hec_input_name = 'TestEventWriter'\n&gt;&gt;&gt;\n&gt;&gt;&gt;     def extra_arguments(self):\n&gt;&gt;&gt;         ... .. .\n&gt;&gt;&gt;\n&gt;&gt;&gt;     def do_validation(self, parameters):\n&gt;&gt;&gt;         ... .. .\n&gt;&gt;&gt;\n&gt;&gt;&gt;     def do_run(self, inputs):\n&gt;&gt;&gt;         ... .. .\n&gt;&gt;&gt;\n&gt;&gt;&gt; if __name__ == '__main__':\n&gt;&gt;&gt;     md = TestModularInput()\n&gt;&gt;&gt;     md.execute()\n</code></pre> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>class ModularInput(metaclass=ABCMeta):\n\"\"\"Base class of Splunk modular input.\n\n    It's a base modular input, it should be inherited by sub modular input. For\n    sub modular input, properties: 'app', 'name', 'title' and 'description' must\n    be overriden, also there are some other optional properties can be overriden\n    like: 'use_external_validation', 'use_single_instance', 'use_kvstore_checkpointer'\n    and 'use_hec_event_writer'.\n\n    Notes: If you set 'KVStoreCheckpointer' or 'use_hec_event_writer' to True,\n    you must override the corresponding 'kvstore_checkpointer_collection_name'\n    and 'hec_input_name'.\n\n    Examples:\n\n       &gt;&gt;&gt; class TestModularInput(ModularInput):\n       &gt;&gt;&gt;     app = 'TestApp'\n       &gt;&gt;&gt;     name = 'test_modular_input'\n       &gt;&gt;&gt;     title = 'Test modular input'\n       &gt;&gt;&gt;     description = 'This is a test modular input'\n       &gt;&gt;&gt;     use_external_validation = True\n       &gt;&gt;&gt;     use_single_instance = False\n       &gt;&gt;&gt;     use_kvstore_checkpointer = True\n       &gt;&gt;&gt;     kvstore_checkpointer_collection_name = 'TestCheckpoint'\n       &gt;&gt;&gt;     use_hec_event_writer = True\n       &gt;&gt;&gt;     hec_input_name = 'TestEventWriter'\n       &gt;&gt;&gt;\n       &gt;&gt;&gt;     def extra_arguments(self):\n       &gt;&gt;&gt;         ... .. .\n       &gt;&gt;&gt;\n       &gt;&gt;&gt;     def do_validation(self, parameters):\n       &gt;&gt;&gt;         ... .. .\n       &gt;&gt;&gt;\n       &gt;&gt;&gt;     def do_run(self, inputs):\n       &gt;&gt;&gt;         ... .. .\n       &gt;&gt;&gt;\n       &gt;&gt;&gt; if __name__ == '__main__':\n       &gt;&gt;&gt;     md = TestModularInput()\n       &gt;&gt;&gt;     md.execute()\n    \"\"\"\n\n    # App name, must be overridden\n    app = None\n    # Modular input name, must be overridden\n    name = None\n    # Modular input scheme title, must be overridden\n    title = None\n    # Modular input scheme description, must be overridden\n    description = None\n    # Modular input scheme use external validation, default is False\n    use_external_validation = False\n    # Modular input scheme use single instance mode, default is False\n    use_single_instance = False\n    # Use kvstore as checkpointer, default is True\n    use_kvstore_checkpointer = True\n    # Collection name of kvstore checkpointer, must be overridden if\n    # use_kvstore_checkpointer is True\n    kvstore_checkpointer_collection_name = None\n    # Use hec event writer\n    use_hec_event_writer = True\n    # Input name of Splunk HEC, must be overridden if use_hec_event_writer\n    # is True\n    hec_input_name = None\n    hec_global_settings_schema = False\n\n    def __init__(self):\n        # Validate properties\n        self._validate_properties()\n        # Modular input state\n        self.should_exit = False\n        # Metadata\n        self.server_host_name = None\n        self.server_uri = None\n        self.server_scheme = None\n        self.server_host = None\n        self.server_port = None\n        self.session_key = None\n        # Modular input config name\n        self.config_name = None\n        # Checkpoint dir\n        self._checkpoint_dir = None\n        # Checkpointer\n        self._checkpointer = None\n        # Orphan process monitor\n        self._orphan_monitor = None\n        # Event writer\n        self._event_writer = None\n\n    def _validate_properties(self):\n        if not all([self.app, self.name, self.title, self.description]):\n            raise ModularInputException(\n                'Attributes: \"app\", \"name\", \"title\", \"description\" must '\n                \"be overriden.\"\n            )\n\n        if self.use_kvstore_checkpointer:\n            if self.kvstore_checkpointer_collection_name is None:\n                raise ModularInputException(\n                    'Attribute: \"kvstore_checkpointer_collection_name\" must'\n                    'be overriden if \"use_kvstore_checkpointer\" is True\".'\n                )\n            elif self.kvstore_checkpointer_collection_name.strip() == \"\":\n                raise ModularInputException(\n                    'Attribute: \"kvstore_checkpointer_collection_name\" can'\n                    \" not be empty.\"\n                )\n\n        if self.use_hec_event_writer:\n            if self.hec_input_name is None:\n                raise ModularInputException(\n                    'Attribute: \"hec_input_name\" must be overriden '\n                    'if \"use_hec_event_writer\" is True.'\n                )\n            elif self.hec_input_name.strip() == \"\":\n                raise ModularInputException(\n                    'Attribute: \"hec_input_name\" can not be empty.'\n                )\n\n    @property\n    def checkpointer(self) -&gt; checkpointer.Checkpointer:\n\"\"\"Get checkpointer object.\n\n        The checkpointer returned depends on use_kvstore_checkpointer flag,\n        if use_kvstore_checkpointer is true will return an KVStoreCheckpointer\n        object else an FileCheckpointer object.\n\n        Returns:\n            A checkpointer object.\n        \"\"\"\n\n        if self._checkpointer is not None:\n            return self._checkpointer\n\n        self._checkpointer = self._create_checkpointer()\n        return self._checkpointer\n\n    def _create_checkpointer(self):\n        if self.use_kvstore_checkpointer:\n            checkpointer_name = \":\".join(\n                [self.app, self.config_name, self.kvstore_checkpointer_collection_name]\n            )\n            try:\n                return checkpointer.KVStoreCheckpointer(\n                    checkpointer_name,\n                    self.session_key,\n                    self.app,\n                    owner=\"nobody\",\n                    scheme=self.server_scheme,\n                    host=self.server_host,\n                    port=self.server_port,\n                )\n            except binding.HTTPError:\n                logging.error(\n                    \"Failed to init kvstore checkpointer: %s.\", traceback.format_exc()\n                )\n                raise\n        else:\n            return checkpointer.FileCheckpointer(self._checkpoint_dir)\n\n    @property\n    def event_writer(self) -&gt; event_writer.EventWriter:\n\"\"\"Get event writer object.\n\n        The event writer returned depends on use_hec_event_writer flag,\n        if use_hec_event_writer is true will return an HECEventWriter\n        object else an ClassicEventWriter object.\n\n        Returns:\n            Event writer object.\n        \"\"\"\n\n        if self._event_writer is not None:\n            return self._event_writer\n\n        self._event_writer = self._create_event_writer()\n        return self._event_writer\n\n    def _create_event_writer(self):\n        if self.use_hec_event_writer:\n            hec_input_name = \":\".join([self.app, self.hec_input_name])\n            try:\n                return event_writer.HECEventWriter(\n                    hec_input_name,\n                    self.session_key,\n                    scheme=self.server_scheme,\n                    host=self.server_host,\n                    port=self.server_port,\n                    global_settings_schema=self.hec_global_settings_schema,\n                )\n            except binding.HTTPError:\n                logging.error(\n                    \"Failed to init HECEventWriter: %s.\", traceback.format_exc()\n                )\n                raise\n        else:\n            return event_writer.ClassicEventWriter()\n\n    def _update_metadata(self, metadata):\n        self.server_host_name = metadata[\"server_host\"]\n        splunkd = urlparse.urlsplit(metadata[\"server_uri\"])\n        self.server_uri = splunkd.geturl()\n        self.server_scheme = splunkd.scheme\n        self.server_host = splunkd.hostname\n        self.server_port = splunkd.port\n        self.session_key = metadata[\"session_key\"]\n        self._checkpoint_dir = metadata[\"checkpoint_dir\"]\n\n    def _do_scheme(self):\n        scheme = Scheme(self.title)\n        scheme.description = self.description\n        scheme.use_external_validation = self.use_external_validation\n        scheme.streaming_mode = Scheme.streaming_mode_xml\n        scheme.use_single_instance = self.use_single_instance\n\n        for argument in self.extra_arguments():\n            name = argument[\"name\"]\n            title = argument.get(\"title\", None)\n            description = argument.get(\"description\", None)\n            validation = argument.get(\"validation\", None)\n            data_type = argument.get(\"data_type\", Argument.data_type_string)\n            required_on_edit = argument.get(\"required_on_edit\", False)\n            required_on_create = argument.get(\"required_on_create\", False)\n\n            scheme.add_argument(\n                Argument(\n                    name,\n                    title=title,\n                    description=description,\n                    validation=validation,\n                    data_type=data_type,\n                    required_on_edit=required_on_edit,\n                    required_on_create=required_on_create,\n                )\n            )\n\n        return defused_et.tostring(scheme.to_xml(), encoding=\"unicode\")\n\n    def extra_arguments(self) -&gt; List:\n\"\"\"Extra arguments for modular input.\n\n        Default implementation is returning an empty list.\n\n        Returns:\n            List of arguments like::\n\n                [\n                    {\n                        'name': 'arg1',\n                        'title': 'arg1 title',\n                        'description': 'arg1 description',\n                        'validation': 'arg1 validation statement',\n                        'data_type': Argument.data_type_string,\n                        'required_on_edit': False,\n                        'required_on_create': False\n                    },\n                    {...},\n                    {...}\n                ]\n        \"\"\"\n\n        return []\n\n    def do_validation(self, parameters):\n\"\"\"Handles external validation for modular input kinds.\n\n        When Splunk calls a modular input script in validation mode, it will\n        pass in an XML document giving information about the Splunk instance\n        (so you can call back into it if needed) and the name and parameters\n        of the proposed input. If this function does not throw an exception,\n        the validation is assumed to succeed. Otherwise any errors thrown will\n        be turned into a string and logged back to Splunk.\n\n        Arguments:\n            parameters: The parameters of input passed by splunkd.\n\n        Raises:\n            Exception: If validation is failed.\n        \"\"\"\n\n        pass\n\n    @abstractmethod\n    def do_run(self, inputs: dict):\n\"\"\"Runs this modular input.\n\n        Arguments:\n            inputs: Command line arguments passed to this modular input.\n                For single instance mode, inputs like::\n\n                    {\n                    'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                    'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                    'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                    }\n\n                For multiple instance mode, inputs like::\n\n                    {\n                    'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                    }\n        \"\"\"\n\n        pass\n\n    def register_teardown_handler(self, handler: Callable, *args):\n\"\"\"Register teardown signal handler.\n\n        Arguments:\n            handler: Teardown signal handler.\n            args: Arguments to the handler.\n\n        Examples:\n           &gt;&gt;&gt; mi = ModularInput(...)\n           &gt;&gt;&gt; def teardown_handler(arg1, arg2, ...):\n           &gt;&gt;&gt;     ...\n           &gt;&gt;&gt; mi.register_teardown_handler(teardown_handler, arg1, arg2, ...)\n        \"\"\"\n\n        def _teardown_handler(signum, frame):\n            handler(*args)\n\n        utils.handle_teardown_signals(_teardown_handler)\n\n    def register_orphan_handler(self, handler: Callable, *args):\n\"\"\"Register orphan process handler.\n\n        Arguments:\n            handler: Teardown signal handler.\n            args: Arguments to the handler.\n\n        Examples:\n           &gt;&gt;&gt; mi = ModularInput(...)\n           &gt;&gt;&gt; def orphan_handler(arg1, arg2, ...):\n           &gt;&gt;&gt;     ...\n           &gt;&gt;&gt; mi.register_orphan_handler(orphan_handler, arg1, arg2, ...)\n        \"\"\"\n\n        def _orphan_handler():\n            handler(*args)\n\n        if self._orphan_monitor is None:\n            self._orphan_monitor = OrphanProcessMonitor(_orphan_handler)\n            self._orphan_monitor.start()\n\n    def get_validation_definition(self) -&gt; dict:\n\"\"\"Get validation definition.\n\n        This method can be overwritten to get validation definition from\n        other input instead `stdin`.\n\n        Returns:\n            A dict object must contains `metadata` and `parameters`::\n\n                example: {\n                    'metadata': {\n                    'session_key': 'iCKPS0cvmpyeJk...sdaf',\n                    'server_host': 'test-test.com',\n                    'server_uri': 'https://127.0.0.1:8089',\n                    'checkpoint_dir': '/tmp'\n                    },\n                    parameters: {'args1': value1, 'args2': value2}\n                }\n        \"\"\"\n\n        validation_definition = ValidationDefinition.parse(sys.stdin)\n        return {\n            \"metadata\": validation_definition.metadata,\n            \"parameters\": validation_definition.parameters,\n        }\n\n    def get_input_definition(self) -&gt; dict:\n\"\"\"Get input definition.\n\n        This method can be overwritten to get input definition from\n        other input instead `stdin`.\n\n        Returns:\n            A dict object must contain `metadata` and `inputs`::\n\n                example: {\n                    'metadata': {\n                    'session_key': 'iCKPS0cvmpyeJk...sdaf',\n                    'server_host': 'test-test.com',\n                    'server_uri': 'https://127.0.0.1:8089',\n                    'checkpoint_dir': '/tmp'\n                    },\n                    inputs: {\n                    'stanza1': {'arg1': value1, 'arg2': value2},\n                    'stanza2': {'arg1': value1, 'arg2': value2}\n                    }\n                }\n        \"\"\"\n\n        input_definition = InputDefinition.parse(sys.stdin)\n        return {\n            \"metadata\": input_definition.metadata,\n            \"inputs\": input_definition.inputs,\n        }\n\n    def execute(self):\n\"\"\"Modular input entry.\n\n        Examples:\n           &gt;&gt;&gt; class TestModularInput(ModularInput):\n           &gt;&gt;&gt;         ... .. .\n           &gt;&gt;&gt;\n           &gt;&gt;&gt; if __name__ == '__main__':\n           &gt;&gt;&gt;     md = TestModularInput()\n           &gt;&gt;&gt;     md.execute()\n        \"\"\"\n\n        if len(sys.argv) == 1:\n            try:\n                input_definition = self.get_input_definition()\n                self._update_metadata(input_definition[\"metadata\"])\n                if self.use_single_instance:\n                    self.config_name = self.name\n                else:\n                    self.config_name = list(input_definition[\"inputs\"].keys())[0]\n                self.do_run(input_definition[\"inputs\"])\n                logging.info(\"Modular input: %s exit normally.\", self.name)\n                return 0\n            except Exception:\n                logging.error(\n                    \"Modular input: %s exit with exception: %s.\",\n                    self.name,\n                    traceback.format_exc(),\n                )\n                return 1\n            finally:\n                # Stop orphan monitor if any\n                if self._orphan_monitor:\n                    self._orphan_monitor.stop()\n\n        elif str(sys.argv[1]).lower() == \"--scheme\":\n            sys.stdout.write(self._do_scheme())\n            sys.stdout.flush()\n            return 0\n\n        elif sys.argv[1].lower() == \"--validate-arguments\":\n            try:\n                validation_definition = self.get_validation_definition()\n                self._update_metadata(validation_definition[\"metadata\"])\n                self.do_validation(validation_definition[\"parameters\"])\n                return 0\n            except Exception as e:\n                logging.error(\n                    \"Modular input: %s validate arguments with exception: %s.\",\n                    self.name,\n                    traceback.format_exc(),\n                )\n                root = ET.Element(\"error\")\n                ET.SubElement(root, \"message\").text = str(e)\n                sys.stderr.write(defused_et.tostring(root))\n                sys.stderr.flush()\n                return 1\n        else:\n            logging.error(\n                'Modular input: %s run with invalid arguments: \"%s\".',\n                self.name,\n                \" \".join(sys.argv[1:]),\n            )\n            return 1\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.app","title":"<code>app = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.checkpointer","title":"<code>checkpointer: checkpointer.Checkpointer</code>  <code>property</code>","text":"<p>Get checkpointer object.</p> <p>The checkpointer returned depends on use_kvstore_checkpointer flag, if use_kvstore_checkpointer is true will return an KVStoreCheckpointer object else an FileCheckpointer object.</p> <p>Returns:</p> Type Description <code>checkpointer.Checkpointer</code> <p>A checkpointer object.</p>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.config_name","title":"<code>config_name = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.description","title":"<code>description = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.event_writer","title":"<code>event_writer: event_writer.EventWriter</code>  <code>property</code>","text":"<p>Get event writer object.</p> <p>The event writer returned depends on use_hec_event_writer flag, if use_hec_event_writer is true will return an HECEventWriter object else an ClassicEventWriter object.</p> <p>Returns:</p> Type Description <code>event_writer.EventWriter</code> <p>Event writer object.</p>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.hec_global_settings_schema","title":"<code>hec_global_settings_schema = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.hec_input_name","title":"<code>hec_input_name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.kvstore_checkpointer_collection_name","title":"<code>kvstore_checkpointer_collection_name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.name","title":"<code>name = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.server_host","title":"<code>server_host = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.server_host_name","title":"<code>server_host_name = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.server_port","title":"<code>server_port = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.server_scheme","title":"<code>server_scheme = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.server_uri","title":"<code>server_uri = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.session_key","title":"<code>session_key = None</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.should_exit","title":"<code>should_exit = False</code>  <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.title","title":"<code>title = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_external_validation","title":"<code>use_external_validation = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_hec_event_writer","title":"<code>use_hec_event_writer = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_kvstore_checkpointer","title":"<code>use_kvstore_checkpointer = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.use_single_instance","title":"<code>use_single_instance = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.__init__","title":"<code>__init__()</code>","text":"Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def __init__(self):\n    # Validate properties\n    self._validate_properties()\n    # Modular input state\n    self.should_exit = False\n    # Metadata\n    self.server_host_name = None\n    self.server_uri = None\n    self.server_scheme = None\n    self.server_host = None\n    self.server_port = None\n    self.session_key = None\n    # Modular input config name\n    self.config_name = None\n    # Checkpoint dir\n    self._checkpoint_dir = None\n    # Checkpointer\n    self._checkpointer = None\n    # Orphan process monitor\n    self._orphan_monitor = None\n    # Event writer\n    self._event_writer = None\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.do_run","title":"<code>do_run(inputs)</code>  <code>abstractmethod</code>","text":"<p>Runs this modular input.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>dict</code> <p>Command line arguments passed to this modular input. For single instance mode, inputs like::</p> <pre><code>{\n'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n}\n</code></pre> <p>For multiple instance mode, inputs like::</p> <pre><code>{\n'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n}\n</code></pre> required Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>@abstractmethod\ndef do_run(self, inputs: dict):\n\"\"\"Runs this modular input.\n\n    Arguments:\n        inputs: Command line arguments passed to this modular input.\n            For single instance mode, inputs like::\n\n                {\n                'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                'stanza_name2': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                'stanza_name3': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                }\n\n            For multiple instance mode, inputs like::\n\n                {\n                'stanza_name1': {'arg1': 'arg1_value', 'arg2': 'arg2_value', ...}\n                }\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.do_validation","title":"<code>do_validation(parameters)</code>","text":"<p>Handles external validation for modular input kinds.</p> <p>When Splunk calls a modular input script in validation mode, it will pass in an XML document giving information about the Splunk instance (so you can call back into it if needed) and the name and parameters of the proposed input. If this function does not throw an exception, the validation is assumed to succeed. Otherwise any errors thrown will be turned into a string and logged back to Splunk.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <p>The parameters of input passed by splunkd.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If validation is failed.</p> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def do_validation(self, parameters):\n\"\"\"Handles external validation for modular input kinds.\n\n    When Splunk calls a modular input script in validation mode, it will\n    pass in an XML document giving information about the Splunk instance\n    (so you can call back into it if needed) and the name and parameters\n    of the proposed input. If this function does not throw an exception,\n    the validation is assumed to succeed. Otherwise any errors thrown will\n    be turned into a string and logged back to Splunk.\n\n    Arguments:\n        parameters: The parameters of input passed by splunkd.\n\n    Raises:\n        Exception: If validation is failed.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.execute","title":"<code>execute()</code>","text":"<p>Modular input entry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class TestModularInput(ModularInput):\n&gt;&gt;&gt;         ... .. .\n&gt;&gt;&gt;\n&gt;&gt;&gt; if __name__ == '__main__':\n&gt;&gt;&gt;     md = TestModularInput()\n&gt;&gt;&gt;     md.execute()\n</code></pre> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def execute(self):\n\"\"\"Modular input entry.\n\n    Examples:\n       &gt;&gt;&gt; class TestModularInput(ModularInput):\n       &gt;&gt;&gt;         ... .. .\n       &gt;&gt;&gt;\n       &gt;&gt;&gt; if __name__ == '__main__':\n       &gt;&gt;&gt;     md = TestModularInput()\n       &gt;&gt;&gt;     md.execute()\n    \"\"\"\n\n    if len(sys.argv) == 1:\n        try:\n            input_definition = self.get_input_definition()\n            self._update_metadata(input_definition[\"metadata\"])\n            if self.use_single_instance:\n                self.config_name = self.name\n            else:\n                self.config_name = list(input_definition[\"inputs\"].keys())[0]\n            self.do_run(input_definition[\"inputs\"])\n            logging.info(\"Modular input: %s exit normally.\", self.name)\n            return 0\n        except Exception:\n            logging.error(\n                \"Modular input: %s exit with exception: %s.\",\n                self.name,\n                traceback.format_exc(),\n            )\n            return 1\n        finally:\n            # Stop orphan monitor if any\n            if self._orphan_monitor:\n                self._orphan_monitor.stop()\n\n    elif str(sys.argv[1]).lower() == \"--scheme\":\n        sys.stdout.write(self._do_scheme())\n        sys.stdout.flush()\n        return 0\n\n    elif sys.argv[1].lower() == \"--validate-arguments\":\n        try:\n            validation_definition = self.get_validation_definition()\n            self._update_metadata(validation_definition[\"metadata\"])\n            self.do_validation(validation_definition[\"parameters\"])\n            return 0\n        except Exception as e:\n            logging.error(\n                \"Modular input: %s validate arguments with exception: %s.\",\n                self.name,\n                traceback.format_exc(),\n            )\n            root = ET.Element(\"error\")\n            ET.SubElement(root, \"message\").text = str(e)\n            sys.stderr.write(defused_et.tostring(root))\n            sys.stderr.flush()\n            return 1\n    else:\n        logging.error(\n            'Modular input: %s run with invalid arguments: \"%s\".',\n            self.name,\n            \" \".join(sys.argv[1:]),\n        )\n        return 1\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.extra_arguments","title":"<code>extra_arguments()</code>","text":"<p>Extra arguments for modular input.</p> <p>Default implementation is returning an empty list.</p> <p>Returns:</p> Type Description <code>List</code> <p>List of arguments like::</p> <p>[     {         \u2018name\u2019: \u2018arg1\u2019,         \u2018title\u2019: \u2018arg1 title\u2019,         \u2018description\u2019: \u2018arg1 description\u2019,         \u2018validation\u2019: \u2018arg1 validation statement\u2019,         \u2018data_type\u2019: Argument.data_type_string,         \u2018required_on_edit\u2019: False,         \u2018required_on_create\u2019: False     },     {\u2026},     {\u2026} ]</p> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def extra_arguments(self) -&gt; List:\n\"\"\"Extra arguments for modular input.\n\n    Default implementation is returning an empty list.\n\n    Returns:\n        List of arguments like::\n\n            [\n                {\n                    'name': 'arg1',\n                    'title': 'arg1 title',\n                    'description': 'arg1 description',\n                    'validation': 'arg1 validation statement',\n                    'data_type': Argument.data_type_string,\n                    'required_on_edit': False,\n                    'required_on_create': False\n                },\n                {...},\n                {...}\n            ]\n    \"\"\"\n\n    return []\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.get_input_definition","title":"<code>get_input_definition()</code>","text":"<p>Get input definition.</p> <p>This method can be overwritten to get input definition from other input instead <code>stdin</code>.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict object must contain <code>metadata</code> and <code>inputs</code>::</p> <p>example: {     \u2018metadata\u2019: {     \u2018session_key\u2019: \u2018iCKPS0cvmpyeJk\u2026sdaf\u2019,     \u2018server_host\u2019: \u2018test-test.com\u2019,     \u2018server_uri\u2019: \u2018https://127.0.0.1:8089\u2019,     \u2018checkpoint_dir\u2019: \u2018/tmp\u2019     },     inputs: {     \u2018stanza1\u2019: {\u2018arg1\u2019: value1, \u2018arg2\u2019: value2},     \u2018stanza2\u2019: {\u2018arg1\u2019: value1, \u2018arg2\u2019: value2}     } }</p> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def get_input_definition(self) -&gt; dict:\n\"\"\"Get input definition.\n\n    This method can be overwritten to get input definition from\n    other input instead `stdin`.\n\n    Returns:\n        A dict object must contain `metadata` and `inputs`::\n\n            example: {\n                'metadata': {\n                'session_key': 'iCKPS0cvmpyeJk...sdaf',\n                'server_host': 'test-test.com',\n                'server_uri': 'https://127.0.0.1:8089',\n                'checkpoint_dir': '/tmp'\n                },\n                inputs: {\n                'stanza1': {'arg1': value1, 'arg2': value2},\n                'stanza2': {'arg1': value1, 'arg2': value2}\n                }\n            }\n    \"\"\"\n\n    input_definition = InputDefinition.parse(sys.stdin)\n    return {\n        \"metadata\": input_definition.metadata,\n        \"inputs\": input_definition.inputs,\n    }\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.get_validation_definition","title":"<code>get_validation_definition()</code>","text":"<p>Get validation definition.</p> <p>This method can be overwritten to get validation definition from other input instead <code>stdin</code>.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict object must contains <code>metadata</code> and <code>parameters</code>::</p> <p>example: {     \u2018metadata\u2019: {     \u2018session_key\u2019: \u2018iCKPS0cvmpyeJk\u2026sdaf\u2019,     \u2018server_host\u2019: \u2018test-test.com\u2019,     \u2018server_uri\u2019: \u2018https://127.0.0.1:8089\u2019,     \u2018checkpoint_dir\u2019: \u2018/tmp\u2019     },     parameters: {\u2018args1\u2019: value1, \u2018args2\u2019: value2} }</p> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def get_validation_definition(self) -&gt; dict:\n\"\"\"Get validation definition.\n\n    This method can be overwritten to get validation definition from\n    other input instead `stdin`.\n\n    Returns:\n        A dict object must contains `metadata` and `parameters`::\n\n            example: {\n                'metadata': {\n                'session_key': 'iCKPS0cvmpyeJk...sdaf',\n                'server_host': 'test-test.com',\n                'server_uri': 'https://127.0.0.1:8089',\n                'checkpoint_dir': '/tmp'\n                },\n                parameters: {'args1': value1, 'args2': value2}\n            }\n    \"\"\"\n\n    validation_definition = ValidationDefinition.parse(sys.stdin)\n    return {\n        \"metadata\": validation_definition.metadata,\n        \"parameters\": validation_definition.parameters,\n    }\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.register_orphan_handler","title":"<code>register_orphan_handler(handler, *args)</code>","text":"<p>Register orphan process handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>Teardown signal handler.</p> required <code>args</code> <p>Arguments to the handler.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mi = ModularInput(...)\n&gt;&gt;&gt; def orphan_handler(arg1, arg2, ...):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt; mi.register_orphan_handler(orphan_handler, arg1, arg2, ...)\n</code></pre> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def register_orphan_handler(self, handler: Callable, *args):\n\"\"\"Register orphan process handler.\n\n    Arguments:\n        handler: Teardown signal handler.\n        args: Arguments to the handler.\n\n    Examples:\n       &gt;&gt;&gt; mi = ModularInput(...)\n       &gt;&gt;&gt; def orphan_handler(arg1, arg2, ...):\n       &gt;&gt;&gt;     ...\n       &gt;&gt;&gt; mi.register_orphan_handler(orphan_handler, arg1, arg2, ...)\n    \"\"\"\n\n    def _orphan_handler():\n        handler(*args)\n\n    if self._orphan_monitor is None:\n        self._orphan_monitor = OrphanProcessMonitor(_orphan_handler)\n        self._orphan_monitor.start()\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInput.register_teardown_handler","title":"<code>register_teardown_handler(handler, *args)</code>","text":"<p>Register teardown signal handler.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>Teardown signal handler.</p> required <code>args</code> <p>Arguments to the handler.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mi = ModularInput(...)\n&gt;&gt;&gt; def teardown_handler(arg1, arg2, ...):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt; mi.register_teardown_handler(teardown_handler, arg1, arg2, ...)\n</code></pre> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>def register_teardown_handler(self, handler: Callable, *args):\n\"\"\"Register teardown signal handler.\n\n    Arguments:\n        handler: Teardown signal handler.\n        args: Arguments to the handler.\n\n    Examples:\n       &gt;&gt;&gt; mi = ModularInput(...)\n       &gt;&gt;&gt; def teardown_handler(arg1, arg2, ...):\n       &gt;&gt;&gt;     ...\n       &gt;&gt;&gt; mi.register_teardown_handler(teardown_handler, arg1, arg2, ...)\n    \"\"\"\n\n    def _teardown_handler(signum, frame):\n        handler(*args)\n\n    utils.handle_teardown_signals(_teardown_handler)\n</code></pre>"},{"location":"modular_input/modular_input/#solnlib.modular_input.modular_input.ModularInputException","title":"<code>ModularInputException</code>","text":"<p>         Bases: <code>Exception</code></p> <p>Exception for ModularInput class.</p> Source code in <code>solnlib/modular_input/modular_input.py</code> <pre><code>class ModularInputException(Exception):\n\"\"\"Exception for ModularInput class.\"\"\"\n\n    pass\n</code></pre>"}]}